--------------------------------------------------1--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]# <span class="term_command">date --help</span>
Usage: date [OPTION]... [+FORMAT]                           <span class="term_note"># 这里有基本语法</span>
  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]  <span class="term_note"># 这是设置时间的语法</span>
Display the current time in the given FORMAT, or set the system date.
<span class="term_note"># 下面是主要的选项说明</span>
Mandatory arguments to long options are mandatory for short options too.
  -d, --date=STRING         display time described by STRING, not 'now'
  -f, --file=DATEFILE       like --date once for each line of DATEFILE
<span class="term_say">....（中间省略）....</span>
  -u, --utc, --universal    print or set Coordinated Universal Time （UTC）
      --help     显示此求助说明并离开
      --version  显示版本信息并离开
<span class="term_note"># 下面则是重要的格式 （FORMAT） 的主要项目</span>
FORMAT controls the output.  Interpreted sequences are:

  %%   a literal %
  %a   locale's abbreviated weekday name （e.g., Sun）
  %A   locale's full weekday name （e.g., Sunday）
<span class="term_say">....（中间省略）....</span>
<span class="term_note"># 下面是几个重要的范例 （Example）</span>
Examples:
Convert seconds since the epoch （1970-01-01 UTC） to a date
  $ date --date='@2147483647'
<span class="term_say">....（下面省略）....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 1--------------------------------------------------<br/>--------------------------------------------------2--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">/sbin/shutdown [-krhc] [时间] [警告讯息]</span>
<span class="term_say">选项与参数：
-k     ： 不要真的关机，只是发送警告讯息出去！
-r     ： 在将系统的服务停掉之后就重新开机（常用）
-h     ： 将系统的服务停掉后，立即关机。 （常用）
-c     ： 取消已经在进行的 shutdown 指令内容。
时间   ： 指定系统关机的时间！时间的范例下面会说明。若没有这个项目，则默认 1 分钟后自动进行。
范例：</span>
[root@study ~]# <span class="term_command">/sbin/shutdown -h 10 'I will shutdown after 10 mins'</span>
Broadcast message from root@study.centos.vbird （Tue 2015-06-02 10:51:34 CST）:

I will shutdown after 10 mins
The system is going down for power-off at Tue 2015-06-02 11:01:34 CST!
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 2--------------------------------------------------<br/>--------------------------------------------------3--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">su -</span>  <span class="term_note"># 先来切换一下身份看看</span>
Password:
Last login: Tue Jun  2 19:32:31 CST 2015 on tty2
[root@study ~]# <span class="term_command">ls -al</span>
<span>total 48
dr-xr-x---.  5    root     root    4096  May 29 16:08 .
dr-xr-xr-x. 17    root     root    4096  May  4 17:56 ..
-rw-------.  1    root     root    1816  May  4 17:57 anaconda-ks.cfg
-rw-------.  1    root     root     927  Jun  2 11:27 .bash_history
-rw-r--r--.  1    root     root      18  Dec 29  2013 .bash_logout
-rw-r--r--.  1    root     root     176  Dec 29  2013 .bash_profile
-rw-r--r--.  1    root     root     176  Dec 29  2013 .bashrc
<span class="calibre34">drwxr-xr-x.  3    root     root      17  May  6 00:14 .config</span>               <span class="term_note">&lt;=范例说明处</span>
drwx------.  3    root     root      24  May  4 17:59 .dbus
<span class="calibre34">-rw-r--r--.  1    root     root    1864  May  4 18:01 initial-setup-ks.cfg</span>  <span class="term_note">&lt;=范例说明处</span>
[    1    ][  2 ][   3  ][  4 ][    5   ][    6     ] [       7          ]
[  权限   ][链接][拥有者][群组][文件大小][ 修改日期 ] [      文件名        ]</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 3--------------------------------------------------<br/>--------------------------------------------------4--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">chgrp [-R] dirname/filename ...</span>
<span class="term_say">选项与参数：
-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录
     都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。
范例：</span>
[root@study ~]# <span class="term_command">chgrp users initial-setup-ks.cfg</span>
[root@study ~]# <span class="term_command">ls -l</span>
-rw-r--r--. 1 root <span class="term_command">users</span> 1864 May  4 18:01 initial-setup-ks.cfg
[root@study ~]# <span class="term_command">chgrp testing initial-setup-ks.cfg</span>
chgrp: invalid group:  `testing' <span class="term_note">&lt;== 发生错误讯息啰～找不到这个群组名～</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 4--------------------------------------------------<br/>--------------------------------------------------5--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">chown [-R] 帐号名称 文件或目录</span>
[root@study ~]# <span class="term_command">chown [-R] 帐号名称:群组名称 文件或目录</span>
<span class="term_say">选项与参数：
-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都变更</span>

<span class="term_hd">范例：将 initial-setup-ks.cfg 的拥有者改为bin这个帐号：</span>
[root@study ~]# <span class="term_command">chown bin initial-setup-ks.cfg</span>
[root@study ~]# <span class="term_command">ls -l</span>
-rw-r--r--. 1 <span class="term_command">bin</span>  users 1864 May  4 18:01 initial-setup-ks.cfg

<span class="term_hd">范例：将 initial-setup-ks.cfg 的拥有者与群组改回为root：</span>
[root@study ~]# <span class="term_command">chown root:root initial-setup-ks.cfg</span>
[root@study ~]# <span class="term_command">ls -l</span>
-rw-r--r--. 1 <span class="term_command">root root</span> 1864 May  4 18:01 initial-setup-ks.cfg
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 5--------------------------------------------------<br/>--------------------------------------------------6--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">pwd [-P]</span>
<span class="term_say">选项与参数：
-P  ：显示出确实的路径，而非使用链接 （link） 路径。</span>

<span class="term_hd">范例：单纯显示出目前的工作目录：</span>
[root@study ~]# <span class="term_command">pwd</span>
/root   <span class="term_note">&lt;== 显示出目录啦～</span>

<span class="term_hd">范例：显示出实际的工作目录，而非链接文件本身的目录名而已</span>
[root@study ~]# <span class="term_command">cd /var/mail</span>   <span class="term_note">&lt;==注意，/var/mail是一个链接文件</span>
[root@study mail]# <span class="term_command">pwd</span>
/var/mail         <span class="term_note">&lt;==列出目前的工作目录</span>
[root@study mail]# <span class="term_command">pwd -P</span>
/var/spool/mail   <span class="term_note">&lt;==怎么回事？有没有加 -P 差很多～</span>
[root@study mail]# <span class="term_command">ls -ld /var/mail</span>
<span class="term_command">lrwxrwxrwx.</span> 1 root root 10 May  4 17:51 /var/mail -&gt; spool/mail
<span class="term_say"># 看到这里应该知道为啥了吧？因为 /var/mail 是链接文件，链接到 /var/spool/mail 
# 所以，加上 pwd -P 的选项后，会不以链接文件的数据显示，而是显示正确的完整路径啊！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 6--------------------------------------------------<br/>--------------------------------------------------7--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">mkdir [-mp] 目录名称</span>
<span class="term_say">选项与参数：
-m ：设置文件的权限喔！直接设置，不需要看默认权限 （umask） 的脸色～
-p ：帮助你直接将所需要的目录（包含上层目录）递回创建起来！</span>

<span class="term_hd">范例：请到/tmp下面尝试创建数个新目录看看：</span>
[root@study ~]# <span class="term_command">cd /tmp</span>
[root@study tmp]# <span class="term_command">mkdir test</span>    <span class="term_note">&lt;==创建一名为 test 的新目录</span>
[root@study tmp]# <span class="term_command">mkdir test1/test2/test3/test4</span>
mkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory
<span class="term_say"># 话说，系统告诉我们，没可能创建这个目录啊！就是没有目录才要创建的！见鬼嘛？</span>
[root@study tmp]# <span class="term_command">mkdir -p test1/test2/test3/test4</span>
<span class="term_say"># 原来是要建 test4 上层没先建 test3 之故！加了这个 -p 的选项，可以自行帮你创建多层目录！</span>

<span class="term_hd">范例：创建权限为rwx--x--x的目录</span>
[root@study tmp]# <span class="term_command">mkdir -m 711 test2</span>
[root@study tmp]# <span class="term_command">ls -ld test*</span>
drwxr-xr-x. 2 root   root  6 Jun  4 19:03 test
drwxr-xr-x. 3 root   root 18 Jun  4 19:04 test1
<span class="term_command">drwx--x--x</span>. 2 root   root  6 Jun  4 19:05 test2
<span class="term_say"># 仔细看上面的权限部分，如果没有加上 -m 来强制设置属性，系统会使用默认属性。
# 那么你的默认属性为何？这要通过下面介绍的 <a href="#calibre_link-48" class="pcalibre"><span class="term_say1">umask</span></a> 才能了解喔！ ^_^</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 7--------------------------------------------------<br/>--------------------------------------------------8--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">rmdir [-p] 目录名称</span>
<span class="term_say">选项与参数：
-p ：连同“上层”“空的”目录也一起删除</span>

<span class="term_hd">范例：将于mkdir范例中创建的目录（/tmp下面）删除掉！</span>
[root@study tmp]# <span class="term_command">ls -ld test*</span>   <span class="term_note">&lt;==看看有多少目录存在？</span>
drwxr-xr-x. 2 root   root  6 Jun  4 19:03 test
drwxr-xr-x. 3 root   root 18 Jun  4 19:04 test1
drwx--x--x. 2 root   root  6 Jun  4 19:05 test2
[root@study tmp]# <span class="term_command">rmdir test </span>  <span class="term_note">&lt;==可直接删除掉，没问题</span>
[root@study tmp]# <span class="term_command">rmdir test1</span>  <span class="term_note">&lt;==因为尚有内容，所以无法删除！</span>
rmdir: failed to remove ‘test1’: Directory not empty
[root@study tmp]# <span class="term_command">rmdir -p test1/test2/test3/test4</span>
[root@study tmp]# <span class="term_command">ls -ld test*  </span>  <span class="term_note">&lt;==您看看，下面的输出中test与test1不见了！</span>
drwx--x--x. 2 root   root  6 Jun  4 19:05 test2
<span class="term_say"># 瞧！利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除～
# 不过要注意的是，这个 rmdir 仅能“删除空的目录”喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 8--------------------------------------------------<br/>--------------------------------------------------9--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：先用root的身份列出搜寻的路径为何？</span>
[root@study ~]# <span class="term_command">echo $PATH</span>
/usr/local/sbin:/usr/local/bin:/sbin:<span class="term_command">/bin</span>:/usr/sbin:/usr/bin:/root/bin

<span class="term_hd">范例：用dmtsai的身份列出搜寻的路径为何？</span>
[root@study ~]# <span class="term_command">exit</span>    <span class="term_note"># 由之前的 su - 离开，变回原本的帐号！或再取得一个终端机皆可！</span>
[dmtsai@study ~]$ <span class="term_command">echo $PATH</span>
/usr/local/bin:<span class="term_command">/usr/bin</span>:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say"># 记不记得我们前一章说过，目前 /bin 是链接到 /usr/bin 当中的喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 9--------------------------------------------------<br/>--------------------------------------------------10--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：将主文件夹下的所有文件列出来（含属性与隐藏文件）</span>
[root@study ~]# <span class="term_command">ls -al ~</span>
total 56
dr-xr-x---.  5 root root 4096 Jun  4 19:49 <span class="calibre50">.</span>
dr-xr-xr-x. 17 root root 4096 May  4 17:56 <span class="calibre50">..</span>
-rw-------.  1 root root 1816 May  4 17:57 anaconda-ks.cfg
-rw-------.  1 root root 6798 Jun  4 19:53 .bash_history
-rw-r--r--.  1 root root   18 Dec 29  2013 .bash_logout
-rw-r--r--.  1 root root  176 Dec 29  2013 .bash_profile
-rw-rw-rw-.  1 root root  176 Dec 29  2013 .bashrc
-rw-r--r--.  1 root root  176 Jun  3 00:04 .bashrc_test
drwx------.  4 root root   29 May  6 00:14 <span class="calibre50">.cache</span>
drwxr-xr-x.  3 root root   17 May  6 00:14 <span class="calibre50">.config</span>
<span class="term_say"># 这个时候你会看到以 . 为开头的几个文件，以及目录档 （.） （..） .config 等等，
# 不过，目录档文件名都是以深蓝色显示，有点不容易看清楚就是了。</span>

<span class="term_hd">范例二：承上题，不显示颜色，但在文件名末显示出该文件名代表的类型（type）</span>
[root@study ~]# <span class="term_command">ls -alF --color=never  ~</span>
total 56
dr-xr-x---.  5 root root 4096 Jun  4 19:49 ./
dr-xr-xr-x. 17 root root 4096 May  4 17:56 ../
-rw-------.  1 root root 1816 May  4 17:57 anaconda-ks.cfg
-rw-------.  1 root root 6798 Jun  4 19:53 .bash_history
-rw-r--r--.  1 root root   18 Dec 29  2013 .bash_logout
-rw-r--r--.  1 root root  176 Dec 29  2013 .bash_profile
-rw-rw-rw-.  1 root root  176 Dec 29  2013 .bashrc
-rw-r--r--.  1 root root  176 Jun  3 00:04 .bashrc_test
drwx------.  4 root root   29 May  6 00:14 .cache/
drwxr-xr-x.  3 root root   17 May  6 00:14 .config/
<span class="term_say"># 注意看到显示结果的第一行，嘿嘿～知道为何我们会下达类似 ./command 
# 之类的指令了吧？因为 ./ 代表的是“目前目录下”的意思啊！至于什么是 FIFO/Socket ？
# 请参考前一章节的介绍啊！另外，那个.bashrc 时间仅写2013，能否知道详细时间？</span>

<span class="term_hd">范例三：完整的呈现文件的修改时间 （modification time）</span>
[root@study ~]# <span class="term_command">ls -al --full-time  ~</span>
total 56
dr-xr-x---.  5 root root 4096 2015-06-04 19:49:54.520684829 +0800 .
dr-xr-xr-x. 17 root root 4096 2015-05-04 17:56:38.888000000 +0800 ..
-rw-------.  1 root root 1816 2015-05-04 17:57:02.326000000 +0800 anaconda-ks.cfg
-rw-------.  1 root root 6798 2015-06-04 19:53:41.451684829 +0800 .bash_history
-rw-r--r--.  1 root root   18 2013-12-29 10:26:31.000000000 +0800 .bash_logout
-rw-r--r--.  1 root root  176 2013-12-29 10:26:31.000000000 +0800 .bash_profile
-rw-rw-rw-.  1 root root  176 2013-12-29 10:26:31.000000000 +0800 .bashrc
-rw-r--r--.  1 root root  176 2015-06-03 00:04:16.916684829 +0800 .bashrc_test
drwx------.  4 root root   29 2015-05-06 00:14:56.960764950 +0800 .cache
drwxr-xr-x.  3 root root   17 2015-05-06 00:14:56.975764950 +0800 .config
<span class="term_say"># 请仔细看，上面的“时间”字段变了喔！变成较为完整的格式。
# 一般来说， ls -al 仅列出目前短格式的时间，有时不会列出年份，
# 借由 --full-time 可以查阅到比较正确的完整时间格式啊！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 10--------------------------------------------------<br/>--------------------------------------------------11--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：用root身份，将主文件夹下的 .bashrc 复制到 /tmp 下，并更名为 bashrc</span>
[root@study ~]# <span class="term_command">cp ~/.bashrc /tmp/bashrc</span>
[root@study ~]# <span class="term_command">cp -i ~/.bashrc /tmp/bashrc</span>
cp: overwrite `/tmp/bashrc'? <span class="term_command">n</span>  <span class="term_note">&lt;==n不覆盖，y为覆盖</span>
<span class="term_say"># 重复作两次动作，由于 /tmp 下面已经存在 bashrc 了，加上 -i 选项后，
# 则在覆盖前会询问使用者是否确定！可以按下 n 或者 y 来二次确认呢！</span>

<span class="term_hd">范例二：变换目录到/tmp，并将/var/log/wtmp复制到/tmp且观察属性：</span>
[root@study ~]# <span class="term_command">cd /tmp</span>
[root@study tmp]# <span class="term_command">cp /var/log/wtmp .</span> <span class="term_note">&lt;==想要复制到目前的目录，最后的 . 不要忘</span>
[root@study tmp]# <span class="term_command">ls -l /var/log/wtmp wtmp</span>
<span class="term_command">-rw-rw-r--</span>. 1 root <span class="term_command">utmp</span> 28416 <span class="term_command">Jun 11 18:56</span> /var/log/wtmp
<span class="term_command">-rw-r--r--</span>. 1 root <span class="term_command">root</span> 28416 <span class="term_command">Jun 11 19:01</span> wtmp
<span class="term_say"># 注意上面的特殊字体，在不加任何选项的情况下，文件的某些属性/权限会改变；
# 这是个很重要的特性！要注意喔！还有，连文件创建的时间也不一样了！
# 那如果你想要将文件的所有特性都一起复制过来该怎办？可以加上 -a 喔！如下所示：</span>

[root@study tmp]# <span class="term_command">cp -a /var/log/wtmp wtmp_2</span>
[root@study tmp]# <span class="term_command">ls -l /var/log/wtmp wtmp_2</span>
-rw-rw-r--. 1 root utmp 28416 Jun 11 18:56 /var/log/wtmp
-rw-rw-r--. 1 root utmp 28416 Jun 11 18:56 wtmp_2
<span class="term_say"># 瞭了吧！整个数据特性完全一模一样ㄟ！真是不赖～这就是 -a 的特性！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 11--------------------------------------------------<br/>--------------------------------------------------12--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：复制 /etc/ 这个目录下的所有内容到 /tmp 下面</span>
[root@study tmp]# <span class="term_command">cp /etc/ /tmp</span>
cp: omitting directory `/etc'   <span class="term_note">&lt;== 如果是目录则不能直接复制，要加上 -r 的选项</span>
[root@study tmp]# <span class="term_command">cp -r /etc/ /tmp</span>
<span class="term_say"># 还是要再次的强调喔！ -r 是可以复制目录，但是，文件与目录的权限可能会被改变
# 所以，也可以利用“ cp -a /etc /tmp ”来下达指令喔！尤其是在备份的情况下！</span>

<span class="term_hd">范例四：将范例一复制的 bashrc 创建一个链接文件 （symbolic link）</span>
[root@study tmp]# <span class="term_command">ls -l bashrc</span>
-rw-r--r--. 1 root root 176 Jun 11 19:01 bashrc  <span class="term_note">&lt;==先观察一下文件情况</span>
[root@study tmp]# <span class="term_command">cp -s bashrc bashrc_slink</span>
[root@study tmp]# <span class="term_command">cp -l bashrc bashrc_hlink</span>
[root@study tmp]# <span class="term_command">ls -l bashrc*</span>
-rw-r--r--. <span class="term_command">2</span> root root 176 Jun 11 19:01 bashrc         <span class="term_note">&lt;==与原始文件不太一样了！</span>
-rw-r--r--. <span class="term_command">2</span> root root 176 Jun 11 19:01 bashrc_hlink
lrwxrwxrwx. 1 root root   6 Jun 11 19:06 bashrc_slink -&gt; bashrc
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 12--------------------------------------------------<br/>--------------------------------------------------13--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例五：若 ~/.bashrc 比 /tmp/bashrc 新才复制过来</span>
[root@study tmp]# <span class="term_command">cp -u ~/.bashrc /tmp/bashrc</span>
<span class="term_say"># 这个 -u 的特性，是在目标文件与来源文件有差异时，才会复制的。
# 所以，比较常被用于“备份”的工作当中喔！ ^_^</span>

<span class="term_hd">范例六：将范例四造成的 bashrc_slink 复制成为 bashrc_slink_1 与bashrc_slink_2</span>
[root@study tmp]# <span class="term_command">cp bashrc_slink bashrc_slink_1</span>
[root@study tmp]# <span class="term_command">cp -d bashrc_slink bashrc_slink_2</span>
[root@study tmp]# <span class="term_command">ls -l bashrc bashrc_slink*</span>
-rw-r--r--. 2 root root 176 Jun 11 19:01 bashrc
lrwxrwxrwx. 1 root root   6 Jun 11 19:06 bashrc_slink -&gt; bashrc
-rw-r--r--. 1 root root 176 Jun 11 19:09 bashrc_slink_1            <span class="term_note">&lt;==与原始文件相同</span>
lrwxrwxrwx. 1 root root   6 Jun 11 19:10 bashrc_slink_2 -&gt; bashrc  <span class="term_note">&lt;==是链接文件！</span>
<span class="term_say"># 这个例子也是很有趣喔！原本复制的是链接文件，但是却将链接文件的实际文件复制过来了
# 也就是说，如果没有加上任何选项时，cp复制的是原始文件，而非链接文件的属性！
# 若要复制链接文件的属性，就得要使用 -d 的选项了！如 bashrc_slink_2 所示。</span>

<span class="term_hd">范例七：将主文件夹的 .bashrc 及 .bash_history 复制到 /tmp 下面</span>
[root@study tmp]# <span class="term_command">cp ~/.bashrc ~/.bash_history /tmp</span>
<span class="term_say"># 可以将多个数据一次复制到同一个目录去！最后面一定是目录！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 13--------------------------------------------------<br/>--------------------------------------------------14--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">rm [-fir] 文件或目录</span>
<span class="term_say">选项与参数：
-f  ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；
-i  ：互动模式，在删除前会询问使用者是否动作
-r  ：递回删除啊！最常用在目录的删除了！<span class="calibre34">这是非常危险的选项！！！</span></span>

<span class="term_hd">范例一：将刚刚在 cp 的范例中创建的 bashrc 删除掉！</span>
[root@study ~]# <span class="term_command">cd /tmp</span>
[root@study tmp]# <span class="term_command">rm -i bashrc</span>
rm: remove regular file `bashrc'? <span class="term_command">y</span>
<span class="term_say"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的文件名！</span>

<span class="term_hd">范例二：通过万用字符*的帮忙，将/tmp下面开头为bashrc的文件名通通删除：</span>
[root@study tmp]# <span class="term_command">rm -i bashrc*</span>
<span class="term_say"># 注意那个星号，代表的是 0 到无穷多个任意字符喔！很好用的东西！</span>

<span class="term_hd">范例三：将 cp 范例中所创建的 /tmp/etc/ 这个目录删除掉！</span>
[root@study tmp]# <span class="term_command">rmdir /tmp/etc</span>
rmdir: failed to remove '/tmp/etc': Directory not empty   <span class="term_note">&lt;== 删不掉啊！因为这不是空的目录！</span>
[root@study tmp]# <span class="term_command">rm -r /tmp/etc</span>
rm: descend into directory `/tmp/etc'? <span class="term_command">y</span>
rm: remove regular file `/tmp/etc/fstab'? <span class="term_command">y</span>
rm: remove regular empty file `/tmp/etc/crypttab'? <span class="term_command">^C</span>  <span class="term_note">&lt;== 按下 [crtl]+c 中断</span>
<span class="term_say">.....（中间省略）.....
# 因为身份是 root ，默认已经加入了 -i 的选项，所以你要一直按 y 才会删除！
# 如果不想要继续按 y ，可以按下“ [ctrl]-c ”来结束 rm 的工作。
# 这是一种保护的动作，如果确定要删除掉此目录而不要询问，可以这样做：</span>
[root@study tmp]# <span class="term_command">\rm -r /tmp/etc</span>
<span class="term_say"># 在指令前加上反斜线，可以忽略掉 alias 的指定选项喔！至于 alias 我们在bash再谈！
# 拜托！这个范例很可怕！你不要删错了！删除 /etc 系统是会挂掉的！</span>

<span class="term_hd">范例四：删除一个带有 - 开头的文件</span>
[root@study tmp]# <span class="term_command">touch ./-aaa-</span>  <span class="term_note">&lt;==<a href="#calibre_link-208" class="calibre51 pcalibre">touch</a>这个指令可以创建空文件！</span>
[root@study tmp]# <span class="term_command">ls -l </span>
-rw-r--r--. 1 root   root       0 Jun 11 19:22 -aaa-  <span class="term_note">&lt;==文件大小为0，所以是空文件</span>
[root@study tmp]# <span class="term_command">rm -aaa-</span>
rm: invalid option -- 'a'                    <span class="term_say">&lt;== 因为 "-" 是选项嘛！所以系统误判了！</span>
Try 'rm ./-aaa-' to remove the file `-aaa-'. <span class="term_say">&lt;== 新的 bash 有给建议的</span>
Try 'rm --help' for more information.
[root@study tmp]# <span class="term_command">rm ./-aaa-</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 14--------------------------------------------------<br/>--------------------------------------------------15--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">mv [-fiu] source destination</span>
[root@study ~]# <span class="term_command">mv [options] source1 source2 source3 .... directory</span>
<span class="term_say">选项与参数：
-f  ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
-i  ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！
-u  ：若目标文件已经存在，且 source 比较新，才会更新 （update）</span>

<span class="term_hd">范例一：复制一文件，创建一目录，将文件移动到目录中</span>
[root@study ~]# <span class="term_command">cd /tmp</span>
[root@study tmp]# <span class="term_command">cp ~/.bashrc bashrc</span>
[root@study tmp]# <span class="term_command">mkdir mvtest</span>
[root@study tmp]# <span class="term_command">mv bashrc mvtest</span>
<span class="term_say"># 将某个文件移动到某个目录去，就是这样做！</span>

<span class="term_hd">范例二：将刚刚的目录名称更名为 mvtest2</span>
[root@study tmp]# <span class="term_command">mv mvtest mvtest2</span> <span class="term_note">&lt;== 这样就更名了！简单～</span>
<span class="term_say"># 其实在 Linux 下面还有个有趣的指令，名称为 <span class="term_note_b">rename</span> ，
# 该指令专职进行多个文件名的同时更名，并非针对单一文件名变更，与mv不同。请man rename。</span>

<span class="term_hd">范例三：再创建两个文件，再全部移动到 /tmp/mvtest2 当中</span>
[root@study tmp]# <span class="term_command">cp ~/.bashrc bashrc1</span>
[root@study tmp]# <span class="term_command">cp ~/.bashrc bashrc2</span>
[root@study tmp]# <span class="term_command">mv bashrc1 bashrc2 mvtest2</span>
<span class="term_say"># 注意到这边，如果有多个来源文件或目录，则最后一个目标文件一定是“目录！”
# 意思是说，将所有的数据移动到该目录的意思！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 15--------------------------------------------------<br/>--------------------------------------------------16--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">cat [-AbEnTv]</span>
<span class="term_say">选项与参数：
-A  ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；
-b  ：列出行号，仅针对非空白行做行号显示，空白行不标行号！
-E  ：将结尾的断行字符 $ 显示出来；
<span class="calibre34">-n  ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</span>
-T  ：将 [tab] 按键以 ^I 显示出来；
-v  ：列出一些看不出来的特殊字符</span>

<span class="term_hd">范例一：检阅 /etc/issue 这个文件的内容</span>
[root@study ~]# <span class="term_command">cat /etc/issue</span>
\S
Kernel \r on an \m

<span class="term_hd">范例二：承上题，如果还要加印行号呢？</span>
[root@study ~]# <span class="term_command">cat -n /etc/issue</span>
     1  \S
     2  Kernel \r on an \m
     3
<span class="term_say"># 所以这个文件有三行！看到了吧！可以印出行号呢！这对于大文件要找某个特定的行时，有点用处！
# 如果不想要编排空白行的行号，可以使用“cat -b /etc/issue”，自己测试看看：</span>

<span class="term_hd">范例三：将 /etc/man_db.conf 的内容完整的显示出来（包含特殊字符）</span>
[root@study ~]# <span class="term_command">cat -A /etc/man_db.conf</span>
# <span class="term_command">$</span>
<span class="term_say">....（中间省略）....</span>
MANPATH_MAP<span class="term_command">^I</span>/bin<span class="term_command">^I^I^I</span>/usr/share/man<span class="term_command">$</span>
MANPATH_MAP<span class="term_command">^I</span>/usr/bin<span class="term_command">^I^I</span>/usr/share/man<span class="term_command">$</span>
MANPATH_MAP<span class="term_command">^I</span>/sbin<span class="term_command">^I^I^I</span>/usr/share/man<span class="term_command">$</span>
MANPATH_MAP<span class="term_command">^I</span>/usr/sbin<span class="term_command">^I^I</span>/usr/share/man<span class="term_command">$</span>
<span class="term_say">.....（下面省略）.....</span>
<span class="term_say"># 上面的结果限于篇幅，鸟哥删除掉很多数据了。另外，输出的结果并不会有特殊字体，
# 鸟哥上面的特殊字体是要让您发现差异点在哪里就是了。基本上，在一般的环境中，
# 使用 [tab] 与空白键的效果差不多，都是一堆空白啊！我们无法知道两者的差别。
# 此时使用 cat -A 就能够发现那些空白的地方是啥鬼东西了！[tab]会以 ^I 表示，
# 断行字符则是以 $ 表示，所以你可以发现每一行后面都是 $ 啊！不过断行字符
# 在Windows/Linux则不太相同，Windows的断行字符是 ^M$ 啰。
# 这部分我们会在<a href="#calibre_link-53" class="calibre51 pcalibre">第九章 vim 软件</a>的介绍时，再次的说明到喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 16--------------------------------------------------<br/>--------------------------------------------------17--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">tac /etc/issue</span>

Kernel \r on an \m
\S
<span class="term_say"># 嘿嘿！与刚刚上面的范例一比较，是由最后一行先显示喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 17--------------------------------------------------<br/>--------------------------------------------------18--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">nl [-bnw] 文件</span>
<span class="term_say">选项与参数：
-b  ：指定行号指定的方式，主要有两种：
      -b a ：表示不论是否为空行，也同样列出行号（类似 cat -n）；
      -b t ：如果有空行，空的那一行不要列出行号（默认值）；
-n  ：列出行号表示的方法，主要有三种：
      -n ln ：行号在屏幕的最左方显示；
      -n rn ：行号在自己字段的最右方显示，且不加 0 ；
      -n rz ：行号在自己字段的最右方显示，且加 0 ；
-w  ：行号字段的占用的字符数。</span>

<span class="term_hd">范例一：用 nl 列出 /etc/issue 的内容</span>
[root@study ~]# <span class="term_command">nl /etc/issue</span>
     1  \S
     2  Kernel \r on an \m

<span class="term_say"># 注意看，这个文件其实有三行，第三行为空白（没有任何字符），
# 因为他是空白行，所以 nl 不会加上行号喔！如果确定要加上行号，可以这样做：</span>

[root@study ~]# <span class="term_command">nl -b a /etc/issue</span>
     1  \S
     2  Kernel \r on an \m
     3
<span class="term_say"># 呵呵！行号加上来啰～那么如果要让行号前面自动补上 0 呢？可这样</span>

[root@study ~]# <span class="term_command">nl -b a -n rz /etc/issue</span>
000001  \S
000002  Kernel \r on an \m
000003
<span class="term_say"># 嘿嘿！自动在自己字段的地方补上 0 了～默认字段是六位数，如果想要改成 3 位数？</span>

[root@study ~]# <span class="term_command">nl -b a -n rz -w 3 /etc/issue</span>
001     \S
002     Kernel \r on an \m
003
<span class="term_say"># 变成仅有 3 位数啰～</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 18--------------------------------------------------<br/>--------------------------------------------------19--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">head [-n number] 文件 </span>
<span class="term_say">选项与参数：
-n  ：后面接数字，代表显示几行的意思</span>

[root@study ~]# <span class="term_command">head /etc/man_db.conf</span>
<span class="term_say"># 默认的情况中，显示前面十行！若要显示前 20 行，就得要这样：</span>
[root@study ~]# <span class="term_command">head -n 20 /etc/man_db.conf</span>

<span class="term_hd">范例：如果后面100行的数据都不打印，只打印/etc/man_db.conf的前面几行，该如何是好？</span>
[root@study ~]# <span class="term_command">head -n -100 /etc/man_db.conf</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 19--------------------------------------------------<br/>--------------------------------------------------20--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">tail [-n number] 文件 </span>
<span class="term_say">选项与参数：
-n  ：后面接数字，代表显示几行的意思
-f  ：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</span>

[root@study ~]# <span class="term_command">tail /etc/man_db.conf</span>
<span class="term_say"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span>
[root@study ~]# <span class="term_command">tail -n 20 /etc/man_db.conf</span>

<span class="term_hd">范例一：如果不知道/etc/man_db.conf有几行，却只想列出100行以后的数据时？</span>
[root@study ~]# <span class="term_command">tail -n +100 /etc/man_db.conf</span>

<span class="term_hd">范例二：持续侦测/var/log/messages的内容</span>
[root@study ~]# <span class="term_command">tail -f /var/log/messages</span>
  <span class="term_note">&lt;==要等到输入[crtl]-c之后才会离开tail这个指令的侦测！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 20--------------------------------------------------<br/>--------------------------------------------------21--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">od [-t TYPE] 文件</span>
<span class="term_say">选项或参数：
-t  ：后面可以接各种“类型 （TYPE）”的输出，例如：
      a       ：利用默认的字符来输出；
      c       ：使用 ASCII 字符来输出
      d[size] ：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ；
      f[size] ：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ；
      o[size] ：利用八进位（octal）来输出数据，每个整数占用 size Bytes ；
      x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ；</span>

<span class="term_hd">范例一：请将/usr/bin/passwd的内容使用ASCII方式来展现！</span>
[root@study ~]# <span class="term_command">od -t c /usr/bin/passwd</span>
0000000 177   E   L   F 002 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000020 003  \0   &gt;  \0 001  \0  \0  \0 364   3  \0  \0  \0  \0  \0  \0
0000040   @  \0  \0  \0  \0  \0  \0  \0   x   e  \0  \0  \0  \0  \0  \0
0000060  \0  \0  \0  \0   @  \0   8  \0  \t  \0   @  \0 035  \0 034  \0
0000100 006  \0  \0  \0 005  \0  \0  \0   @  \0  \0  \0  \0  \0  \0  \0
<span class="term_say">.....（后面省略）....
# 最左边第一栏是以 8 进位来表示Bytes数。以上面范例来说，第二栏0000020代表开头是
# 第 16 个 byes （2x8） 的内容之意。</span>

<span class="term_hd">范例二：请将/etc/issue这个文件的内容以8进位列出储存值与ASCII的对照表</span>
[root@study ~]# <span class="term_command">od -t oCc /etc/issue</span>
0000000 134 123 012 113 145 162 156 145 154 040 134 162 040 157 156 040
          \   S  \n   K   e   r   n   e   l       \   r       o   n
0000020 141 156 040 134 155 012 012
          a   n       \   m  \n  \n
0000027
<span class="term_say"># 如上所示，可以发现每个字符可以对应到的数值为何！要注意的是，该数值是 8 进位喔！
# 例如 S 对应的记录数值为 123 ，转成十进制：1x8^2+2x8+3=83。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 21--------------------------------------------------<br/>--------------------------------------------------22--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">touch [-acdmt] 文件</span>
<span class="term_say">选项与参数：
-a  ：仅修订 access time；
-c  ：仅修改文件的时间，若该文件不存在则不创建新文件；
-d  ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date="日期或时间"
-m  ：仅修改 mtime ；
-t  ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</span>

<span class="term_hd">范例一：新建一个空的文件并观察时间</span>
[dmtsai@study ~]# <span class="term_command">cd /tmp</span>
[dmtsai@study tmp]# <span class="term_command">touch testtouch</span>
[dmtsai@study tmp]# <span class="term_command">ls -l testtouch</span>
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_command">0</span> Jun 16 00:45 testtouch
<span class="term_say"># 注意到，这个文件的大小是 0 呢！在默认的状态下，如果 touch 后面有接文件，
# 则该文件的三个时间 （atime/ctime/mtime） 都会更新为目前的时间。若该文件不存在，
# 则会主动的创建一个新的空的文件喔！例如上面这个例子！</span>

<span class="term_hd">范例二：将 ~/.bashrc 复制成为 bashrc，假设复制完全的属性，检查其日期</span>
[dmtsai@study tmp]# <span class="term_command">cp -a ~/.bashrc bashrc</span>
[dmtsai@study tmp]# <span class="term_command">date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc</span>
Tue Jun 16 00:49:24 CST 2015                         <span class="term_note">&lt;==这是目前的时间</span>
-rw-r--r--. 1 dmtsai dmtsai 231 Mar  6 06:06 bashrc  <span class="term_note">&lt;==这是 mtime</span>
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 15 23:44 bashrc  <span class="term_note">&lt;==这是 atime</span>
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 16 00:47 bashrc  <span class="term_note">&lt;==这是 ctime</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 22--------------------------------------------------<br/>--------------------------------------------------23--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：修改案例二的 bashrc 文件，将日期调整为两天前</span>
[dmtsai@study tmp]# <span class="term_command">touch -d "2 days ago" bashrc</span>
[dmtsai@study tmp]# <span class="term_command">date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc</span>
Tue Jun 16 00:51:52 CST 2015
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 14 00:51 bashrc
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 14 00:51 bashrc
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 16 00:51 bashrc
<span class="term_say"># 跟上个范例比较看看，本来是 16 日变成 14 日了 （atime/mtime）～不过， ctime 并没有跟着改变喔！</span>

<span class="term_hd">范例四：将上个范例的 bashrc 日期改为 2014/06/15 2:02</span>
[dmtsai@study tmp]# <span class="term_command">touch -t 201406150202 bashrc</span>
[dmtsai@study tmp]# <span class="term_command">date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc</span>
Tue Jun 16 00:54:07 CST 2015
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 15  2014 bashrc
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 15  2014 bashrc
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 16 00:54 bashrc
<span class="term_say"># 注意看看，日期在 atime 与 mtime 都改变了，但是 ctime 则是记录目前的时间！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 23--------------------------------------------------<br/>--------------------------------------------------24--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">chattr [+-=][ASacdistu] 文件或目录名称</span>
<span class="term_say">选项与参数：
+   ：增加某一个特殊参数，其他原本存在参数则不动。
-   ：移除某一个特殊参数，其他原本存在参数则不动。
=   ：设置一定，且仅有后面接的参数

A  ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改，
     可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）
S  ：一般文件是非同步写入磁盘的（原理请参考<a href="#calibre_link-732" class="calibre51 pcalibre">前一章sync</a>的说明），如果加上 S 这个属性时，
     当你进行任何文件的修改，该更动会“同步”写入磁盘中。
<span class="calibre34">a  ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性</span>
c  ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩，
     但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）
d  ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份
<span class="calibre34">i  ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！”
     对于系统安全性有相当大的助益！只有 root 能设置此属性</span>
s  ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，
     所以如果误删了，完全无法救回来了喔！
u  ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中，
     可以使用来救援该文件喔！
注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置
注意2：xfs 文件系统仅支持 AadiS 而已</span>

<span class="term_hd">范例：请尝试到/tmp下面创建文件，并加入 i 的参数，尝试删除看看。</span>
[root@study ~]# <span class="term_command">cd /tmp</span>
[root@study tmp]# <span class="term_command">touch attrtest    </span> <span class="term_note">&lt;==创建一个空文件</span>
[root@study tmp]# <span class="term_command">chattr +i attrtest</span> <span class="term_note">&lt;==给予 i 的属性</span>
[root@study tmp]# <span class="term_command">rm attrtest       </span> <span class="term_note">&lt;==尝试删除看看</span>
rm: remove regular empty file `attrtest'? <span class="term_command">y</span>
rm: cannot remove `attrtest': Operation not permitted
<span class="term_say"># 看到了吗？呼呼！连 root 也没有办法将这个文件删除呢！赶紧解除设置！</span>

<span class="term_hd">范例：请将该文件的 i 属性取消！</span>
[root@study tmp]# <span class="term_command">chattr -i attrtest</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 24--------------------------------------------------<br/>--------------------------------------------------25--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">which [-a] command</span>
<span class="term_say">选项或参数：
-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</span>

<span class="term_hd">范例一：搜寻 ifconfig 这个指令的完整文件名</span>
[root@study ~]# <span class="term_command">which ifconfig</span>
/sbin/ifconfig 

<span class="term_hd">范例二：用 which 去找出 which 的文件名为何？</span>
[root@study ~]# <span class="term_command">which which</span>
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
        /bin/alias
        /usr/bin/which
<span class="term_say"># 竟然会有两个 which ，其中一个是 alias 这玩意儿呢！那是啥？
# 那就是所谓的“命令别名”，意思是输入 which 会等于后面接的那串指令啦！
# 更多的数据我们会在 bash 章节中再来谈的！</span>

<span class="term_hd">范例三：请找出 history 这个指令的完整文件名</span>
[root@study ~]# <span class="term_command">which history</span>
/usr/bin/which: no history in （/usr/local/sbin:/usr/local/bin:/sbin:/bin:
/usr/sbin:/usr/bin:/root/bin）

[root@study ~]# <span class="term_command">history --help</span>
-bash: history: --: invalid option
history: usage: history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg 
<span class="term_say"># 瞎密？怎么可能没有 history ，我明明就能够用 root 执行 history 的啊！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 25--------------------------------------------------<br/>--------------------------------------------------26--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">whereis [-bmsu] 文件或目录名</span>
<span class="term_say">选项与参数：
-l    :可以列出 whereis 会去查询的几个主要目录而已
-b    :只找 binary 格式的文件
-m    :只找在说明文档 manual 路径下的文件
-s    :只找 source 来源文件
-u    :搜寻不在上述三个项目当中的其他特殊文件</span>

<span class="term_hd">范例一：请找出 ifconfig 这个文件名</span>
[root@study ~]# <span class="term_command">whereis ifconfig </span>
ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz

<span class="term_hd">范例二：只找出跟 passwd 有关的“说明文档”文件名（man page）</span>
[root@study ~]# <span class="term_command">whereis passwd</span>     <span class="term_note"># 全部的文件名通通列出来！</span>
passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
[root@study ~]# <span class="term_command">whereis -m passwd</span>  <span class="term_note"># 只有在 man 里面的文件名才抓出来！</span>
passwd: /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 26--------------------------------------------------<br/>--------------------------------------------------27--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">locate [-ir] keyword</span>
<span class="term_say">选项与参数：
-i  ：忽略大小写的差异；
-c  ：不输出文件名，仅计算找到的文件数量
-l  ：仅输出几行的意思，例如输出五行则是 -l 5
-S  ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等
-r  ：后面可接正则表达式的显示方式</span>

<span class="term_hd">范例一：找出系统中所有与 passwd 相关的文件名，且只列出 5 个</span>
[root@study ~]# <span class="term_command">locate -l 5 passwd</span>
/etc/passwd
/etc/passwd-
/etc/pam.d/passwd
/etc/security/opasswd
/usr/bin/gpasswd

<span class="term_hd">范例二：列出 locate 查询所使用的数据库文件之文件名与各数据数量</span>
[root@study ~]# <span class="term_command">locate -S</span>
Database /var/lib/mlocate/mlocate.db:
        8,086 directories     <span class="term_note"># 总纪录目录数</span>
        109,605 files         <span class="term_note"># 总纪录文件数</span>
        5,190,295 Bytes in file names
        2,349,150 Bytes used to store database
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 27--------------------------------------------------<br/>--------------------------------------------------28--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">find [PATH] [option] [action]</span>
<span class="term_say">选项与参数：
1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明
   -mtime  n ：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；
   -mtime +n ：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；
   -mtime -n ：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。
   -newer file ：file 为一个存在的文件，列出比 file 还要新的文件文件名</span>

<span class="term_hd">范例一：将过去系统上面 24 小时内有更动过内容 （mtime） 的文件列出</span>
[root@study ~]# <span class="term_command">find / -mtime 0</span>
<span class="term_say"># 那个 0 是重点！0 代表目前的时间，所以，从现在开始到 24 小时前，
# 有变动过内容的文件都会被列出来！那如果是三天前的 24 小时内？
# find / -mtime 3 有变动过的文件都被列出的意思！</span>

<span class="term_hd">范例二：寻找 /etc 下面的文件，如果文件日期比 /etc/passwd 新就列出</span>
[root@study ~]# <span class="term_command">find /etc -newer /etc/passwd</span>
<span class="term_say"># -newer 用在分辨两个文件之间的新旧关系是很有用的！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 28--------------------------------------------------<br/>--------------------------------------------------29--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_say">选项与参数：
2. 与使用者或群组名称有关的参数：
   -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在
            /etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。
   -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在
            /etc/group，相关的介绍我们会第四篇说明～
   -user name ：name 为使用者帐号名称喔！例如 dmtsai 
   -group name：name 为群组名称喔，例如 users ；
   -nouser    ：寻找文件的拥有者不存在 /etc/passwd 的人！
   -nogroup   ：寻找文件的拥有群组不存在于 /etc/group 的文件！
                当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，
                这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</span>

<span class="term_hd">范例三：搜寻 /home 下面属于 dmtsai 的文件</span>
[root@study ~]# <span class="term_command">find /home -user dmtsai</span>
<span class="term_say"># 这个东西也很有用的～当我们要找出任何一个使用者在系统当中的所有文件时，
# 就可以利用这个指令将属于某个使用者的所有文件都找出来喔！</span>

<span class="term_hd">范例四：搜寻系统中不属于任何人的文件</span>
[root@study ~]# <span class="term_command">find / -nouser</span>
<span class="term_say"># 通过这个指令，可以轻易的就找出那些不太正常的文件。如果有找到不属于系统任何人的文件时，
# 不要太紧张，那有时候是正常的～尤其是你曾经以源代码自行编译软件时。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 29--------------------------------------------------<br/>--------------------------------------------------30--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_say">选项与参数：
3. 与文件权限及名称有关的参数：
   -name filename：搜寻文件名称为 filename 的文件；
   -size [+-]SIZE：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：
                   c: 代表 Byte， k: 代表 1024Bytes。所以，要找比 50KB
                   还要大的文件，就是“ -size +50k ”
   -type TYPE    ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,
                   目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。
   -perm mode  ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod
                 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！
   -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，
                 我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744，
                 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，
                 因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。
   -perm /mode ：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻
                 -rwxr-xr-x ，亦即 -perm /755 时，但一个文件属性为 -rw-------
                 也会被列出来，因为他有 -rw.... 的属性存在！</span>

<span class="term_hd">范例五：找出文件名为 passwd 这个文件</span>
[root@study ~]# <span class="term_command">find / -name passwd</span>

<span class="term_hd">范例五-1：找出文件名包含了 passwd 这个关键字的文件</span>
[root@study ~]# <span class="term_command">find / -name "*passwd*"</span>
<span class="term_say"># 利用这个 -name 可以搜寻文件名啊！默认是完整文件名，如果想要找关键字，
# 可以使用类似 * 的任意字符来处理</span>

<span class="term_hd">范例六：找出 /run 目录下，文件类型为 Socket 的文件名有哪些？</span>
[root@study ~]# <span class="term_command">find /run -type s</span>
<span class="term_say"># 这个 -type 的属性也很有帮助喔！尤其是要找出那些怪异的文件，
# 例如 socket 与 FIFO 文件，可以用 find /run -type p 或 -type s 来找！</span>

<span class="term_hd">范例七：搜寻文件当中含有 SGID 或 SUID 或 SBIT 的属性</span>
[root@study ~]# <span class="term_command">find / -perm /7000 </span>
<span class="term_say"># 所谓的 7000 就是 ---s--s--t ，那么只要含有 s 或 t 的就列出，所以当然要使用 /7000，
# 使用 -7000 表示要同时含有 ---s--s--t 的所有三个权限。而只需要任意一个，就是 /7000 ～瞭乎？</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 30--------------------------------------------------<br/>--------------------------------------------------31--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_say">选项与参数：
4. 额外可进行的动作：
   -exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。
   -print        ：将结果打印到屏幕上，这个动作是默认动作！</span>

<span class="term_hd">范例八：将上个范例找到的文件使用 ls -l 列出来～</span>
[root@study ~]# <span class="term_command">find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} \;</span>
<span class="term_say"># 注意到，那个 -exec 后面的 ls -l 就是额外的指令，指令不支持命令别名，
# 所以仅能使用 ls -l 不可以使用 ll 喔！注意注意！</span>

<span class="term_hd">范例九：找出系统中，大于 1MB 的文件</span>
[root@study ~]# <span class="term_command">find / -size +1M</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 31--------------------------------------------------<br/>--------------------------------------------------32--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">dumpe2fs [-bh] 设备文件名</span>
<span class="term_say">选项与参数：
-b ：列出保留为坏轨的部分（一般用不到吧！？）
-h ：仅列出 superblock 的数据，不会列出其他的区段内容！</span>

<span class="term_hd">范例：鸟哥的一块 1GB ext4 文件系统内容</span>
[root@study ~]# <span class="term_command">blkid</span>   <span class="term_note">&lt;==这个指令可以叫出目前系统有被格式化的设备</span>
/dev/vda1: LABEL="myboot" UUID="ce4dbf1b-2b3d-4973-8234-73768e8fd659" TYPE="xfs"
/dev/vda2: LABEL="myroot" UUID="21ad8b9a-aaad-443c-b732-4e2522e95e23" TYPE="xfs"
/dev/vda3: UUID="12y99K-bv2A-y7RY-jhEW-rIWf-PcH5-SaiApN" TYPE="LVM2_member"
<span class="term_command">/dev/vda5: UUID="e20d65d9-20d4-472f-9f91-cdcfb30219d6" TYPE="ext4"</span>  <span class="term_note">&lt;==看到 ext4 了！</span>

[root@study ~]# <span class="term_command">dumpe2fs /dev/vda5</span>
dumpe2fs 1.42.9 （28-Dec-2013）
<span class="term_command">Filesystem volume name:   &lt;none&gt;</span>           <span class="term_note"># 文件系统的名称（不一定会有）</span>
Last mounted on:          &lt;not available&gt;  <span class="term_note"># 上一次挂载的目录位置</span>
<span class="term_command">Filesystem UUID:          e20d65d9-20d4-472f-9f91-cdcfb30219d6</span>
Filesystem magic number:  0xEF53           <span class="term_note"># 上方的 UUID 为 Linux 对设备的定义码</span>
Filesystem revision #:    1 （dynamic）      <span class="term_note"># 下方的 features 为文件系统的特征数据</span>
<span class="term_command">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit 
 flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span>
Filesystem flags:         signed_directory_hash
<span class="term_command">Default mount options:    user_xattr acl</span>   <span class="term_note"># 默认在挂载时会主动加上的挂载参数</span>
<span class="term_command">Filesystem state:         clean</span>            <span class="term_note"># 这块文件系统的状态为何，clean 是没问题</span>
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              65536            <span class="term_note"># inode 的总数</span>
Block count:              262144           <span class="term_note"># block 的总数</span>
Reserved block count:     13107            <span class="term_note"># 保留的 block 总数</span>
Free blocks:              249189           <span class="term_note"># 还有多少的 block 可用数量</span>
Free inodes:              65525            <span class="term_note"># 还有多少的 inode 可用数量</span>
First block:              0
<span class="term_command">Block size:               4096</span>             <span class="term_note"># 单个 block 的容量大小</span>
Fragment size:            4096
Group descriptor size:    64
<span class="term_say">....（中间省略）....</span>
<span class="term_command">Inode size:               256</span>              <span class="term_note"># inode 的容量大小！已经是 256 了喔！</span>
<span class="term_say">....（中间省略）....</span>
Journal inode:            8
Default directory hash:   half_md4
Directory Hash Seed:      3c2568b4-1a7e-44cf-95a2-c8867fb19fbc
Journal backup:           inode blocks
Journal features:         （none）
Journal size:             32M              <span class="term_note"># Journal 日志式数据的可供纪录总容量</span>
Journal length:           8192
Journal sequence:         0x00000001
Journal start:            0

Group 0: （Blocks 0-32767）                  <span class="term_note"># 第一块 block group 位置</span>
  Checksum 0x13be, unused inodes 8181
  Primary superblock at 0, Group descriptors at 1-1   <span class="term_note"># 主要 superblock 的所在喔！</span>
  Reserved GDT blocks at 2-128
  Block bitmap at 129 （+129）, Inode bitmap at 145 （+145）
  Inode table at 161-672 （+161）                       <span class="term_note"># inode table 的所在喔！</span>
  28521 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes
  Free blocks: 142-144, 153-160, 4258-32767           <span class="term_note"># 下面两行说明剩余的容量有多少</span>
  Free inodes: 12-8192
Group 1: （Blocks 32768-65535） [INODE_UNINIT]          <span class="term_note"># 后续为更多其他的 block group 喔！</span>
<span class="term_say">....（下面省略）....</span>
<span class="term_say"># 由于数据量非常的庞大，因此鸟哥将一些信息省略输出了！上表与你的屏幕会有点差异。
# 前半部在秀出 supberblock 的内容，包括标头名称（Label）以及inode/block的相关信息
# 后面则是每个 block group 的个别信息了！您可以看到各区段数据所在的号码！
# 也就是说，基本上所有的数据还是与 block 的号码有关就是了！很重要！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 32--------------------------------------------------<br/>--------------------------------------------------33--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">xfs_info 挂载点|设备文件名</span>

<span class="term_hd">范例一：找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录</span>
[root@study ~]# <span class="term_command">df -T /boot</span>
Filesystem     Type 1K-blocks   Used Available Use% Mounted on
/dev/vda2      xfs    1038336 133704    904632  13% /boot
<span class="term_say"># 没错！可以看得出来是 xfs 文件系统的！来观察一下内容吧！</span>

[root@study ~]# <span class="term_command">xfs_info /dev/vda2</span>
1  meta-data=/dev/vda2         <span class="term_command">isize=256</span>    agcount=4, agsize=65536 blks
2           =                  sectsz=512   attr=2, projid32bit=1
3           =                  crc=0        finobt=0
4  data     =                  <span class="term_command">bsize=4096</span>   blocks=262144, imaxpct=25
5           =                  <span class="term_command">sunit=0      swidth=0</span> blks
6  naming   =version 2         bsize=4096   ascii-ci=0 ftype=0
7  log      =internal          bsize=4096   blocks=2560, version=2
8           =                  sectsz=512   sunit=0 blks, lazy-count=1
9  realtime =none              <span class="term_command">extsz=4096</span>   blocks=0, rtextents=0
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 33--------------------------------------------------<br/>--------------------------------------------------34--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">df [-ahikHTm] [目录或文件名]</span>
<span class="term_say">选项与参数：
-a  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；
-k  ：以 KBytes 的容量显示各文件系统；
-m  ：以 MBytes 的容量显示各文件系统；
<span class="calibre34">-h  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</span>
-H  ：以 M=1000K 取代 M=1024K 的进位方式；
-T  ：连同该 partition 的 filesystem 名称 （例如 xfs） 也列出；
<span class="calibre34">-i  ：不用磁盘容量，而以 inode 的数量来显示</span></span>

<span class="term_hd">范例一：将系统内所有的 filesystem 列出来！</span>
[root@study ~]# <span class="term_command">df</span>
Filesystem              <span class="term_command">1K-blocks</span>    Used Available Use% Mounted on
/dev/mapper/centos-root  10475520 3409408   7066112  33% /
devtmpfs                   627700       0    627700   0% /dev
tmpfs                      637568      80    637488   1% /dev/shm
tmpfs                      637568   24684    612884   4% /run
tmpfs                      637568       0    637568   0% /sys/fs/cgroup
/dev/mapper/centos-home   5232640   67720   5164920   2% /home
/dev/vda2                 1038336  133704    904632  13% /boot
<span class="term_say"># 在 Linux 下面如果 df 没有加任何选项，那么默认会将系统内所有的 
# （不含特殊内存内的文件系统与 swap） 都以 1 KBytes 的容量来列出来！
# 至于那个 /dev/shm 是与内存有关的挂载，先不要理他！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 34--------------------------------------------------<br/>--------------------------------------------------35--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：将容量结果以易读的容量格式显示出来</span>
[root@study ~]# <span class="term_command">df -h</span>
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root   10G  3.3G  6.8G  33% /
devtmpfs                 613M     0  613M   0% /dev
tmpfs                    623M   80K  623M   1% /dev/shm
tmpfs                    623M   25M  599M   4% /run
tmpfs                    623M     0  623M   0% /sys/fs/cgroup
/dev/mapper/centos-home  5.0G   67M  5.0G   2% /home
/dev/vda2               1014M  131M  884M  13% /boot
<span class="term_say"># 不同于范例一，这里会以 G/M 等容量格式显示出来，比较容易看啦！</span>

<span class="term_hd">范例三：将系统内的所有特殊文件格式及名称都列出来</span>
[root@study ~]# <span class="term_command">df -aT</span>
Filesystem              <span class="term_command">Type</span>        1K-blocks    Used Available Use% Mounted on
rootfs                  rootfs       10475520 3409368   7066152  33% /
proc                    proc                0       0         0    - /proc
sysfs                   sysfs               0       0         0    - /sys
devtmpfs                devtmpfs       627700       0    627700   0% /dev
securityfs              securityfs          0       0         0    - /sys/kernel/security
tmpfs                   tmpfs          637568      80    637488   1% /dev/shm
devpts                  devpts              0       0         0    - /dev/pts
tmpfs                   tmpfs          637568   24684    612884   4% /run
tmpfs                   tmpfs          637568       0    637568   0% /sys/fs/cgroup
<span class="term_say">.....（中间省略）.....</span>
/dev/mapper/centos-root xfs          10475520 3409368   7066152  33% /
selinuxfs               selinuxfs           0       0         0    - /sys/fs/selinux
<span class="term_say">.....（中间省略）.....</span>
/dev/mapper/centos-home xfs           5232640   67720   5164920   2% /home
/dev/vda2               xfs           1038336  133704    904632  13% /boot
binfmt_misc             binfmt_misc         0       0         0    - /proc/sys/fs/binfmt_misc
<span class="term_say"># 系统里面其实还有很多特殊的文件系统存在的。那些比较特殊的文件系统几乎
# 都是在内存当中，例如 /proc 这个挂载点。因此，这些特殊的文件系统
# 都不会占据磁盘空间喔！ ^_^</span>

<span class="term_hd">范例四：将 /etc 下面的可用的磁盘容量以易读的容量格式显示</span>
[root@study ~]# <span class="term_command">df -h /etc</span>
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root   10G  3.3G  6.8G  33% /
<span class="term_say"># 这个范例比较有趣一点啦，在 df 后面加上目录或者是文件时， df
# 会自动的分析该目录或文件所在的 partition ，并将该 partition 的容量显示出来，
# 所以，您就可以知道某个目录下面还有多少容量可以使用了！ ^_^</span>

<span class="term_hd">范例五：将目前各个 partition 当中可用的 inode 数量列出</span>
[root@study ~]# <span class="term_command">df -ih </span>
Filesystem              <span class="term_command">Inodes</span> IUsed IFree IUse% Mounted on
/dev/mapper/centos-root    10M  108K  9.9M    2% /
devtmpfs                  154K   397  153K    1% /dev
tmpfs                     156K     5  156K    1% /dev/shm
tmpfs                     156K   497  156K    1% /run
tmpfs                     156K    13  156K    1% /sys/fs/cgroup
<span class="term_say"># 这个范例则主要列出可用的 inode 剩余量与总容量。分析一下与范例一的关系，
# 你可以清楚的发现到，通常 inode 的数量剩余都比 block 还要多呢</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 35--------------------------------------------------<br/>--------------------------------------------------36--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">du [-ahskm] 文件或目录名称</span>
<span class="term_say">选项与参数：
-a  ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已。
-h  ：以人们较易读的容量格式 （G/M） 显示；
<span class="calibre34">-s  ：列出总量而已，而不列出每个各别的目录占用容量；</span>
-S  ：不包括子目录下的总计，与 -s 有点差别。
-k  ：以 KBytes 列出容量显示；
-m  ：以 MBytes 列出容量显示；</span>

<span class="term_hd">范例一：列出目前目录下的所有文件大小</span>
[root@study ~]# <span class="term_command">du</span>
4       ./.cache/dconf  <span class="term_note">&lt;==每个目录都会列出来</span>
4       ./.cache/abrt
8       ./.cache
<span class="term_say">....（中间省略）....</span>
0       ./test4
4       ./.ssh          <span class="term_note">&lt;==包括隐藏文件的目录</span>
76      .               <span class="term_note">&lt;==这个目录（.）所占用的总量</span>
<span class="term_say"># 直接输入 du 没有加任何选项时，则 du 会分析“目前所在目录”
# 的文件与目录所占用的磁盘空间。但是，实际显示时，仅会显示目录容量（不含文件），
# 因此 . 目录有很多文件没有被列出来，所以全部的目录相加不会等于 . 的容量喔！
# 此外，输出的数值数据为 1K 大小的容量单位。</span>

<span class="term_hd">范例二：同范例一，但是将文件的容量也列出来</span>
[root@study ~]# <span class="term_command">du -a</span>
4       ./.bash_logout         <span class="term_note">&lt;==有文件的列表了</span>
4       ./.bash_profile
4       ./.bashrc
<span class="term_say">....（中间省略）....</span>
4       ./.ssh/known_hosts
4       ./.ssh
76      .

<span class="term_hd">范例三：检查根目录下面每个目录所占用的容量</span>
[root@study ~]# <span class="term_command">du -sm /*</span>
0       /bin
99      /boot
<span class="term_say">....（中间省略）....</span>
du: cannot access ‘/proc/17772/task/17772/fd/4’: No such file or directory
du: cannot access ‘/proc/17772/fdinfo/4’: No such file or directory
0       /proc      <span class="term_note">&lt;==不会占用硬盘空间！</span>
1       /root
25      /run
<span class="term_say">....（中间省略）....</span>
3126    /usr       <span class="term_note">&lt;==系统初期最大就是他了啦！</span>
117     /var
<span class="term_say"># 这是个很常被使用的功能～利用万用字符 * 来代表每个目录，如果想要检查某个目录下，
# 哪个次目录占用最大的容量，可以用这个方法找出来。值得注意的是，如果刚刚安装好 Linux 时，
# 那么整个系统容量最大的应该是 /usr 。而 /proc 虽然有列出容量，但是那个容量是在内存中，
# 不占磁盘空间。至于 /proc 里头会列出一堆“No such file or directory” 的错误，
# 别担心！因为是内存内的程序，程序执行结束就会消失，因此会有些目录找不到，是正确的！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 36--------------------------------------------------<br/>--------------------------------------------------37--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">ln [-sf] 来源文件 目标文件</span>
<span class="term_say">选项与参数：
<span class="calibre34">-s  ：如果不加任何参数就进行链接，那就是hard link，至于 -s 就是symbolic link</span>
-f  ：如果 目标文件 存在时，就主动的将目标文件直接移除后再创建！</span>

<span class="term_hd">范例一：将 /etc/passwd 复制到 /tmp 下面，并且观察 inode 与 block</span>
[root@study ~]# <span class="term_command">cd /tmp</span>
[root@study tmp]# <span class="term_command">cp -a /etc/passwd .</span>
[root@study tmp]# <span class="term_command">du -sb ; df -i .</span>
<span class="term_command">6602</span>    .   <span class="term_note">&lt;==先注意一下这里的容量是多少！</span>
Filesystem                Inodes  IUsed    IFree IUse% Mounted on
/dev/mapper/centos-root 10485760 <span class="term_command">109748</span> 10376012    2% /
<span class="term_say"># 利用 du 与 df 来检查一下目前的参数～那个 du -sb 是计算整个 /tmp 下面有多少 Bytes 的容量啦！</span>

<span class="term_hd">范例二：将 /tmp/passwd 制作 hard link 成为 passwd-hd 文件，并观察文件与容量</span>
[root@study tmp]# <span class="term_command">ln passwd passwd-hd</span>
[root@study tmp]# <span class="term_command">du -sb ; df -i .</span>
<span class="term_command">6602</span>    .
Filesystem                Inodes  IUsed    IFree IUse% Mounted on
/dev/mapper/centos-root 10485760 <span class="term_command">109748</span> 10376012    2% /
<span class="term_say"># 仔细看，即使多了一个文件在 /tmp 下面，整个 inode 与 block 的容量并没有改变！</span>

[root@study tmp]# <span class="term_command">ls -il passwd*</span>
<span class="term_command">2668897</span> -rw-r--r--. <span class="term_command">2</span> root root 2092 Jun 17 00:20 passwd
<span class="term_command">2668897</span> -rw-r--r--. <span class="term_command">2</span> root root 2092 Jun 17 00:20 passwd-hd
<span class="term_say"># 原来是指向同一个 inode 啊！这是个重点啊！另外，那个第二栏的链接数也会增加！</span>

<span class="term_hd">范例三：将 /tmp/passwd 创建一个符号链接</span>
[root@study tmp]# <span class="term_command">ln -s passwd passwd-so</span>
[root@study tmp]# <span class="term_command">ls -li passwd*</span>
2668897 -rw-r--r--. 2 root root 2092 Jun 17 00:20 passwd
2668897 -rw-r--r--. 2 root root 2092 Jun 17 00:20 passwd-hd
<span class="term_command">2668898</span> lrwxrwxrwx. 1 root root    <span class="term_command">6</span> Jun 23 22:40 passwd-so -&gt; passwd
<span class="term_say"># passwd-so 指向的 inode number 不同了！这是一个新的文件～这个文件的内容是指向 
# passwd 的。passwd-so 的大小是 6Bytes ，因为 “passwd” 这个单字共有六个字符之故</span>

[root@study tmp]# <span class="term_command">du -sb ; df -i .</span>
<span class="term_command">6608</span>    .
Filesystem                Inodes  IUsed    IFree IUse% Mounted on
/dev/mapper/centos-root 10485760 <span class="term_command">109749</span> 10376011    2% /
<span class="term_say"># 呼呼！整个容量与 inode 使用数都改变啰～确实如此啊！</span>

<span class="term_hd">范例四：删除原始文件 passwd ，其他两个文件是否能够打开？</span>
[root@study tmp]# <span class="term_command">rm passwd</span>
[root@study tmp]# <span class="term_command">cat passwd-hd</span>
<span class="term_say">.....（正常显示完毕！）</span>
[root@study tmp]# <span class="term_command">cat passwd-so</span>
cat: passwd-so: No such file or directory
[root@study tmp]# <span class="term_command">ll passwd*</span>
-rw-r--r--. 1 root root 2092 Jun 17 00:20 passwd-hd
lrwxrwxrwx. 1 root root    6 Jun 23 22:40 <span class="term_command">passwd-so</span> -&gt; <span class="term_command">passwd</span>
<span class="term_say"># 怕了吧！符号链接果然无法打开！另外，如果符号链接的目标文件不存在，
# 其实文件名的部分就会有特殊的颜色显示喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 37--------------------------------------------------<br/>--------------------------------------------------38--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">lsblk [-dfimpt] [device]</span>
<span class="term_say">选项与参数：
-d  ：仅列出磁盘本身，并不会列出该磁盘的分区数据
-f  ：同时列出该磁盘内的文件系统名称
-i  ：使用 ASCII 的线段输出，不要使用复杂的编码 （再某些环境下很有用）
-m  ：同时输出该设备在 /dev 下面的权限数据 （rwx 的数据）
-p  ：列出该设备的完整文件名！而不是仅列出最后的名字而已。
-t  ：列出该磁盘设备的详细数据，包括磁盘伫列机制、预读写的数据量大小等</span>

<span class="term_hd">范例一：列出本系统下的所有磁盘与磁盘内的分区信息</span>
[root@study ~]# <span class="term_command">lsblk</span>
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sr0              11:0    1 1024M  0 rom
vda             252:0    0   40G  0 disk             <span class="term_note"># 一整颗磁盘</span>
|-vda1          252:1    0    2M  0 part
|-vda2          252:2    0    1G  0 part /boot
`-vda3          252:3    0   30G  0 part
  |-centos-root 253:0    0   10G  0 lvm  /           <span class="term_note"># 在 vda3 内的其他文件系统</span>
  |-centos-swap 253:1    0    1G  0 lvm  [SWAP]
  `-centos-home 253:2    0    5G  0 lvm  /home
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 38--------------------------------------------------<br/>--------------------------------------------------39--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：仅列出 /dev/vda 设备内的所有数据的完整文件名</span>
[root@study ~]# <span class="term_command">lsblk -ip /dev/vda</span>
NAME                        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
/dev/vda                    252:0    0   40G  0 disk
|-/dev/vda1                 252:1    0    2M  0 part
|-/dev/vda2                 252:2    0    1G  0 part /boot
`-/dev/vda3                 252:3    0   30G  0 part
  |-/dev/mapper/centos-root 253:0    0   10G  0 lvm  /
  |-/dev/mapper/centos-swap 253:1    0    1G  0 lvm  [SWAP]
  `-/dev/mapper/centos-home 253:2    0    5G  0 lvm  /home        <span class="term_note"># 完整的文件名，由 / 开始写</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 39--------------------------------------------------<br/>--------------------------------------------------40--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">parted device_name print</span>

<span class="term_hd">范例一：列出 /dev/vda 磁盘的相关数据</span>
[root@study ~]# <span class="term_command">parted /dev/vda print</span>
Model: Virtio Block Device （virtblk）        <span class="term_note"># 磁盘的模块名称（厂商）</span>
Disk /dev/vda: 42.9GB                       <span class="term_note"># 磁盘的总容量</span>
Sector size （logical/physical）: 512B/512B   <span class="term_note"># 磁盘的每个逻辑/物理扇区容量</span>
<span class="term_command">Partition Table: gpt</span>                        <span class="term_note"># 分区表的格式 （MBR/GPT）</span>
Disk Flags: pmbr_boot

Number  Start   End     Size    File system  Name  Flags      <span class="term_note"># 下面才是分区数据</span>
 1      1049kB  3146kB  2097kB                     bios_grub
 2      3146kB  1077MB  1074MB  xfs
 3      1077MB  33.3GB  32.2GB                     lvm
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 40--------------------------------------------------<br/>--------------------------------------------------41--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">gdisk 设备名称</span>

<span class="term_hd">范例：由前一小节的 lsblk 输出，我们知道系统有个 /dev/vda，请观察该磁盘的分区与相关数据</span>
[root@study ~]# <span class="term_command">gdisk /dev/vda</span>  <span class="term_note">&lt;==仔细看，不要加上数字喔！</span>
GPT fdisk （gdisk） version 0.8.6

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

<span class="term_command">Found valid GPT with protective MBR; using GPT.</span>  <span class="term_note">&lt;==找到了 GPT 的分区表！</span>

Command （? for help）: <span class="term_command"> </span>   <span class="term_note">&lt;==这里可以让你输入指令动作，可以按问号 （?） 来查看可用指令</span>
Command （? for help）: <span class="term_command">?</span>
b       back up GPT data to a file
c       change a partition's name
<span class="term_write">d       delete a partition</span>           <span class="term_note"># 删除一个分区</span>
i       show detailed information on a partition
l       list known partition types
<span class="term_write">n       add a new partition</span>          <span class="term_note"># 增加一个分区</span>
o       create a new empty GUID partition table （GPT）
<span class="term_write">p       print the partition table</span>    <span class="term_note"># 印出分区表 （常用）</span>
<span class="term_write">q       quit without saving changes</span>  <span class="term_note"># 不储存分区就直接离开 gdisk</span>
r       recovery and transformation options （experts only）
s       sort partitions
t       change a partition's type code
v       verify disk
<span class="term_write">w       write table to disk and exit</span> <span class="term_note"># 储存分区操作后离开 gdisk</span>
x       extra functionality （experts only）
?       print this menu
Command （? for help）: <span class="term_command"> </span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 41--------------------------------------------------<br/>--------------------------------------------------42--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f] \
                         [-r parms] 设备名称</span>
<span class="term_say">选项与参数：
关於单位：下面只要谈到“数值”时，没有加单位则为 Bytes 值，可以用 k,m,g,t,p （小写）等来解释
          比较特殊的是 s 这个单位，它指的是 sector 的“个数”喔！
-b  ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！
-d  ：后面接的是重要的 data section 的相关参数值，主要的值有：
      agcount=数值  ：设置需要几个储存群组的意思（AG），通常与 CPU 有关
      agsize=数值   ：每个 AG 设置为多少容量的意思，通常 agcount/agsize 只选一个设置即可
      file          ：指的是“格式化的设备是个文件而不是个设备”的意思！（例如虚拟磁盘）
      size=数值     ：data section 的容量，亦即你可以不将全部的设备容量用完的意思
      su=数值       ：当有 RAID 时，那个 stripe 数值的意思，与下面的 sw 搭配使用
      sw=数值       ：当有 RAID 时，用于储存数据的磁盘数量（须扣除备份碟与备用碟）
      sunit=数值    ：与 su 相当，不过单位使用的是“几个 sector（512Bytes大小）”的意思
      swidth=数值   ：就是 su*sw 的数值，但是以“几个 sector（512Bytes大小）”来设置
-f  ：如果设备内已经有文件系统，则需要使用这个 -f 来强制格式化才行！
-i  ：与 inode 有较相关的设置，主要的设置值有：
      size=数值     ：最小是 256Bytes 最大是 2k，一般保留 256 就足够使用了！
      internal=[0|1]：log 设备是否为内置？默认为 1 内置，如果要用外部设备，使用下面设置
      logdev=device ：log 设备为后面接的那个设备上头的意思，需设置 internal=0 才可！
      size=数值     ：指定这块登录区的容量，通常最小得要有 512 个 block，大约 2M 以上才行！
-L  ：后面接这个文件系统的标头名称 Label name 的意思！
-r  ：指定 realtime section 的相关设置值，常见的有：
      extsize=数值  ：就是那个重要的 extent 数值，一般不须设置，但有 RAID 时，
                      最好设置与 swidth 的数值相同较佳！最小为 4K 最大为 1G 。</span>

<span class="term_hd">范例：将前一小节分区出来的 /dev/vda4 格式化为 xfs 文件系统</span>
[root@study ~]# <span class="term_command">mkfs.xfs /dev/vda4</span>
meta-data=/dev/vda4       <span class="term_command">isize=256</span>    agcount=4, agsize=65536 blks
         =                sectsz=512   attr=2, projid32bit=1
         =                crc=0        finobt=0
data     =                <span class="term_command">bsize=4096</span>   blocks=262144, imaxpct=25
         =                sunit=0      swidth=0 blks
naming   =version 2       bsize=4096   ascii-ci=0 ftype=0
log      =internal log    bsize=4096   blocks=2560, version=2
         =                sectsz=512   sunit=0 blks, lazy-count=1
realtime =none            extsz=4096   blocks=0, rtextents=0
<span class="term_say"># 很快格是化完毕！都用默认值！较重要的是 inode 与 block 的数值</span>

[root@study ~]# <span class="term_command">blkid /dev/vda4</span>
/dev/vda4: UUID="39293f4f-627b-4dfd-a015-08340537709c" TYPE="xfs"
<span class="term_say"># 确定创建好 xfs 文件系统了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 42--------------------------------------------------<br/>--------------------------------------------------43--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：找出你系统的 CPU 数，并据以设置你的 agcount 数值</span>
[root@study ~]# <span class="term_command">grep 'processor' /proc/cpuinfo</span>
processor       : 0
processor       : 1
<span class="term_say"># 所以就是有两颗 CPU 的意思，那就来设置设置我们的 xfs 文件系统格式化参数吧！！</span>

[root@study ~]# <span class="term_command">mkfs.xfs -f -d agcount=2 /dev/vda4</span>
meta-data=/dev/vda4       isize=256    <span class="term_command">agcount=2, agsize=131072 blks</span>
         =                sectsz=512   attr=2, projid32bit=1
         =                crc=0        finobt=0
<span class="term_say">.....（下面省略）.....
# 可以跟前一个范例对照看看，可以发现 agcount 变成 2 了喔！
# 此外，因为已经格式化过一次，因此 mkfs.xfs 可能会出现不给你格式化的警告！因此需要使用 -f</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 43--------------------------------------------------<br/>--------------------------------------------------44--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">mkfs.ext4 [-b size] [-L label] 设备名称</span>
<span class="term_say">选项与参数：
-b  ：设置 block 的大小，有 1K, 2K, 4K 的容量，
-L  ：后面接这个设备的标头名称。</span>

<span class="term_hd">范例：将 /dev/vda5 格式化为 ext4 文件系统</span>
[root@study ~]# <span class="term_command">mkfs.ext4 /dev/vda5</span>
mke2fs 1.42.9 （28-Dec-2013）
Filesystem label=                                  <span class="term_note"># 显示 Label name</span>
OS type: Linux
Block size=4096 （log=2）                            <span class="term_note"># 每一个 block 的大小</span>
Fragment size=4096 （log=2）
Stride=0 blocks, Stripe width=0 blocks             <span class="term_note"># 跟 RAID 相关性较高</span>
65536 inodes, 262144 blocks                        <span class="term_note"># 总计 inode/block 的数量</span>
13107 blocks （5.00%） reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups                                     <span class="term_note"># 共有 8 个 block groups 喔！</span>
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376

Allocating group tables: done
Writing inode tables: done
Creating journal （8192 blocks）: done
Writing superblocks and filesystem accounting information: done

[root@study ~]# <span class="term_command">dumpe2fs -h /dev/vda5</span>
dumpe2fs 1.42.9 （28-Dec-2013）
Filesystem volume name:   &lt;none&gt;
Last mounted on:          &lt;not available&gt;
Filesystem UUID:          3fd5cc6f-a47d-46c0-98c0-d43b072e0e12
<span class="term_say">....（中间省略）....</span>
Inode count:              65536
Block count:              262144
Block size:               4096
Blocks per group:         32768
Inode size:               256
Journal size:             32M
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 44--------------------------------------------------<br/>--------------------------------------------------45--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">xfs_repair [-fnd] 设备名称</span>
<span class="term_say">选项与参数：
-f  ：后面的设备其实是个文件而不是实体设备
-n  ：单纯检查并不修改文件系统的任何数据 （检查而已）
-d  ：通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作！很危险！不要随便使用</span>

<span class="term_hd">范例：检查一下刚刚创建的 /dev/vda4 文件系统</span>
[root@study ~]# <span class="term_command">xfs_repair /dev/vda4</span>
Phase 1 - find and verify superblock...
Phase 2 - using internal log
Phase 3 - for each AG...
Phase 4 - check for duplicate blocks...
Phase 5 - rebuild AG headers and trees...
Phase 6 - check inode connectivity...
Phase 7 - verify and correct link counts...
done
<span class="term_say"># 共有 7 个重要的检查流程！详细的流程介绍可以 man xfs_repair 即可！</span>

<span class="term_hd">范例：检查一下系统原本就有的 /dev/centos/home 文件系统</span>
[root@study ~]# <span class="term_command">xfs_repair /dev/centos/home</span>
xfs_repair: /dev/centos/home contains a mounted filesystem
xfs_repair: /dev/centos/home contains a mounted and writable filesystem

fatal error -- couldn't initialize XFS library
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 45--------------------------------------------------<br/>--------------------------------------------------46--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">fsck.ext4 [-pf] [-b superblock] 设备名称</span>
<span class="term_say">选项与参数：
-p  ：当文件系统在修复时，若有需要回复 y 的动作时，自动回复 y 来继续进行修复动作。
-f  ：强制检查！一般来说，如果 fsck 没有发现任何 unclean 的旗标，不会主动进入
      细部检查的，如果您想要强制 fsck 进入细部检查，就得加上 -f 旗标啰！
-D  ：针对文件系统下的目录进行最优化配置。
-b  ：后面接 superblock 的位置！一般来说这个选项用不到。但是如果你的 superblock 因故损毁时，
      通过这个参数即可利用文件系统内备份的 superblock 来尝试救援。一般来说，superblock 备份在：
      1K block 放在 8193, 2K block 放在 16384, 4K block 放在 32768</span>

<span class="term_hd">范例：找出刚刚创建的 /dev/vda5 的另一块 superblock，并据以检测系统</span>
[root@study ~]# <span class="term_command">dumpe2fs -h /dev/vda5 | grep 'Blocks per group'</span>
Blocks per group:         32768
<span class="term_say"># 看起来每个 block 群组会有 32768 个 block，因此第二个 superblock 应该就在 32768 上！
# 因为 block 号码为 0 号开始编的！</span>

[root@study ~]# <span class="term_command">fsck.ext4 -b 32768 /dev/vda5</span>
e2fsck 1.42.9 （28-Dec-2013）
/dev/vda5 was not cleanly unmounted, check forced.
Pass 1: Checking inodes, blocks, and sizes
Deleted inode 1577 has zero dtime.  Fix&lt;y&gt;? <span class="term_command">yes</span>
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information

/dev/vda5: ***** FILE SYSTEM WAS MODIFIED *****  <span class="term_note"># 文件系统被改过，所以这里会有警告！</span>
/dev/vda5: 11/65536 files （0.0% non-contiguous）, 12955/262144 blocks
<span class="term_say"># 好巧合！鸟哥使用这个方式来检验系统，恰好遇到文件系统出问题！于是可以有比较多的解释方向！
# 当文件系统出问题，它就会要你选择是否修复～如果修复如上所示，按下 y 即可！
# 最终系统会告诉你，文件系统已经被更改过，要注意该项目的意思！</span>

<span class="term_hd">范例：已默认设置强制检查一次 /dev/vda5</span>
[root@study ~]# <span class="term_command">fsck.ext4 /dev/vda5</span>
e2fsck 1.42.9 （28-Dec-2013）
/dev/vda5: clean, 11/65536 files, 12955/262144 blocks
<span class="term_say"># 文件系统状态正常，它并不会进入强制检查！会告诉你文件系统没问题 （clean）</span>

[root@study ~]# <span class="term_command">fsck.ext4 -f /dev/vda5</span>
e2fsck 1.42.9 （28-Dec-2013）
Pass 1: Checking inodes, blocks, and sizes
<span class="term_say">....（下面省略）....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 46--------------------------------------------------<br/>--------------------------------------------------47--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：找出 /dev/vda4 的 UUID 后，用该 UUID 来挂载文件系统到 /data/xfs 内</span>
[root@study ~]# <span class="term_command">blkid /dev/vda4</span>
/dev/vda4: <span class="term_command">UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90"</span> TYPE="xfs"

[root@study ~]# <span class="term_command">mount UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" /data/xfs</span>
mount: mount point /data/xfs does not exist  <span class="term_note"># 非正规目录！所以手动创建它！</span>

[root@study ~]# <span class="term_command">mkdir -p /data/xfs</span>
[root@study ~]# <span class="term_command">mount UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" /data/xfs</span>
[root@study ~]# <span class="term_command">df /data/xfs</span>
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/vda4        <span class="term_command">1038336</span> 32864   1005472   4% /data/xfs
<span class="term_say"># 顺利挂载，且容量约为 1G 左右没问题！</span>

<span class="term_hd">范例：使用相同的方式，将 /dev/vda5 挂载于 /data/ext4</span>
[root@study ~]# <span class="term_command">blkid /dev/vda5</span>
/dev/vda5: UUID="899b755b-1da4-4d1d-9b1c-f762adb798e1" TYPE="ext4"

[root@study ~]# <span class="term_command">mkdir /data/ext4</span>
[root@study ~]# <span class="term_command">mount UUID="899b755b-1da4-4d1d-9b1c-f762adb798e1" /data/ext4</span>
[root@study ~]# <span class="term_command">df /data/ext4</span>
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/vda5         <span class="term_command">999320</span>  2564    927944   1% /data/ext4
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 47--------------------------------------------------<br/>--------------------------------------------------48--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：将你用来安装 Linux 的 CentOS 原版光盘拿出来挂载到 /data/cdrom！</span>
[root@study ~]# <span class="term_command">blkid</span>
<span class="term_say">.....（前面省略）.....</span>
<span class="term_command">/dev/sr0</span>: UUID="2015-04-01-00-21-36-00" LABEL="CentOS 7 x86_64" TYPE="iso9660" PTTYPE="dos"

[root@study ~]# <span class="term_command">mkdir /data/cdrom</span>
[root@study ~]# <span class="term_command">mount /dev/sr0 /data/cdrom</span>
mount: /dev/sr0 is write-protected, mounting read-only

[root@study ~]# <span class="term_command">df /data/cdrom</span>
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sr0         7413478 7413478         0 100% /data/cdrom
<span class="term_say"># 怎么会使用掉 100% 呢？是啊！因为是 DVD 啊！所以无法再写入了啊！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 48--------------------------------------------------<br/>--------------------------------------------------49--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：找出你的U盘设备的 UUID，并挂载到 /data/usb 目录中</span>
[root@study ~]# <span class="term_command">blkid</span>
/dev/sda1: <span class="term_command">UUID="35BC-6D6B"</span> TYPE="vfat"

[root@study ~]# <span class="term_command">mkdir /data/usb</span>
[root@study ~]# <span class="term_command">  mount -o codepage=950,iocharset=utf8 UUID="35BC-6D6B" /data/usb</span>
[root@study ~]# <span class="term_command"># mount -o codepage=950,iocharset=big5 UUID="35BC-6D6B" /data/usb</span>
[root@study ~]# <span class="term_command">df /data/usb</span>
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/sda1        2092344     4   2092340   1% /data/usb
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 49--------------------------------------------------<br/>--------------------------------------------------50--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：将 / 重新挂载，并加入参数为 rw 与 auto</span>
[root@study ~]# <span class="term_command">mount -o remount,rw,auto /</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 50--------------------------------------------------<br/>--------------------------------------------------51--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：将 /var 这个目录暂时挂载到 /data/var 下面：</span>
[root@study ~]# <span class="term_command">mkdir /data/var</span>
[root@study ~]# <span class="term_command">mount --bind /var /data/var</span>
[root@study ~]# <span class="term_command">ls -lid /var /data/var</span>
16777346 drwxr-xr-x. 22 root root 4096 Jun 15 23:43 /data/var
16777346 drwxr-xr-x. 22 root root 4096 Jun 15 23:43 /var
<span class="term_say"># 内容完全一模一样啊！因为挂载目录的缘故！</span>

[root@study ~]# <span class="term_command">mount | grep var</span>
/dev/mapper/centos-root on /data/var type xfs （rw,relatime,seclabel,attr2,inode64,noquota）
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 51--------------------------------------------------<br/>--------------------------------------------------52--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：将本章之前自行挂载的文件系统全部卸载：</span>
[root@study ~]# <span class="term_command">mount</span>
<span class="term_say">.....（前面省略）.....</span>
<span class="term_command">/dev/vda4</span> on <span class="term_command">/data/xfs</span> type xfs （rw,relatime,seclabel,attr2,inode64,logbsize=256k,sunit=512,..）
<span class="term_command">/dev/vda5</span> on <span class="term_command">/data/ext4</span> type ext4 （rw,relatime,seclabel,data=ordered）
<span class="term_command">/dev/sr0</span> on <span class="term_command">/data/cdrom</span> type iso9660 （ro,relatime）
<span class="term_command">/dev/sda1</span> on <span class="term_command">/data/usb</span> type vfat （rw,relatime,fmask=0022,dmask=0022,codepage=950,iocharset=...）
<span class="term_command">/dev/mapper/centos-root</span> on <span class="term_command">/data/var</span> type xfs （rw,relatime,seclabel,attr2,inode64,noquota）
<span class="term_say"># 先找一下已经挂载的文件系统，如上所示，特殊字体即为刚刚挂载的设备啰！
# 基本上，卸载后面接设备或挂载点都可以！不过最后一个 centos-root 由于有其他挂载，
# 因此，该项目一定要使用挂载点来卸载才行！</span>

[root@study ~]# <span class="term_command">umount /dev/vda4    </span>  <span class="term_note">&lt;==用设备文件名来卸载</span>
[root@study ~]# <span class="term_command">umount /data/ext4   </span>  <span class="term_note">&lt;==用挂载点来卸载</span>
[root@study ~]# <span class="term_command">umount /data/cdrom  </span>  <span class="term_note">&lt;==因为挂载点比较好记忆！</span>
[root@study ~]# <span class="term_command">umount /data/usb    </span> 
[root@study ~]# <span class="term_command">umount /data/var    </span>  <span class="term_note">&lt;==一定要用挂载点！因为设备有被其他方式挂载</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 52--------------------------------------------------<br/>--------------------------------------------------53--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">mknod 设备文件名 [bcp] [Major] [Minor]</span>
<span class="term_say">选项与参数：
设备种类：
   b  ：设置设备名称成为一个周边储存设备文件，例如磁盘等；
   c  ：设置设备名称成为一个周边输入设备文件，例如鼠标/键盘等；
   p  ：设置设备名称成为一个 FIFO 文件；
Major ：主要设备代码；
Minor ：次要设备代码；</span>

<span class="term_hd">范例：由上述的介绍我们知道 /dev/vda10 设备代码 252, 10，请创建并查阅此设备</span>
[root@study ~]# <span class="term_command">mknod /dev/vda10 b 252 10</span>
[root@study ~]# <span class="term_command">ll /dev/vda10</span>
<span class="term_command">b</span>rw-r--r--. 1 root root <span class="term_command">252, 10</span> Jun 24 23:40 /dev/vda10
<span class="term_say"># 上面那个 252 与 10 是有意义的，不要随意设置啊！</span>

<span class="term_hd">范例：创建一个 FIFO 文件，文件名为 /tmp/testpipe</span>
[root@study ~]# <span class="term_command">mknod /tmp/testpipe p</span>
[root@study ~]# <span class="term_command">ll /tmp/testpipe</span>
<span class="term_command">p</span>rw-r--r--. 1 root root 0 Jun 24 23:44 /tmp/testpipe
<span class="term_say"># 注意啊！这个文件可不是一般文件，不可以随便就放在这里！
# 测试完毕之后请删除这个文件吧！看一下这个文件的类型！是 p 喔！^_^</span>

[root@study ~]# <span class="term_command">rm /dev/vda10 /tmp/testpipe</span>
rm: remove block special file '/dev/vda10' ? <span class="term_command">y</span>
rm: remove fifo '/tmp/testpipe' ? <span class="term_command">y</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 53--------------------------------------------------<br/>--------------------------------------------------54--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">xfs_admin [-lu] [-L label] [-U uuid] 设备文件名</span>
<span class="term_say">选项与参数：
-l  ：列出这个设备的 label name
-u  ：列出这个设备的 UUID
-L  ：设置这个设备的 Label name
-U  ：设置这个设备的 UUID 喔！</span>

<span class="term_hd">范例：设置 /dev/vda4 的 label name 为 vbird_xfs，并测试挂载</span>
[root@study ~]# <span class="term_command">xfs_admin -L vbird_xfs /dev/vda4</span>
writing all SBs
new label = "vbird_xfs"                 <span class="term_note"># 产生新的 LABEL 名称啰！</span>
[root@study ~]# <span class="term_command">xfs_admin -l /dev/vda4</span>
label = "vbird_xfs"
[root@study ~]# <span class="term_command">mount LABEL=vbird_xfs /data/xfs/</span>

<span class="term_hd">范例：利用 uuidgen 产生新 UUID 来设置 /dev/vda4，并测试挂载</span>
[root@study ~]# <span class="term_command">umount /dev/vda4</span>       <span class="term_note"># 使用前，请先卸载！</span>
[root@study ~]# <span class="term_command">uuidgen</span>
e0fa7252-b374-4a06-987a-3cb14f415488    <span class="term_note"># 很有趣的指令！可以产生新的 UUID 喔！</span>
[root@study ~]# <span class="term_command">xfs_admin -u /dev/vda4</span>
UUID = e0a6af55-26e7-4cb7-a515-826a8bd29e90
[root@study ~]# <span class="term_command">xfs_admin -U e0fa7252-b374-4a06-987a-3cb14f415488 /dev/vda4</span>
Clearing log and setting UUID
writing all SBs
new UUID = e0fa7252-b374-4a06-987a-3cb14f415488
[root@study ~]# <span class="term_command">mount UUID=e0fa7252-b374-4a06-987a-3cb14f415488 /data/xfs</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 54--------------------------------------------------<br/>--------------------------------------------------55--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">tune2fs [-l] [-L Label] [-U uuid] 设备文件名</span>
<span class="term_say">选项与参数：
-l  ：类似 dumpe2fs -h 的功能～将 superblock 内的数据读出来～
-L  ：修改 LABEL name
-U  ：修改 UUID 啰！</span>

<span class="term_hd">范例：列出 /dev/vda5 的 label name 之后，将它改成 vbird_ext4</span>
[root@study ~]# <span class="term_command">dumpe2fs -h /dev/vda5 | grep name</span>
dumpe2fs 1.42.9 （28-Dec-2013）
Filesystem volume name:   &lt;none&gt;   <span class="term_note"># 果然是没有设置的！</span>

[root@study ~]# <span class="term_command">tune2fs -L vbird_ext4 /dev/vda5</span>
[root@study ~]# <span class="term_command">dumpe2fs -h /dev/vda5 | grep name</span>
Filesystem volume name:   vbird_ext4
[root@study ~]# <span class="term_command">mount LABEL=vbird_ext4 /data/ext4</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 55--------------------------------------------------<br/>--------------------------------------------------56--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">parted [设备] [指令 [参数]]</span>
<span class="term_say">选项与参数：
指令功能：
          新增分区：mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束
          显示分区：print
          删除分区：rm [partition]</span>

<span class="term_hd">范例一：以 parted 列出目前本机的分区表数据</span>
[root@study ~]# <span class="term_command">parted /dev/vda print</span>
Model: Virtio Block Device （virtblk）         <span class="term_note">&lt;==磁盘接口与型号</span>
Disk /dev/vda: 42.9GB                        <span class="term_note">&lt;==磁盘文件名与容量</span>
Sector size （logical/physical）: 512B/512B    <span class="term_note">&lt;==每个扇区的大小</span>
Partition Table: gpt                         <span class="term_note">&lt;==是 GPT 还是 MBR 分区</span>
Disk Flags: pmbr_boot

Number  Start   End     Size    File system     Name                  Flags
 1      1049kB  3146kB  2097kB                                        bios_grub
 2      3146kB  1077MB  1074MB  xfs
 3      1077MB  33.3GB  32.2GB                                        lvm
 4      33.3GB  34.4GB  1074MB  xfs             Linux filesystem
 5      34.4GB  35.4GB  1074MB  ext4            Microsoft basic data
 6      35.4GB  36.0GB  537MB   linux-swap（v1）  Linux swap
<span class="term_say">[  1 ]  [  2 ]  [  3  ] [  4  ] [  5  ]         [  6  ]</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 56--------------------------------------------------<br/>--------------------------------------------------57--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：将 /dev/sda 这个原本的 MBR 分区表变成 GPT 分区表！（危险！危险！勿乱搞！无法复原！）</span>
[root@study ~]# <span class="term_command">parted /dev/sda print</span>
Model: ATA QEMU HARDDISK （scsi）
Disk /dev/sda: 2148MB
Sector size （logical/physical）: 512B/512B
Partition Table: msdos    <span class="term_note"># 确实显示的是 MBR 的 msdos 格式喔！</span>

[root@study ~]# <span class="term_command">parted /dev/sda mklabel gpt</span>
Warning: The existing disk label on /dev/sda will be destroyed and all data on 
this disk will be lost. Do you want to continue?
Yes/No? <span class="term_command">y</span>

[root@study ~]# <span class="term_command">parted /dev/sda print</span>
<span class="term_say"># 你应该就会看到变成 gpt 的模样！只是...后续的分区就全部都死掉了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 57--------------------------------------------------<br/>--------------------------------------------------58--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：创建一个约为 512MB 容量的分区</span>
[root@study ~]# <span class="term_command">parted /dev/vda print</span>
<span class="term_say">.....（前面省略）.....</span>
Number  Start   End     Size    File system     Name                  Flags
<span class="term_say">.....（中间省略）.....</span>
 6      35.4GB  <span class="term_command">36.0GB</span>  537MB   linux-swap（v1）  Linux swap  <span class="term_note"># 要先找出来下一个分区的起始点！</span>

[root@study ~]# <span class="term_command">parted /dev/vda mkpart primary fat32 36.0GB 36.5GB</span>
<span class="term_say"># 由于新的分区的起始点在前一个分区的后面，所以当然要先找出前面那个分区的 End 位置！
# 然后再请参考 mkpart 的指令功能，就能够处理好相关的动作！</span>
[root@study ~]# <span class="term_command">parted /dev/vda print</span>
<span class="term_say">.....（前面省略）.....</span>
Number  Start   End     Size    File system     Name                  Flags
<span class="term_command"> 7      36.0GB  36.5GB  522MB                   primary</span>

[root@study ~]# <span class="term_command">partprobe</span>
[root@study ~]# <span class="term_command">lsblk /dev/vda7</span>
NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
vda7 252:7    0  498M  0 part      <span class="term_note"># 要确定它是真的存在才行！</span>

[root@study ~]# <span class="term_command">mkfs -t vfat /dev/vda7</span>
[root@study ~]# <span class="term_command">blkid /dev/vda7</span>
/dev/vda7: SEC_TYPE="msdos" UUID="6032-BF38" TYPE="vfat"

[root@study ~]# <span class="term_command">nano /etc/fstab</span>
<span class="term_command">UUID="6032-BF38"  /data/win  vfat  defaults   0  0</span>

[root@study ~]# <span class="term_command">mkdir /data/win</span>
[root@study ~]# <span class="term_command">mount -a</span>
[root@study ~]# <span class="term_command">df /data/win</span>
Filesystem     1K-blocks  Used Available Use% Mounted on
<span class="term_command">/dev/vda7</span>         509672     0    509672   0% /data/win
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 58--------------------------------------------------<br/>--------------------------------------------------59--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">gzip [-cdtv#] 文件名</span>
[dmtsai@study ~]$ <span class="term_command">zcat 文件名.gz</span>
<span class="term_say">选项与参数：
-c  ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；
-d  ：解压缩的参数；
-t  ：可以用来检验一个压缩文件的一致性～看看文件有无错误；
-v  ：可以显示出原文件/压缩文件的压缩比等信息；
-#  ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6</span>

<span class="term_hd">范例一：找出 /etc 下面 （不含子目录） 容量最大的文件，并将它复制到 /tmp ，然后以 gzip 压缩</span>
[dmtsai@study ~]$ <span class="term_command">ls -ldSr /etc/*</span>   <span class="term_note"># 忘记选项意义？请自行 man 啰！</span>
<span class="term_say">.....（前面省略）.....</span>
-rw-r--r--.  1 root root    25213 Jun 10  2014 /etc/dnsmasq.conf
-rw-r--r--.  1 root root    69768 May  4 17:55 /etc/ld.so.cache
<span class="calibre34">-rw-r--r--.  1 root root   670293 Jun  7  2013 /etc/services</span>

[dmtsai@study ~]$ <span class="term_command">cd /tmp </span>
[dmtsai@study tmp]$ <span class="term_command">cp /etc/services .</span>
[dmtsai@study tmp]$ <span class="term_command">gzip -v services</span>
services:        79.7% -- replaced with services.gz
[dmtsai@study tmp]$ <span class="term_command">ll /etc/services /tmp/services*</span>
-rw-r--r--. 1 root   root   <span class="term_command">670293</span> Jun  7  2013 /etc/services
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command">136088</span> Jun 30 18:40 /tmp/services.gz
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 59--------------------------------------------------<br/>--------------------------------------------------60--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：由于 services 是文本文件，请将范例一的压缩文件的内容读出来！</span>
[dmtsai@study tmp]$ <span class="term_command">zcat services.gz</span>
<span class="term_say"># 由于 services 这个原本的文件是是文本文件，因此我们可以尝试使用 zcat/zmore/zless 去读取！
# 此时屏幕上会显示 servcies.gz 解压缩之后的原始文件内容！</span>

<span class="term_hd">范例三：将范例一的文件解压缩</span>
[dmtsai@study tmp]$ <span class="term_command">gzip -d services.gz</span>
<span class="term_say"># 鸟哥不要使用 gunzip 这个指令，不好背！使用 gzip -d 来进行解压缩！
# 与 gzip 相反， gzip -d 会将原本的 .gz 删除，回复到原本的 services 文件。</span>

<span class="term_hd">范例四：将范例三解开的 services 用最佳的压缩比压缩，并保留原本的文件</span>
[dmtsai@study tmp]$ <span class="term_command">gzip -9 -c services &gt; services.gz</span>

<span class="term_hd">范例五：由范例四再次创建的 services.gz 中，找出 http 这个关键字在哪几行？</span>
[dmtsai@study tmp]$ <span class="term_command">zgrep -n 'http' services.gz</span>
14:#       http://www.iana.org/assignments/port-numbers
89:http            80/tcp          www www-http    # WorldWideWeb HTTP
90:http            80/udp          www www-http    # HyperText Transfer Protocol
<span class="term_say">.....（下面省略）.....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 60--------------------------------------------------<br/>--------------------------------------------------61--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">bzip2 [-cdkzv#] 文件名</span>
[dmtsai@study ~]$ <span class="term_command">bzcat 文件名.bz2</span>
<span class="term_say">选项与参数：
-c  ：将压缩的过程产生的数据输出到屏幕上！
-d  ：解压缩的参数
-k  ：保留原始文件，而不会删除原始的文件喔！
-z  ：压缩的参数 （默认值，可以不加）
-v  ：可以显示出原文件/压缩文件的压缩比等信息；
-#  ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</span>

<span class="term_hd">范例一：将刚刚 gzip 范例留下来的 /tmp/services 以 bzip2 压缩</span>
[dmtsai@study tmp]$ <span class="term_command">bzip2 -v services</span>
  services:  5.409:1,  1.479 bits/Byte, 81.51% saved, 670293 in, 123932 out.
[dmtsai@study tmp]$ <span class="term_command">ls -l services*</span>
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command">123932</span> Jun 30 18:40 services.bz2
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_command">135489</span> Jun 30 18:46 services.gz
<span class="term_say"># 此时 services 会变成 services.bz2 之外，你也可以发现 bzip2 的压缩比要较 gzip 好喔！！
# 压缩率由 gzip 的 79% 提升到 bzip2 的 81% 哩！</span>

<span class="term_hd">范例二：将范例一的文件内容读出来！</span>
[dmtsai@study tmp]$ <span class="term_command">bzcat services.bz2</span>

<span class="term_hd">范例三：将范例一的文件解压缩</span>
[dmtsai@study tmp]$ <span class="term_command">bzip2 -d services.bz2</span>

<span class="term_hd">范例四：将范例三解开的 services 用最佳的压缩比压缩，并保留原本的文件</span>
[dmtsai@study tmp]$ <span class="term_command">bzip2 -9 -c services &gt; services.bz2</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 61--------------------------------------------------<br/>--------------------------------------------------62--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">xz [-dtlkc#] 文件名</span>
[dmtsai@study ~]$ <span class="term_command">xcat 文件名.xz</span>
<span class="term_say">选项与参数：
-d  ：就是解压缩啊！
-t  ：测试压缩文件的完整性，看有没有错误
-l  ：列出压缩文件的相关信息
-k  ：保留原本的文件不删除～
-c  ：同样的，就是将数据由屏幕上输出的意思！
-#  ：同样的，也有较佳的压缩比的意思！</span>

<span class="term_hd">范例一：将刚刚由 bzip2 所遗留下来的 /tmp/services 通过 xz 来压缩！</span>
[dmtsai@study tmp]$ <span class="term_command">xz -v services</span>
services （1/1）
  100 %        97.3 KiB / 654.6 KiB = 0.149

[dmtsai@study tmp]$ <span class="term_command">ls -l services*</span>
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_command">123932</span> Jun 30 19:09 services.bz2
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_command">135489</span> Jun 30 18:46 services.gz
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command"> 99608</span> Jun 30 18:40 services.xz
<span class="term_say"># 各位观众！看到没有啊！！容量又进一步下降的更多耶！好棒的压缩比！</span>

<span class="term_hd">范例二：列出这个压缩文件的信息，然后读出这个压缩文件的内容</span>
[dmtsai@study tmp]$ <span class="term_command">xz -l services.xz</span>
Strms  Blocks   Compressed Uncompressed  Ratio  Check   Filename
    1       1     97.3 KiB    654.6 KiB  0.149  CRC64   services.xz
<span class="term_say"># 竟然可以列出这个文件的压缩前后的容量，真是太人性化了！这样观察就方便多了！</span>

[dmtsai@study tmp]$ <span class="term_command">xzcat services.xz</span>

<span class="term_hd">范例三：将他解压缩吧！</span>
[dmtsai@study tmp]$ <span class="term_command">xz -d services.xz</span>

<span class="term_hd">范例四：保留原文件的文件名，并且创建压缩文件！</span>
[dmtsai@study tmp]$ <span class="term_command">xz -k services</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 62--------------------------------------------------<br/>--------------------------------------------------63--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：将文件名中的（根）目录也备份下来，并察看一下备份文件的内容文件名</span>
[root@study ~]# <span class="term_command">tar -jp<u class="calibre34">P</u>cv -f /root/etc.and.root.tar.bz2 /etc</span>

[root@study ~]# <span class="term_command">tar -jtf /root/etc.and.root.tar.bz2</span>
<span class="term_command">/</span>etc/locale.conf
<span class="term_command">/</span>etc/hostname
<span class="term_command">/</span>etc/aliases.db
<span class="term_say"># 这次查阅文件名不含 -v 选项，所以仅有文件名而已！没有详细属性/权限等参数。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 63--------------------------------------------------<br/>--------------------------------------------------64--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">dd if="input_file" of="output_file" bs="block_size" count="number"</span>
<span class="term_say">选项与参数：
if   ：就是 input file 啰～也可以是设备喔！
of   ：就是 output file 喔～也可以是设备；
bs   ：规划的一个 block 的大小，若未指定则默认是 512 Bytes（一个 sector 的大小）
count：多少个 bs 的意思。</span>

<span class="term_hd">范例一：将 /etc/passwd 备份到 /tmp/passwd.back 当中</span>
[root@study ~]# <span class="term_command">dd if=/etc/passwd of=/tmp/passwd.back</span>
4+1 records in
4+1 records out
2092 Bytes （2.1 kB） copied, 0.000111657 s, 18.7 MB/s
[root@study ~]# <span class="term_command">ll /etc/passwd /tmp/passwd.back</span>
-rw-r--r--. 1 root root 2092 Jun 17 00:20 /etc/passwd
-rw-r--r--. 1 root root 2092 Jul  2 23:27 /tmp/passwd.back
<span class="term_say"># 仔细的看一下，我的 /etc/passwd 文件大小为 2092 Bytes，因为我没有设置 bs ，
# 所以默认是 512 Bytes 为一个单位，因此，上面那个 4+1 表示有 4 个完整的 512 Bytes，
# 以及未满 512 Bytes 的另一个 block 的意思啦！事实上，感觉好像是 cp 这个指令啦～</span>

<span class="term_hd">范例二：将刚刚烧录的光驱的内容，再次的备份下来成为图像挡</span>
[root@study ~]# <span class="term_command">dd if=/dev/sr0 of=/tmp/system.iso</span>
177612+0 records in
177612+0 records out
90937344 Bytes （91 MB） copied, 22.111 s, 4.1 MB/s
<span class="term_say"># 要将数据抓下来用这个方法，如果是要将镜像文件写入 USB 磁盘，就会变如下一个范例啰！</span>

<span class="term_hd">范例三：假设你的 USB 是 /dev/sda 好了，请将刚刚范例二的 image 烧录到 USB 磁盘中</span>
[root@study ~]# <span class="term_command">lsblk /dev/sda</span>
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda    8:0    0   2G  0 disk             <span class="term_note"># 确实是 disk 而且有 2GB 喔！</span>

[root@study ~]# <span class="term_command">dd if=/tmp/system.iso of=/dev/sda</span>
[root@study ~]# <span class="term_command">mount /dev/sda /mnt</span>
[root@study ~]# <span class="term_command">ll /mnt</span>
dr-xr-xr-x. 131 root root 34816 Jun 26 22:14 etc
dr-xr-xr-x.   5 root root  2048 Jun 17 00:20 home
dr-xr-xr-x.   8 root root  4096 Jul  2 18:48 root
<span class="term_say"># 如果你不想要使用 DVD 来作为开机媒体，那可以将镜像文件使用这个 dd 写入 USB 磁盘，
# 该磁盘就会变成跟可开机光盘一样的功能！可以让你用 USB 来安装 Linux 喔！速度快很多！</span>

<span class="term_hd">范例四：将你的 /boot 整个文件系统通过 dd 备份下来</span>
[root@study ~]# <span class="term_command">df -h /boot</span>
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda2      1014M  149M  866M  15% /boot       <span class="term_note"># 请注意！备份的容量会到 1G 喔！</span>
[root@study ~]# <span class="term_command">dd if=/dev/vda2 of=/tmp/vda2.img</span>
[root@study ~]# <span class="term_command">ll -h /tmp/vda2.img</span>
-rw-r--r--. 1 root root <span class="term_command">1.0G</span> Jul  2 23:39 /tmp/vda2.img
<span class="term_say"># 等于是将整个 /dev/vda2 通通捉下来的意思～所以，文件大小会跟整颗磁盘的最大量一样大！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 64--------------------------------------------------<br/>--------------------------------------------------65--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：找出 /boot 下面的所有文件，然后将他备份到 /tmp/boot.cpio 去！</span>
[root@study ~]# <span class="term_command">cd /</span>
[root@study /]# <span class="term_command">find boot -print</span>
boot
boot/grub
boot/grub/splash.xpm.gz
<span class="term_say">....（以下省略）....
# 通过 find 我们可以找到 boot 下面应该要存在的文件名！包括文件与目录！但请千万不要是绝对路径！</span>

[root@study /]# <span class="term_command">find boot | cpio -ocvB &gt; /tmp/boot.cpio</span>
[root@study /]# <span class="term_command">ll -h /tmp/boot.cpio</span>
-rw-r--r--. 1 root root 108M Jul  3 00:05 /tmp/boot.cpio
[root@study ~]# <span class="term_command">file /tmp/boot.cpio</span>
/tmp/boot.cpio: <span class="term_command">ASCII cpio</span> archive （SVR4 with no CRC）
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 65--------------------------------------------------<br/>--------------------------------------------------66--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：将刚刚的文件给他在 /root/ 目录下解开</span>
[root@study ~]# <span class="term_command">cd ~</span>
[root@study ~]# <span class="term_command">cpio -idvc &lt; /tmp/boot.cpio</span>
[root@study ~]# <span class="term_command">ll /root/boot</span>
<span class="term_say"># 你可以自行比较一下 /root/boot 与 /boot 的内容是否一模一样！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 66--------------------------------------------------<br/>--------------------------------------------------67--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">dos2unix [-kn] file [newfile]</span>
[dmtsai@study ~]$ <span class="term_command">unix2dos [-kn] file [newfile]</span>
<span class="term_say">选项与参数：
-k  ：保留该文件原本的 mtime 时间格式 （不更新文件上次内容经过修订的时间）
-n  ：保留原本的旧文件，将转换后的内容输出到新文件，如： dos2unix -n old new</span>

<span class="term_hd">范例一：将 /etc/man_db.conf 重新复制到 /tmp/vitest/ 下面，并将其修改成为 dos 断行</span>
[dmtsai@study ~]# <span class="term_command">cd /tmp/vitest</span>
[dmtsai@study vitest]$ <span class="term_command">cp -a /etc/man_db.conf .</span>
[dmtsai@study vitest]$ <span class="term_command">ll man_db.conf</span>
-rw-r--r--. 1 root root <span class="term_command">5171</span> Jun 10  2014 man_db.conf
[dmtsai@study vitest]$ <span class="term_command">unix2dos -k man_db.conf</span>
unix2dos: converting file man_db.conf to DOS format ...
<span class="term_say"># 屏幕会显示上述的讯息，说明断行转为 DOS 格式了！</span>
[dmtsai@study vitest]$ <span class="term_command">ll man_db.conf</span>
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command">5302</span> Jun 10  2014 man_db.conf
<span class="term_say"># 断行字符多了 ^M ，所以容量增加了！</span>

<span class="term_hd">范例二：将上述的 man_db.conf 转成 Linux 断行字符，并保留旧文件，新文件放于 man_db.conf.linux</span>
[dmtsai@study vitest]$ <span class="term_command">dos2unix -k -n man_db.conf man_db.conf.linux</span>
dos2unix: converting file man_db.conf to file man_db.conf.linux in Unix format ...
[dmtsai@study vitest]$ <span class="term_command">ll man_db.conf*</span>
-rw-r--r--. 1 dmtsai dmtsai 5302 Jun 10  2014 man_db.conf
-rw-r--r--. 1 dmtsai dmtsai 5171 Jun 10  2014 man_db.conf.linux
[dmtsai@study vitest]$ <span class="term_command">file man_db.conf*</span>
man_db.conf:       ASCII text, with CRLF line terminators  <span class="term_note"># 很清楚说明是 CRLF 断行！</span>
man_db.conf.linux: ASCII text
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 67--------------------------------------------------<br/>--------------------------------------------------68--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">iconv --list</span>
[dmtsai@study ~]$ <span class="term_command">iconv -f 原本编码 -t 新编码 filename [-o newfile]</span>
<span class="term_say">选项与参数：
--list ：列出 iconv 支持的语系数据
-f     ：from ，亦即来源之意，后接原本的编码格式；
-t     ：to ，亦即后来的新编码要是什么格式；
-o file：如果要保留原本的文件，那么使用 -o 新文件名，可以创建新编码文件。</span>

<span class="term_hd">范例一：将 /tmp/vitest/vi.big5 转成 utf8 编码吧！</span>
[dmtsai@study ~]$ <span class="term_command">cd /tmp/vitest</span>
[dmtsai@study vitest]$ <span class="term_command">iconv -f big5 -t utf8 vi.big5 -o vi.utf8</span>
[dmtsai@study vitest]$ <span class="term_command">file vi*</span>
vi.big5: ISO-8859 text, with CRLF line terminators
vi.utf8: UTF-8 Unicode text, with CRLF line terminators
<span class="term_say"># 是吧！有明显的不同吧！ ^_^</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 68--------------------------------------------------<br/>--------------------------------------------------69--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">type [-tpa] name</span>
<span class="term_say">选项与参数：
    ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令
-t  ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：
      file    ：表示为外部指令；
      alias   ：表示该指令为命令别名所设置的名称；
      builtin ：表示该指令为 bash 内置的指令功能；
-p  ：如果后面接的 name 为外部指令时，才会显示完整文件名；
-a  ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</span>

<span class="term_hd">范例一：查询一下 ls 这个指令是否为 bash 内置？</span>
[dmtsai@study ~]$ <span class="term_command">type ls</span>
ls is aliased to `ls --color=auto' <span class="term_note">&lt;==未加任何参数，列出 ls 的最主要使用情况</span>
[dmtsai@study ~]$ <span class="term_command">type -t ls</span>
alias                              <span class="term_note">&lt;==仅列出 ls 执行时的依据</span>
[dmtsai@study ~]$ <span class="term_command">type -a ls</span>
ls is aliased to `ls --color=auto' <span class="term_note">&lt;==最先使用 aliase</span>
ls is /usr/bin/ls                  <span class="term_note">&lt;==还有找到外部指令在 /bin/ls</span>

<span class="term_hd">范例二：那么 cd 呢？</span>
[dmtsai@study ~]$ <span class="term_command">type cd</span>
cd is a shell builtin              <span class="term_note">&lt;==看到了吗？ cd 是 shell 内置指令</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 69--------------------------------------------------<br/>--------------------------------------------------70--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：如果指令串太长的话，如何使用两行来输出？</span>
[dmtsai@study ~]$ <span class="term_command">cp /var/spool/mail/root /etc/crontab \</span>
&gt; <span class="term_command">/etc/fstab /root</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 70--------------------------------------------------<br/>--------------------------------------------------71--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：设置一变量 name ，且内容为 VBird</span>
[dmtsai@study ~]$ <span class="term_command">12name=VBird</span>
bash: 12name=VBird: command not found...  <span class="term_note">&lt;==屏幕会显示错误！因为不能以数字开头！</span>
[dmtsai@study ~]$ <span class="term_command">name = VBird</span>            <span class="term_note">&lt;==还是错误！因为有空白！</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird</span>              <span class="term_note">&lt;==OK 的啦！</span>

<span class="term_hd">范例二：承上题，若变量内容为 VBird's name 呢，就是变量内容含有特殊符号时：</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird's name</span>  
<span class="term_say"># <u class="calibre34">单引号与双引号必须要成对</u>，在上面的设置中仅有一个单引号，因此当你按下 enter 后，
# 你还可以继续输入变量内容。这与我们所需要的功能不同，失败啦！
# 记得，失败后要复原请按下 [ctrl]-c 结束！</span>
[dmtsai@study ~]$ <span class="term_command">name="VBird's name"</span>    <span class="term_note">&lt;==OK 的啦！</span>
<span class="term_say"># 指令是由左边向右找→，先遇到的引号先有用，因此如上所示， 单引号变成一般字符！</span>
[dmtsai@study ~]$ <span class="term_command">name='VBird's name'</span>    <span class="term_note">&lt;==失败的啦！</span>
<span class="term_say"># 因为前两个单引号已成对，后面就多了一个不成对的单引号了！因此也就失败了！</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird\'s\ name</span>     <span class="term_note">&lt;==OK 的啦！</span>
<span class="term_say"># 利用反斜线 （\） 跳脱特殊字符，例如单引号与空白键，这也是 OK 的啦！</span>

<span class="term_hd">范例三：我要在 PATH 这个变量当中“累加”:/home/dmtsai/bin 这个目录</span>
[dmtsai@study ~]$ <span class="term_command">PATH=$PATH:/home/dmtsai/bin</span>
[dmtsai@study ~]$ <span class="term_command">PATH="$PATH":/home/dmtsai/bin</span>
[dmtsai@study ~]$ <span class="term_command">PATH=${PATH}:/home/dmtsai/bin</span>
<span class="term_say"># 上面这三种格式在 PATH 里头的设置都是 OK 的！但是下面的例子就不见得啰！</span>

<span class="term_hd">范例四：承范例三，我要将 name 的内容多出 "yes" 呢？</span>
[dmtsai@study ~]$ <span class="term_command">name=$nameyes</span>  
<span class="term_say"># 知道了吧？如果没有双引号，那么变量成了啥？name 的内容是 $nameyes 这个变量！
# 呵呵！我们可没有设置过 nameyes 这个变量呐！所以，应该是下面这样才对！</span>
[dmtsai@study ~]$ <span class="term_command">name="$name"yes</span>
[dmtsai@study ~]$ <span class="term_command">name=${name}yes</span>  <span class="term_note">&lt;==以此例较佳！</span>

<span class="term_hd">范例五：如何让我刚刚设置的 name=VBird 可以用在下个 shell 的程序？</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird</span>
[dmtsai@study ~]$ <span class="term_command">bash      </span>  <span class="term_note">&lt;==进入到所谓的子程序</span>
[dmtsai@study ~]$ <span class="term_command">echo $name</span>  <span class="term_note">&lt;==子程序：再次的 echo 一下；</span>
       <span class="term_note">&lt;==嘿嘿！并没有刚刚设置的内容喔！</span>
[dmtsai@study ~]$ <span class="term_command">exit      </span>  <span class="term_note">&lt;==子程序：离开这个子程序</span>
[dmtsai@study ~]$ <span class="term_command">export name</span>
[dmtsai@study ~]$ <span class="term_command">bash      </span>  <span class="term_note">&lt;==进入到所谓的子程序</span>
[dmtsai@study ~]$ <span class="term_command">echo $name</span>  <span class="term_note">&lt;==子程序：在此执行！</span>
VBird  <span class="term_note">&lt;==看吧！出现设置值了！</span>
[dmtsai@study ~]$ <span class="term_command">exit      </span>  <span class="term_note">&lt;==子程序：离开这个子程序</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 71--------------------------------------------------<br/>--------------------------------------------------72--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例六：如何进入到您目前核心的模块目录？</span>
[dmtsai@study ~]$ <span class="term_command">cd /lib/modules/`uname -r`/kernel</span>
[dmtsai@study ~]$ <span class="term_command">cd /lib/modules/$（uname -r）/kernel</span>  <span class="term_note"># 以此例较佳！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 72--------------------------------------------------<br/>--------------------------------------------------73--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例七：取消刚刚设置的 name 这个变量内容</span>
[dmtsai@study ~]$ <span class="term_command">unset name</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 73--------------------------------------------------<br/>--------------------------------------------------74--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：列出目前的 shell 环境下的所有环境变量与其内容。</span>
[dmtsai@study ~]$ <span class="term_command">env</span>
HOSTNAME=study.centos.vbird    <span class="term_note">&lt;== 这部主机的主机名称</span>
TERM=xterm                     <span class="term_note">&lt;== 这个终端机使用的环境是什么类型</span>
SHELL=/bin/bash                <span class="term_note">&lt;== 目前这个环境下，使用的 Shell 是哪一个程序？</span>
HISTSIZE=1000                  <span class="term_note">&lt;== “记录指令的笔数”在 CentOS 默认可记录 1000 笔</span>
OLDPWD=/home/dmtsai            <span class="term_note">&lt;== 上一个工作目录的所在</span>
LC_ALL=en_US.utf8              <span class="term_note">&lt;== 由于语系的关系，鸟哥偷偷丢上来的一个设置</span>
USER=dmtsai                    <span class="term_note">&lt;== 使用者的名称啊！</span>
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:
or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:
*.tar=01...                    <span class="term_note">&lt;== 一些颜色显示</span>
MAIL=/var/spool/mail/dmtsai    <span class="term_note">&lt;== 这个使用者所取用的 mailbox 位置</span>
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
PWD=/home/dmtsai               <span class="term_note">&lt;== 目前使用者所在的工作目录 （利用 pwd 取出！）</span>
LANG=zh_TW.UTF-8               <span class="term_note">&lt;== 这个与语系有关，下面会再介绍！</span>
HOME=/home/dmtsai              <span class="term_note">&lt;== 这个使用者的主文件夹啊！</span>
LOGNAME=dmtsai                 <span class="term_note">&lt;== 登陆者用来登陆的帐号名称</span>
_=/usr/bin/env                 <span class="term_note">&lt;== 上一次使用的指令的最后一个参数（或指令本身）</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 74--------------------------------------------------<br/>--------------------------------------------------75--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">read [-pt] variable</span>
<span class="term_say">选项与参数：
-p  ：后面可以接提示字符！
-t  ：后面可以接等待的“秒数！”这个比较有趣～不会一直等待使用者啦！</span>

<span class="term_hd">范例一：让使用者由键盘输入一内容，将该内容变成名为 atest 的变量</span>
[dmtsai@study ~]$ <span class="term_command">read atest</span>
<span class="term_command">This is a test</span>        <span class="term_note">&lt;==此时光标会等待你输入！请输入左侧文字看看</span>
[dmtsai@study ~]$ <span class="term_command">echo ${atest}</span>
This is a test          <span class="term_note">&lt;==你刚刚输入的数据已经变成一个变量内容！</span>

<span class="term_hd">范例二：提示使用者 30 秒内输入自己的大名，将该输入字串作为名为 named 的变量内容</span>
[dmtsai@study ~]$ <span class="term_command">read -p "Please keyin your name: " -t 30 named</span>
Please keyin your name: <span class="term_command">VBird Tsai</span>   <span class="term_note">&lt;==注意看，会有提示字符喔！</span>
[dmtsai@study ~]$ <span class="term_command">echo ${named}</span>
VBird Tsai        <span class="term_note">&lt;==输入的数据又变成一个变量的内容了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 75--------------------------------------------------<br/>--------------------------------------------------76--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">declare [-aixr] variable</span>
<span class="term_say">选项与参数：
-a  ：将后面名为 variable 的变量定义成为阵列 （array） 类型
-i  ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型
-x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；
-r  ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset</span>

<span class="term_hd">范例一：让变量 sum 进行 100+300+50 的加总结果</span>
[dmtsai@study ~]$ <span class="term_command">sum=100+300+50</span>
[dmtsai@study ~]$ <span class="term_command">echo ${sum}</span>
100+300+50  <span class="term_note">&lt;==咦！怎么没有帮我计算加总？因为这是文字体态的变量属性啊！</span>
[dmtsai@study ~]$ <span class="term_command">declare -i sum=100+300+50</span>
[dmtsai@study ~]$ <span class="term_command">echo ${sum}</span>
450         <span class="term_note">&lt;==瞭乎？？</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 76--------------------------------------------------<br/>--------------------------------------------------77--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：将 sum 变成环境变量</span>
[dmtsai@study ~]$ <span class="term_command">declare -x sum</span>
[dmtsai@study ~]$ <span class="term_command">export | grep sum</span>
declare -ix sum="450"  <span class="term_note">&lt;==果然出现了！包括有 i 与 x 的宣告！</span>

<span class="term_hd">范例三：让 sum 变成只读属性，不可更动！</span>
[dmtsai@study ~]$ <span class="term_command">declare -r sum</span>
[dmtsai@study ~]$ <span class="term_command">sum=tesgting</span>
-bash: sum: readonly variable  <span class="term_note">&lt;==老天爷～不能改这个变量了！</span>

<span class="term_hd">范例四：让 sum 变成非环境变量的自订变量吧！</span>
[dmtsai@study ~]$ <span class="term_command">declare +x sum</span>  <span class="term_note">&lt;== 将 - 变成 + 可以进行“取消”动作</span>
[dmtsai@study ~]$ <span class="term_command">declare -p sum</span>  <span class="term_note">&lt;== -p 可以单独列出变量的类型</span>
declare -ir sum="450" <span class="term_note">&lt;== 看吧！只剩下 i, r 的类型，不具有 x 啰！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 77--------------------------------------------------<br/>--------------------------------------------------78--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例：设置上面提到的 var[1] ～ var[3] 的变量。</span>
[dmtsai@study ~]$ <span class="term_command">var[1]="small min"</span>
[dmtsai@study ~]$ <span class="term_command">var[2]="big min"</span>
[dmtsai@study ~]$ <span class="term_command">var[3]="nice min"</span>
[dmtsai@study ~]$ <span class="term_command">echo "${var[1]}, ${var[2]}, ${var[3]}"</span>
small min, big min, nice min
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 78--------------------------------------------------<br/>--------------------------------------------------79--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">ulimit [-SHacdfltu] [配额]</span>
<span class="term_say">选项与参数：
-H  ：hard limit ，严格的设置，必定不能超过这个设置的数值；
-S  ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。
      在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard 
      设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时，
      系统会有警告讯息通知你！
-a  ：后面不接任何选项与参数，可列出所有的限制额度；
-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），
      这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。
-f  ：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes
-d  ：程序可使用的最大断裂内存（segment）容量；
-l  ：可用于锁定 （lock） 的内存量
-t  ：可使用的最大 CPU 时间 （单位为秒）
-u  ：单一使用者可以使用的最大程序（process）数量。</span>

<span class="term_hd">范例一：列出你目前身份（假设为一般帐号）的所有限制数据数值</span>
[dmtsai@study ~]$ <span class="term_command">ulimit -a</span>
core file size          （blocks, -c） 0          <span class="term_note">&lt;==只要是 0 就代表没限制</span>
data seg size           （kBytes, -d） unlimited
scheduling priority             （-e） 0
<span class="term_command">file size               （blocks, -f） unlimited  <span class="term_note">&lt;==可创建的单一文件的大小</span></span>
pending signals                 （-i） 4903
max locked memory       （kBytes, -l） 64
max memory size         （kBytes, -m） unlimited
<span class="term_command">open files                      （-n） 1024       <span class="term_note">&lt;==同时可打开的文件数量</span></span>
pipe size            （512 Bytes, -p） 8
POSIX message queues     （Bytes, -q） 819200
real-time priority              （-r） 0
stack size              （kBytes, -s） 8192
cpu time               （seconds, -t） unlimited
max user processes              （-u） 4096
virtual memory          （kBytes, -v） unlimited
file locks                      （-x） unlimited

<span class="term_hd">范例二：限制使用者仅能创建 10MBytes 以下的容量的文件</span>
[dmtsai@study ~]$ <span class="term_command">ulimit -f 10240</span>
[dmtsai@study ~]$ <span class="term_command">ulimit -a | grep 'file size'</span>
core file size          （blocks, -c） 0
file size               （blocks, -f） 10240 <span class="term_note">&lt;==最大量为10240Kbyes，相当10MBytes</span>

[dmtsai@study ~]$ <span class="term_command">dd if=/dev/zero of=123 bs=1M count=20</span>
File size limit exceeded （core dumped） <span class="term_note">&lt;==尝试创建 20MB 的文件，结果失败了！</span>

[dmtsai@study ~]$ <span class="term_command">rm 123</span>  <span class="term_note">&lt;==赶快将这个文件删除啰！同时你得要登出再次的登陆才能解开 10M 的限制</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 79--------------------------------------------------<br/>--------------------------------------------------80--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：先让小写的 path 自订变量设置的与 PATH 内容相同</span>
[dmtsai@study ~]$ <span class="term_command">path=${PATH}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path}</span>
<span class="term_command">/usr/local/bin:</span>/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin

<span class="term_hd">范例二：假设我不喜欢 local/bin，所以要将前 1 个目录删除掉，如何显示？</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path#/*local/bin:}</span>
/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 80--------------------------------------------------<br/>--------------------------------------------------81--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_command">${</span>variable#/*local/bin:<span class="term_command">}</span>
<span class="term_say">   上面的特殊字体部分是关键字！用在这种删除模式所必须存在的</span>

${<span class="term_command">variable</span>#/*local/bin:}
<span class="term_say">   这就是原本的变量名称，以上面范例二来说，这里就填写 path 这个“变量名称”啦！</span>

${variable<span class="term_command">#</span>/*local/bin:}
<span class="term_say">   这是重点！代表“从变量内容的最前面开始向右删除”，且仅删除最短的那个</span>

${variable#<span class="term_command">/*local/bin:</span>}
<span class="term_say">   代表要被删除的部分，由于 # 代表由前面开始删除，所以这里便由开始的 / 写起。
   需要注意的是，我们还可以通过万用字符 * 来取代 0 到无穷多个任意字符</span>

<span class="term_say">   以上面范例二的结果来看， path 这个变量被删除的内容如下所示：</span>
<span class="calibre55">/usr/local/bin:</span>/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 81--------------------------------------------------<br/>--------------------------------------------------82--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：我想要删除前面所有的目录，仅保留最后一个目录</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path#/*:}</span>
/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say"># 由于一个 # 仅删除掉最短的那个，因此他删除的情况可以用下面的删除线来看：
# <span class="calibre55">/usr/local/bin:</span>/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span>

[dmtsai@study ~]$ <span class="term_command">echo ${path##/*:}</span>
/home/dmtsai/bin
<span class="term_say"># 嘿！多加了一个 # 变成 ## 之后，他变成“删除掉最长的那个数据”！亦即是：
# <span class="calibre55">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:</span>/home/dmtsai/bin</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 82--------------------------------------------------<br/>--------------------------------------------------83--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：我想要删除最后面那个目录，亦即从 : 到 bin 为止的字串</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path%:*bin}</span>
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin
<span class="term_say"># 注意啊！最后面一个目录不见去！</span>
<span class="term_say"># 这个 % 符号代表由最后面开始向前删除！所以上面得到的结果其实是来自如下：
# /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin<span class="calibre55">:/home/dmtsai/bin</span></span>

<span class="term_hd">范例五：那如果我只想要保留第一个目录呢？</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path%%:*bin}</span>
/usr/local/bin
<span class="term_say"># 同样的， %% 代表的则是最长的符合字串，所以结果其实是来自如下：
# /usr/local/bin<span class="calibre55">:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span></span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 83--------------------------------------------------<br/>--------------------------------------------------84--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例六：将 path 的变量内容内的 sbin 取代成大写 SBIN：</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path/sbin/SBIN}</span>
/usr/local/bin:/usr/bin:/usr/local/<span class="term_command">SBIN</span>:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say"># 这个部分就容易理解的多了！关键字在于那两个斜线，两斜线中间的是旧字串
# 后面的是新字串，所以结果就会出现如上述的特殊字体部分啰！</span>

[dmtsai@study ~]$ <span class="term_command">echo ${path//sbin/SBIN}</span>
/usr/local/bin:/usr/bin:/usr/local/<span class="term_command">SBIN</span>:/usr/<span class="term_command">SBIN</span>:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say"># 如果是两条斜线，那么就变成所有符合的内容都会被取代喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 84--------------------------------------------------<br/>--------------------------------------------------85--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：测试一下是否存在 username 这个变量，若不存在则给予 username 内容为 root</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
           <span class="term_note">&lt;==由于出现空白，所以 username 可能不存在，也可能是空字串</span>
[dmtsai@study ~]$ <span class="term_command">username=${username-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
root       <span class="term_note">&lt;==因为 username 没有设置，所以主动给予名为 root 的内容。</span>
[dmtsai@study ~]$ <span class="term_command">username="vbird tsai"</span> <span class="term_note">&lt;==主动设置 username 的内容</span>
[dmtsai@study ~]$ <span class="term_command">username=${username-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
vbird tsai <span class="term_note">&lt;==因为 username 已经设置了，所以使用旧有的设置而不以 root 取代</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 85--------------------------------------------------<br/>--------------------------------------------------86--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_command">new_var</span>=${old_var-content}
   <span class="term_say">新的变量，主要用来取代旧变量。新旧变量名称其实常常是一样的</span>

new_var=<span class="term_command">${</span>old_var<span class="term_command">-</span>content<span class="term_command">}</span>
   <span class="term_say">这是本范例中的关键字部分！必须要存在的哩！</span>

new_var=${<span class="term_command">old_var</span>-content}
   <span class="term_say">旧的变量，被测试的项目！</span>

new_var=${old_var-<span class="term_command">content</span>}
   <span class="term_say">变量的“内容”，在本范例中，这个部分是在“给予未设置变量的内容”</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 86--------------------------------------------------<br/>--------------------------------------------------87--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：若 username 未设置或为空字串，则将 username 内容设置为 root</span>
[dmtsai@study ~]$ <span class="term_command">username=""</span>
[dmtsai@study ~]$ <span class="term_command">username=${username-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
      <span class="term_note">&lt;==因为 username 被设置为空字串了！所以当然还是保留为空字串！</span>
[dmtsai@study ~]$ <span class="term_command">username=${username:-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
root  <span class="term_note">&lt;==加上“ : ”后若变量内容为空或者是未设置，都能够以后面的内容替换！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 87--------------------------------------------------<br/>--------------------------------------------------88--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">history [n]</span>
[dmtsai@study ~]$ <span class="term_command">history [-c]</span>
[dmtsai@study ~]$ <span class="term_command">history [-raw] histfiles</span>
<span class="term_say">选项与参数：
n   ：数字，意思是“要列出最近的 n 笔命令列表”的意思！
-c  ：将目前的 shell 中的所有 history 内容全部消除
-a  ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ，
      则默认写入 ~/.bash_history
-r  ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；
-w  ：将目前的 history 记忆内容写入 histfiles 中！</span>

<span class="term_hd">范例一：列出目前内存内的所有 history 记忆</span>
[dmtsai@study ~]$ <span class="term_command">history</span>
<span class="term_say"># 前面省略</span>
 1017  man bash
 1018  ll
 1019  history 
 1020  history
<span class="term_say"># 列出的信息当中，共分两栏，第一栏为该指令在这个 shell 当中的代码，
# 另一个则是指令本身的内容喔！至于会秀出几笔指令记录，则与 HISTSIZE 有关！</span>

<span class="term_hd">范例二：列出目前最近的 3 笔数据</span>
[dmtsai@study ~]$ <span class="term_command">history 3</span>
 1019  history 
 1020  history
 1021  history 3

<span class="term_hd">范例三：立刻将目前的数据写入 histfile 当中</span>
[dmtsai@study ~]$ <span class="term_command">history -w</span>
<span class="term_say"># 在默认的情况下，会将历史纪录写入 ~/.bash_history 当中！</span>
[dmtsai@study ~]$ <span class="term_command">echo ${HISTSIZE}</span>
1000
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 88--------------------------------------------------<br/>--------------------------------------------------89--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">source 配置文件文件名</span>

<span class="term_hd">范例：将主文件夹的 ~/.bashrc 的设置读入目前的 bash 环境中</span>
[dmtsai@study ~]$ <span class="term_command">source ~/.bashrc</span>  <span class="term_note">&lt;==下面这两个指令是一样的！</span>
[dmtsai@study ~]$ <span class="term_command"> .  ~/.bashrc</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 89--------------------------------------------------<br/>--------------------------------------------------90--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">stty [-a]</span>
<span class="term_say">选项与参数：
-a  ：将目前所有的 stty 参数列出来；</span>

<span class="term_hd">范例一：列出所有的按键与按键内容</span>
[dmtsai@study ~]$ <span class="term_command">stty -a</span>
speed 38400 baud; rows 20; columns 90; line = 0;
<span class="term_command">intr = ^C</span>; quit = ^\; <span class="term_command">erase = ^?</span>; kill = ^U; <span class="term_command">eof = ^D</span>; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
swtch = &lt;undef&gt;; <span class="term_command">start = ^Q</span>; <span class="term_command">stop = ^S</span>; <span class="term_command">susp = ^Z</span>; rprnt = ^R; werase = ^W; lnext = ^V;
flush = ^O; min = 1; time = 0;
<span class="term_say">....（以下省略）....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 90--------------------------------------------------<br/>--------------------------------------------------91--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">set [-uvCHhmBx]</span>
<span class="term_say">选项与参数：
-u  ：默认不启用。若启用后，当使用未设置变量时，会显示错误讯息；
-v  ：默认不启用。若启用后，在讯息被输出前，会先显示讯息的原始内容；
-x  ：默认不启用。若启用后，在指令被执行前，会显示指令内容（前面有 ++ 符号）
-h  ：默认启用。与历史命令有关；
-H  ：默认启用。与历史命令有关；
-m  ：默认启用。与工作管理有关；
-B  ：默认启用。与刮号 [] 的作用有关；
-C  ：默认不启用。若使用 &gt; 等，则若文件存在时，该文件不会被覆盖。</span>

<span class="term_hd">范例一：显示目前所有的 set 设置值</span>
[dmtsai@study ~]$ <span class="term_command">echo $-</span>
himBH
<span class="term_say"># 那个 $- 变量内容就是 set 的所有设置啦！ bash 默认是 himBH 喔！</span>

<span class="term_hd">范例二：设置 "若使用未定义变量时，则显示错误讯息" </span>
[dmtsai@study ~]$ <span class="term_command">set -u</span>
[dmtsai@study ~]$ <span class="term_command">echo $vbirding</span>
-bash: vbirding: unbound variable
<span class="term_say"># 默认情况下，未设置/未宣告 的变量都会是“空的”，不过，若设置 -u 参数，
# 那么当使用未设置的变量时，就会有问题啦！很多的 shell 都默认启用 -u 参数。
# 若要取消这个参数，输入 set +u 即可！</span>

<span class="term_hd">范例三：执行前，显示该指令内容。</span>
[dmtsai@study ~]$ <span class="term_command">set -x</span>
++ printf '\033]0;%s@%s:%s\007' dmtsai study '~'    <span class="term_note"># 这个是在列出提示字符的控制码！</span>
[dmtsai@study ~]$ <span class="term_command">echo ${HOME}</span>
+ echo /home/dmtsai
/home/dmtsai
++ printf '\033]0;%s@%s:%s\007' dmtsai study '~'
<span class="term_say"># 看见否？要输出的指令都会先被打印到屏幕上喔！前面会多出 + 的符号！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 91--------------------------------------------------<br/>--------------------------------------------------92--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">LANG=C            </span>  <span class="term_note">&lt;==由于与编码有关，先设置语系一下</span>

<span class="term_hd">范例一：找出 /etc/ 下面以 cron 为开头的文件名</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/cron*  </span>  <span class="term_note">&lt;==加上 -d 是为了仅显示目录而已</span>

<span class="term_hd">范例二：找出 /etc/ 下面文件名“刚好是五个字母”的文件名</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/?????  </span>  <span class="term_note">&lt;==由于 ? 一定有一个，所以五个 ? 就对了</span>

<span class="term_hd">范例三：找出 /etc/ 下面文件名含有数字的文件名</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/*[0-9]*</span>  <span class="term_note">&lt;==记得中括号左右两边均需 *</span>

<span class="term_hd">范例四：找出 /etc/ 下面，文件名开头非为小写字母的文件名：</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/[^a-z]*</span>  <span class="term_note">&lt;==注意中括号左边没有 *</span>

<span class="term_hd">范例五：将范例四找到的文件复制到 /tmp/upper 中</span>
[dmtsai@study ~]$ <span class="term_command">mkdir /tmp/upper; cp -a /etc/[^a-z]* /tmp/upper</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 92--------------------------------------------------<br/>--------------------------------------------------93--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：观察你的系统根目录 （/） 下各目录的文件名、权限与属性，并记录下来</span>
[dmtsai@study ~]$ <span class="term_command">ll /</span>  <span class="term_note">&lt;==此时屏幕会显示出文件名信息</span>

[dmtsai@study ~]$ <span class="term_command">ll / &gt; ~/rootfile</span> <span class="term_note">&lt;==屏幕并无任何信息</span>
[dmtsai@study ~]$ <span class="term_command">ll  ~/rootfile</span> <span class="term_note">&lt;==有个新文件被创建了！</span>
-rw-rw-r--. 1 dmtsai dmtsai 1078 Jul  9 18:51 /home/dmtsai/rootfile
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 93--------------------------------------------------<br/>--------------------------------------------------94--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：利用一般身份帐号搜寻 /home 下面是否有名为 .bashrc 的文件存在</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc</span> <span class="term_note">&lt;==身份是 dmtsai 喔！</span>
find: '/home/arod': Permission denied    <span class="term_note">&lt;== Standard error output</span>
find: '/home/alex': Permission denied    <span class="term_note">&lt;== Standard error output</span>
/home/dmtsai/.bashrc                     <span class="term_note">&lt;== Standard output</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 94--------------------------------------------------<br/>--------------------------------------------------95--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：承范例二，将 stdout 与 stderr 分存到不同的文件去</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &gt; list_right 2&gt; list_error</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 95--------------------------------------------------<br/>--------------------------------------------------96--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：承范例三，将错误的数据丢弃，屏幕上显示正确的数据</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc 2&gt; /dev/null</span>
/home/dmtsai/.bashrc  <span class="term_note">&lt;==只有 stdout 会显示到屏幕上， stderr 被丢弃了</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 96--------------------------------------------------<br/>--------------------------------------------------97--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例五：将指令的数据全部写入名为 list 的文件中</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &gt; list 2&gt; list</span>  <span class="term_note">&lt;==错误</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &gt; list 2&gt;&amp;1   </span>  <span class="term_note">&lt;==正确</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &amp;&gt; list       </span>  <span class="term_note">&lt;==正确</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 97--------------------------------------------------<br/>--------------------------------------------------98--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例六：利用 cat 指令来创建一个文件的简单流程</span>
[dmtsai@study ~]$ <span class="term_command">cat &gt; catfile</span>
<span class="term_command">testing
cat file test</span>
<span class="term_note">&lt;==这里按下 [ctrl]+d 来离开</span>

[dmtsai@study ~]$ <span class="term_command">cat catfile</span>
testing
cat file test
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 98--------------------------------------------------<br/>--------------------------------------------------99--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例七：用 stdin 取代键盘的输入以创建新文件的简单流程</span>
[dmtsai@study ~]$ <span class="term_command">cat &gt; catfile &lt; ~/.bashrc</span>
[dmtsai@study ~]$ <span class="term_command">ll catfile ~/.bashrc</span>
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command">231</span> Mar  6 06:06 /home/dmtsai/.bashrc
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_command">231</span> Jul  9 18:58 catfile
<span class="term_say"># 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 99--------------------------------------------------<br/>--------------------------------------------------100--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：使用 ls 查阅目录 /tmp/abc 是否存在，若存在则用 touch 创建 /tmp/abc/hehe </span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
ls: cannot access /tmp/abc: No such file or directory
<span class="term_say"># ls 很干脆的说明找不到该目录，但并没有 touch 的错误，表示 touch 并没有执行</span>

[dmtsai@study ~]$ <span class="term_command">mkdir /tmp/abc</span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
[dmtsai@study ~]$ <span class="term_command">ll /tmp/abc</span>
-rw-rw-r--. 1 dmtsai dmtsai 0 Jul  9 19:16 hehe
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 100--------------------------------------------------<br/>--------------------------------------------------101--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：测试 /tmp/abc 是否存在，若不存在则予以创建，若存在就不作任何事情</span>
[dmtsai@study ~]$ <span class="term_command">rm -r /tmp/abc               </span> <span class="term_note">&lt;==先删除此目录以方便测试</span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc || mkdir /tmp/abc</span>
ls: cannot access /tmp/abc: No such file or directory  <span class="term_note">&lt;==真的不存在喔！</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /tmp/abc                  </span>
drwxrwxr-x. 2 dmtsai dmtsai 6 Jul  9 19:17 /tmp/abca   <span class="term_note">&lt;==结果出现了！有进行 mkdir</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 101--------------------------------------------------<br/>--------------------------------------------------102--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：我不清楚 /tmp/abc 是否存在，但就是要创建 /tmp/abc/hehe 文件</span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 102--------------------------------------------------<br/>--------------------------------------------------103--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">cut -d'分隔字符' -f fields</span> <span class="term_note">&lt;==用于有特定分隔字符</span>
[dmtsai@study ~]$ <span class="term_command">cut -c 字符区间           </span> <span class="term_note">&lt;==用于排列整齐的讯息</span>
<span class="term_say">选项与参数：
-d  ：后面接分隔字符。与 -f 一起使用；
-f  ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；
-c  ：以字符 （characters） 的单位取出固定字符区间；</span>

<span class="term_hd"><a id="calibre_link-58" class="pcalibre"></a>范例一：将 PATH 变量取出，我要找出第五个路径。</span>
[dmtsai@study ~]$ <span class="term_command">echo ${PATH}</span>
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say">#      1      |    2   |       3       |    4    |           5           |      6         |</span>

[dmtsai@study ~]$ <span class="term_command">echo ${PATH} | cut -d ':' -f 5</span>
<span class="term_say"># 如同上面的数字显示，我们是以“ : ”作为分隔，因此会出现 /home/dmtsai/.local/bin
# 那么如果想要列出第 3 与第 5 呢？，就是这样：</span>
[dmtsai@study ~]$ <span class="term_command">echo ${PATH} | cut -d ':' -f 3,5</span>

<span class="term_hd">范例二：将 export 输出的讯息，取得第 12 字符以后的所有字串</span>
[dmtsai@study ~]$ <span class="term_command">export</span>
declare -x HISTCONTROL="ignoredups"
declare -x HISTSIZE="1000"
declare -x HOME="/home/dmtsai"
declare -x HOSTNAME="study.centos.vbird"
<span class="term_say">.....（其他省略）.....
# 注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做：</span>

[dmtsai@study ~]$ <span class="term_command">export | cut -c 12-</span>
HISTCONTROL="ignoredups"
HISTSIZE="1000"
HOME="/home/dmtsai"
HOSTNAME="study.centos.vbird"
<span class="term_say">.....（其他省略）.....
# 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！
# 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span>
<a id="calibre_link-11" class="pcalibre"></a>
<span class="term_hd">范例三：用 last 将显示的登陆者的信息中，仅留下使用者大名</span>
[dmtsai@study ~]$ <span class="term_command">last</span>
root   pts/1    192.168.201.101  Sat Feb  7 12:35   still logged in
root   pts/1    192.168.201.101  Fri Feb  6 12:13 - 18:46  （06:33）
root   pts/1    192.168.201.254  Thu Feb  5 22:37 - 23:53  （01:16）
<span class="term_say"># last 可以输出“帐号/终端机/来源/日期时间”的数据，并且是排列整齐的</span>

[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f 1</span>
<span class="term_say"># 由输出的结果我们可以发现第一个空白分隔的字段代表帐号，所以使用如上指令：
# 但是因为 root   pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 
# pts/1 其实不能以 cut -d ' ' -f 1,2 喔！输出的结果会不是我们想要的。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 103--------------------------------------------------<br/>--------------------------------------------------104--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">grep [-acinv] [--color=auto] '搜寻字串' filename</span>
<span class="term_say">选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 '搜寻字串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 '搜寻字串' 内容的那一行！
--color=auto ：可以将找到的关键字部分加上颜色的显示喔！</span>

<span class="term_hd">范例一：将 last 当中，有出现 root 的那一行就取出来；</span>
[dmtsai@study ~]$ <span class="term_command">last | grep 'root'</span>

<span class="term_hd">范例二：与范例一相反，只要没有 root 的就取出！</span>
[dmtsai@study ~]$ <span class="term_command">last | grep -v 'root'</span>

<span class="term_hd">范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏</span>
[dmtsai@study ~]$ <span class="term_command">last | grep 'root' |cut -d ' ' -f1</span>
<span class="term_say"># 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！</span>

<span class="term_hd">范例四：取出 /etc/man_db.conf 内含 MANPATH 的那几行</span>
[dmtsai@study ~]$ <span class="term_command">grep --color=auto 'MANPATH' /etc/man_db.conf</span>
<span class="term_say">....（前面省略）....</span>
<span class="term_command">MANPATH</span>_MAP     /usr/games              /usr/share/man
<span class="term_command">MANPATH</span>_MAP     /opt/bin                /opt/man
<span class="term_command">MANPATH</span>_MAP     /opt/sbin               /opt/man
<span class="term_say"># 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 104--------------------------------------------------<br/>--------------------------------------------------105--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">sort [-fbMnrtuk] [file or stdin]</span>
<span class="term_say">选项与参数：
-f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；
-b  ：忽略最前面的空白字符部分；
-M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
-n  ：使用“纯数字”进行排序（默认是以文字体态来排序的）；
-r  ：反向排序；
-u  ：就是 uniq ，相同的数据中，仅出现一行代表；
-t  ：分隔符号，默认是用 [tab] 键来分隔；
-k  ：以那个区间 （field） 来进行排序的意思</span>

<span class="term_hd">范例一：个人帐号都记录在 /etc/passwd 下，请将帐号进行排序。</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd | sort</span>
<span class="term_command">ab</span>rt:x:173:173::/etc/abrt:/sbin/nologin
<span class="term_command">ad</span>m:x:3:4:adm:/var/adm:/sbin/nologin
<span class="term_command">al</span>ex:x:1001:1002::/home/alex:/bin/bash
<span class="term_say"># 鸟哥省略很多的输出～由上面的数据看起来， sort 是默认“以第一个”数据来排序，
# 而且默认是以“文字”型态来排序的喔！所以由 a 开始排到最后啰！</span>

<span class="term_hd">范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd | sort -t ':' -k 3</span>
root:x:<span class="term_command">0</span>:0:root:/root:/bin/bash
dmtsai:x:<span class="term_command">1000</span>:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:<span class="term_command">1001</span>:1002::/home/alex:/bin/bash
arod:x:<span class="term_command">1002</span>:1003::/home/arod:/bin/bash
<span class="term_say"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～
# 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：
# cat /etc/passwd | sort -t ':' -k 3 -n
# 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span>

<span class="term_hd">范例三：利用 last ，将输出的数据仅取帐号，并加以排序</span>
[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f1 | sort</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 105--------------------------------------------------<br/>--------------------------------------------------106--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">uniq [-ic]</span>
<span class="term_say">选项与参数：
-i  ：忽略大小写字符的不同；
-c  ：进行计数</span>

<span class="term_hd">范例一：使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；</span>
[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f1 | sort | uniq</span>

<span class="term_hd">范例二：承上题，如果我还想要知道每个人的登陆总次数呢？</span>
[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f1 | sort | uniq -c</span>
      1
      6 （unknown
     47 dmtsai
      4 reboot
      7 root
      1 wtmp
<span class="term_say"># 从上面的结果可以发现 reboot 有 4 次， root 登陆则有 7 次！大部分是以 dmtsai 来操作！
# wtmp 与第一行的空白都是 last 的默认字符，那两个可以忽略的！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 106--------------------------------------------------<br/>--------------------------------------------------107--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">wc [-lwm]</span>
<span class="term_say">选项与参数：
-l  ：仅列出行；
-w  ：仅列出多少字（英文单字）；
-m  ：多少字符；</span>

<span class="term_hd">范例一：那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数？</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/man_db.conf | wc </span>
    131     723    5171
<span class="term_say"># 输出的三个数字中，分别代表： “行、字数、字符数”</span>

<span class="term_hd">范例二：我知道使用 last 可以输出登陆者，但是 last 最后两行并非帐号内容，那么请问，
        我该如何以一行指令串取得登陆系统的总人次？</span>
[dmtsai@study ~]$ <span class="term_command">last | grep [a-zA-Z] | grep -v 'wtmp' | grep -v 'reboot' | \</span>
&gt; <span class="term_command">grep -v 'unknown' |wc -l </span>
<span class="term_say"># 由于 last 会输出空白行, wtmp, unknown, reboot 等无关帐号登陆的信息，因此，我利用
# grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 107--------------------------------------------------<br/>--------------------------------------------------108--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">tee [-a] file</span>
<span class="term_say">选项与参数：
-a  ：以累加 （append） 的方式，将数据加入 file 当中！</span>

[dmtsai@study ~]$ <span class="term_command">last | tee last.list | cut -d " " -f1</span>
<span class="term_say"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中；</span>

[dmtsai@study ~]$ <span class="term_command">ls -l /home | tee ~/homefile | more</span>
<span class="term_say"># 这个范例则是将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</span>

[dmtsai@study ~]$ <span class="term_command">ls -l / | tee -a ~/homefile | more</span>
<span class="term_say"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 108--------------------------------------------------<br/>--------------------------------------------------109--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">tr [-ds] SET1 ...</span>
<span class="term_say">选项与参数：
-d  ：删除讯息当中的 SET1 这个字串；
-s  ：取代掉重复的字符！</span>

<span class="term_hd">范例一：将 last 输出的讯息中，所有的小写变成大写字符：</span>
[dmtsai@study ~]$ <span class="term_command">last | tr '[a-z]' '[A-Z]'</span>
<span class="term_say"># 事实上，没有加上单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”</span>

<span class="term_hd">范例二：将 /etc/passwd 输出的讯息中，将冒号 （:） 删除</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd | tr -d ':'</span>

<span class="term_hd">范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span>
[dmtsai@study ~]$ <span class="term_command">cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd</span>
[dmtsai@study ~]$ <span class="term_command">file /etc/passwd ~/passwd</span>
/etc/passwd:         ASCII text
/home/dmtsai/passwd: ASCII text, with CRLF line terminators  <span class="term_note">&lt;==就是 DOS 断行</span>
[dmtsai@study ~]$ <span class="term_command">cat ~/passwd | tr -d '\r' &gt; ~/passwd.linux</span>
<span class="term_say"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span>
[dmtsai@study ~]$ <span class="term_command">ll /etc/passwd ~/passwd*</span>
-rw-r--r--. 1 root   root   <span class="term_command">2092</span> Jun 17 00:20 /etc/passwd
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command">2133</span> Jul  9 22:13 /home/dmtsai/passwd
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_command">2092</span> Jul  9 22:13 /home/dmtsai/passwd.linux
<span class="term_say"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 109--------------------------------------------------<br/>--------------------------------------------------110--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">col [-xb]</span>
<span class="term_say">选项与参数：
-x  ：将 tab 键转换成对等的空白键</span>

<span class="term_hd">范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</span>
[dmtsai@study ~]$ <span class="term_command">cat -A /etc/man_db.conf</span>  <span class="term_note">&lt;==此时会看到很多 ^I 的符号，那就是 tab</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/man_db.conf | col -x | cat -A | more</span>
<span class="term_say"># 嘿嘿！如此一来， [tab] 按键会被取代成为空白键，输出就美观多了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 110--------------------------------------------------<br/>--------------------------------------------------111--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">join [-ti12] file1 file2</span>
<span class="term_say">选项与参数：
-t  ：join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，
      如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个！
-i  ：忽略大小写的差异；
-1  ：这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思；
-2  ：代表“第二个文件要用那个字段来分析”的意思。</span>

<span class="term_hd">范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span>
[root@study ~]# <span class="term_command">head -n 3 /etc/passwd /etc/shadow</span>
==&gt; /etc/passwd &lt;==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

==&gt; /etc/shadow &lt;==
root:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::
bin:*:16372:0:99999:7:::
daemon:*:16372:0:99999:7:::
<span class="term_say"># 由输出的数据可以发现这两个文件的最左边字段都是相同帐号！且以 : 分隔</span>

[root@study ~]# <span class="term_command">join -t ':' /etc/passwd /etc/shadow | head -n 3</span>
<span class="term_command">root</span>:x:0:0:root:/root:/bin/bash:<span class="term_command">$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::</span>
<span class="term_command">bin</span>:x:1:1:bin:/bin:/sbin/nologin:<span class="term_command">*:16372:0:99999:7:::</span>
<span class="term_command">daemon</span>:x:2:2:daemon:/sbin:/sbin/nologin:<span class="term_command">*:16372:0:99999:7:::</span>
<span class="term_say"># 通过上面这个动作，我们可以将两个文件第一字段相同者整合成一列！
# 第二个文件的相同字段并不会显示（因为已经在最左边的字段出现了啊！）</span>

<span class="term_hd">范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 
        /etc/group 当中的第三个字段，请问如何将两个文件整合？</span>
[root@study ~]# <span class="term_command">head -n 3 /etc/passwd /etc/group</span>
==&gt; /etc/passwd &lt;==
root:x:0:<span class="term_command">0</span>:root:/root:/bin/bash
bin:x:1:<span class="term_command">1</span>:bin:/bin:/sbin/nologin
daemon:x:2:<span class="term_command">2</span>:daemon:/sbin:/sbin/nologin

==&gt; /etc/group &lt;==
root:x:<span class="term_command">0</span>:
bin:x:<span class="term_command">1</span>:
daemon:x:<span class="term_command">2</span>:
<span class="term_say"># 从上面可以看到，确实有相同的部分喔！赶紧来整合一下！</span>

[root@study ~]# <span class="term_command">join -t ':' -1 4 /etc/passwd -2 3 /etc/group | head -n 3</span>
<span class="term_command">0</span>:root:x:0:root:/root:/bin/bash:<span class="term_command">root:x:</span>
<span class="term_command">1</span>:bin:x:1:bin:/bin:/sbin/nologin:<span class="term_command">bin:x:</span>
<span class="term_command">2</span>:daemon:x:2:daemon:/sbin:/sbin/nologin:<span class="term_command">daemon:x:</span>
<span class="term_say"># 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。
# 请读者们配合上述显示两个文件的实际内容来比对！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 111--------------------------------------------------<br/>--------------------------------------------------112--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">paste [-d] file1 file2</span>
<span class="term_say">选项与参数：
-d  ：后面可以接分隔字符。默认是以 [tab] 来分隔的！
-   ：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</span>

<span class="term_hd">范例一：用 root 身份，将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span>
[root@study ~]# <span class="term_command">paste /etc/passwd /etc/shadow</span>
root:x:0:0:root:/root:/bin/bash root:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin        bin:*:16372:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:16372:0:99999:7:::
<span class="term_say"># 注意喔！同一行中间是以 [tab] 按键隔开的！</span>

<span class="term_hd">范例二：先将 /etc/group 读出（用 cat），然后与范例一贴上一起！且仅取出前三行</span>
[root@study ~]# <span class="term_command">cat /etc/group|paste /etc/passwd /etc/shadow -|head -n 3</span>
<span class="term_say"># 这个例子的重点在那个 - 的使用！那玩意儿常常代表 stdin 喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 112--------------------------------------------------<br/>--------------------------------------------------113--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">expand [-t] file</span>
<span class="term_say">选项与参数：
-t  ：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。
      我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</span>

<span class="term_hd">范例一：将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出；仅取前三行；</span>
[dmtsai@study ~]$ <span class="term_command">grep '^MANPATH' /etc/man_db.conf | head -n 3</span>
MANPATH_MAP     /bin                    /usr/share/man
MANPATH_MAP     /usr/bin                /usr/share/man
MANPATH_MAP     /sbin                   /usr/share/man
<span class="term_say"># 行首的代表标志为 ^ ，这个我们留待下节介绍！先有概念即可！</span>

<span class="term_hd">范例二：承上，如果我想要将所有的符号都列出来？（用 cat）</span>
[dmtsai@study ~]$ <span class="term_command">grep '^MANPATH' /etc/man_db.conf | head -n 3 |cat -A</span>
MANPATH_MAP^I/bin^I^I^I/usr/share/man$
MANPATH_MAP^I/usr/bin^I^I/usr/share/man$
MANPATH_MAP^I/sbin^I^I^I/usr/share/man$
<span class="term_say"># 发现差别了吗？没错～ [tab] 按键可以被 cat -A 显示成为 ^I </span>

<span class="term_hd">范例三：承上，我将 [tab] 按键设置成 6 个字符的话？</span>
[dmtsai@study ~]$ <span class="term_command">grep '^MANPATH' /etc/man_db.conf | head -n 3 | expand -t 6 - | cat -A</span>
MANPATH_MAP /bin              /usr/share/man$
MANPATH_MAP /usr/bin          /usr/share/man$
MANPATH_MAP /sbin             /usr/share/man$
<span class="term_say">123456123456123456123456123456123456123456123456...
# 仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，
# MAN... 到 /usr 之间会隔 12 （两个 [tab]） 个字符喔！如果 tab 改成 9 的话，
# 情况就又不同了！这里也不好理解～您可以多设置几个数字来查阅就晓得！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 113--------------------------------------------------<br/>--------------------------------------------------114--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">split [-bl] file PREFIX</span>
<span class="term_say">选项与参数：
-b  ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；
-l  ：以行数来进行分区。
PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。</span>

<span class="term_hd">范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</span>
[dmtsai@study ~]$ <span class="term_command">cd /tmp; split -b 300k /etc/services services</span>
[dmtsai@study tmp]$ <span class="term_command">ll -k services*</span>
-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul  9 22:52 services<span class="term_command">aa</span>
-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul  9 22:52 services<span class="term_command">ab</span>
-rw-rw-r--. 1 dmtsai dmtsai  55893 Jul  9 22:52 services<span class="term_command">ac</span>
<span class="term_say"># 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以
# xxxaa, xxxab, xxxac 等方式来创建小文件的！</span>

<span class="term_hd">范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback</span>
[dmtsai@study tmp]$ <span class="term_command">cat services* &gt;&gt; servicesback</span>
<span class="term_say"># 很简单吧？就用数据流重导向就好啦！简单！</span>

<span class="term_hd">范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件</span>
[dmtsai@study tmp]$ <span class="term_command">ls -al / | split -l 10 - lsroot</span>
[dmtsai@study tmp]$ <span class="term_command">wc -l lsroot*</span>
  10 lsrootaa
  10 lsrootab
   4 lsrootac
  24 total
<span class="term_say"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，
# 有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 114--------------------------------------------------<br/>--------------------------------------------------115--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">xargs [-0epn] command</span>
<span class="term_say">选项与参数：
-0  ：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数
      可以将他还原成一般字符。这个参数可以用于特殊状态喔！
-e  ：这个是 EOF （end of file） 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，
      就会停止继续工作！
-p  ：在执行每个指令的 argument 时，都会询问使用者的意思；
-n  ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。
当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</span>

<span class="term_hd">范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来</span>
[dmtsai@study ~]$ <span class="term_command">id root</span>
uid=0（root） gid=0（root） groups=0（root）   <span class="term_note"># 这个 id 指令可以查询使用者的 UID/GID 等信息</span>

[dmtsai@study ~]$ <span class="term_command">id $（cut -d ':' -f 1 /etc/passwd | head -n 3）</span>
<span class="term_say"># 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！
# 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</span>

[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | id</span>
uid=1000（dmtsai） gid=1000（dmtsai） groups=1000（dmtsai）,10（wheel）   <span class="term_note"># 我不是要查自己啊！</span>
<span class="term_say"># 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</span>

[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs id</span>
<span class="term_say"># 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但 id 就接受 1 个啊最多！</span>

[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -n 1 id</span>
uid=0（root） gid=0（root） groups=0（root）
uid=1（bin） gid=1（bin） groups=1（bin）
uid=2（daemon） gid=2（daemon） groups=2（daemon）
<span class="term_say"># 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span>

<span class="term_hd">范例二：同上，但是每次执行 id 时，都要询问使用者是否动作？</span>
[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 id</span>
id root ?...<span class="term_command">y</span>
uid=0（root） gid=0（root） groups=0（root）
id bin ?...<span class="term_command">y</span>
<span class="term_say">.....（下面省略）.....
# 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</span>

<span class="term_hd">范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</span>
[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | xargs -e'sync' -n 1 id</span>
<span class="term_say"># 仔细与上面的案例做比较。也同时注意，那个 -e'sync' 是连在一起的，中间没有空白键。
# 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e'sync' 后，则分析到 sync 这个字串时，
# 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 115--------------------------------------------------<br/>--------------------------------------------------116--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</span>
[dmtsai@study ~]$ <span class="term_command">find /usr/sbin -perm /7000 | xargs ls -l</span>
-rwx--s--x. 1 root lock      11208 Jun 10  2014 /usr/sbin/lockdev
-rwsr-xr-x. 1 root root     113400 Mar  6 12:17 /usr/sbin/mount.nfs
-rwxr-sr-x. 1 root root      11208 Mar  6 11:05 /usr/sbin/netreport
<span class="term_say">.....（下面省略）.....
# 聪明的读者应该会想到使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！
# 都 OK！能解决问题的方法，就是好方法！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 116--------------------------------------------------<br/>--------------------------------------------------117--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">grep [-A] [-B] [--color=auto] '搜寻字串' filename</span>
<span class="term_say">选项与参数：
-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；
--color=auto 可将正确的那个撷取数据列出颜色</span>

<span class="term_hd">范例一：用 dmesg 列出核心讯息，再以 grep 找出内含 qxl 那行</span>
[dmtsai@study ~]$ <span class="term_command">dmesg | grep 'qxl'</span>
[    0.522749] [drm] qxl: 16M of VRAM memory size
[    0.522750] [drm] qxl: 63M of IO pages memory ready （VRAM domain）
[    0.522750] [drm] qxl: 32M of Surface memory size
[    0.650714] fbcon: qxldrmfb （fb0） is primary device
[    0.668487] qxl 0000:00:02.0: fb0: qxldrmfb frame buffer device
<span class="term_say"># dmesg 可列出核心产生的讯息！包括硬件侦测的流程也会显示出来。
# 鸟哥使用的显卡是 QXL 这个虚拟卡，通过 grep 来 qxl 的相关信息，可发现如上信息。</span>

<span class="term_hd">范例二：承上题，要将捉到的关键字显色，且加上行号来表示：</span>
[dmtsai@study ~]$ <span class="term_command">dmesg | grep -n --color=auto 'qxl'</span>
515:[    0.522749] [drm] <span class="term_command">qxl</span>: 16M of VRAM memory size
516:[    0.522750] [drm] <span class="term_command">qxl</span>: 63M of IO pages memory ready （VRAM domain）
517:[    0.522750] [drm] <span class="term_command">qxl</span>: 32M of Surface memory size
529:[    0.650714] fbcon: <span class="term_command">qxl</span>drmfb （fb0） is primary device
539:[    0.668487] <span class="term_command">qxl</span> 0000:00:02.0: fb0: <span class="term_command">qxl</span>drmfb frame buffer device
<span class="term_say"># 除了 qxl 会有特殊颜色来表示之外，最前面还有行号喔！其实颜色显示已经是默认在 alias 当中了！</span>

<span class="term_hd">范例三：承上题，在关键字所在行的前两行与后三行也一起捉出来显示</span>
[dmtsai@study ~]$ <span class="term_command">dmesg | grep -n -A3 -B2 --color=auto 'qxl'</span>
<span class="term_say"># 你会发现关键字之前与之后的数行也被显示出来！这样可以让你将关键字前后数据捉出来进行分析啦！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 117--------------------------------------------------<br/>--------------------------------------------------118--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除！</span>
[dmtsai@study ~]$ <span class="term_command">nl /etc/passwd | sed '2,5d'</span>
     1  root:x:0:0:root:/root:/bin/bash
     6  sync:x:5:0:sync:/sbin:/bin/sync
     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
<span class="term_say">.....（后面省略）.....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 118--------------------------------------------------<br/>--------------------------------------------------119--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：承上题，在第二行后（亦即是加在第三行）加上“drink tea?”字样！</span>
[dmtsai@study ~]$ <span class="term_command">nl /etc/passwd | sed '2a drink tea'</span>
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
<span class="term_say">.....（后面省略）.....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 119--------------------------------------------------<br/>--------------------------------------------------120--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：在第二行后面加入两行字，例如“Drink tea or .....”与“drink beer?”</span>
[dmtsai@study ~]$ <span class="term_command">nl /etc/passwd | sed '2a Drink tea or ......\</span>
&gt; <span class="term_command">drink beer ?'</span>
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
Drink tea or ......
drink beer ?
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
<span class="term_say">.....（后面省略）.....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 120--------------------------------------------------<br/>--------------------------------------------------121--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：我想将第2-5行的内容取代成为“No 2-5 number”呢？</span>
[dmtsai@study ~]$ <span class="term_command">nl /etc/passwd | sed '2,5c No 2-5 number'</span>
     1  root:x:0:0:root:/root:/bin/bash
No 2-5 number
     6  sync:x:5:0:sync:/sbin:/bin/sync
<span class="term_say">.....（后面省略）.....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 121--------------------------------------------------<br/>--------------------------------------------------122--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例五：仅列出 /etc/passwd 文件内的第 5-7 行</span>
[dmtsai@study ~]$ <span class="term_command">nl /etc/passwd | sed -n '5,7p'</span>
     5  lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
     6  sync:x:5:0:sync:/sbin:/bin/sync
     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 122--------------------------------------------------<br/>--------------------------------------------------123--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">步骤一：先观察原始讯息，利用 /sbin/ifconfig  查询 IP 为何？</span>
[dmtsai@study ~]$ <span class="term_command">/sbin/ifconfig eth0</span>
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        <span class="term_command">inet 192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255</span>
        inet6 fe80::5054:ff:fedf:e174  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 52:54:00:df:e1:74  txqueuelen 1000  （Ethernet）
<span class="term_say">.....（以下省略）.....
# 因为我们还没有讲到 IP ，这里你先有个概念即可啊！我们的重点在第二行，
# 也就是 192.168.1.100 那一行而已！先利用关键字捉出那一行！</span>

<span class="term_hd">步骤二：利用关键字配合 grep 撷取出关键的一行数据</span>
[dmtsai@study ~]$ <span class="term_command">/sbin/ifconfig eth0 | grep 'inet '</span>
        <span class="term_command">inet </span>192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255
<span class="term_say"># 当场仅剩下一行！要注意， CentOS 7 与 CentOS 6 以前的 ifconfig 指令输出结果不太相同，
# 鸟哥这个范例主要是针对 CentOS 7 以后的喔！接下来，我们要将开始到 addr: 通通删除，
# 就是像下面这样：
# <span class="calibre55">inet </span>192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255
# 上面的删除关键在于“ ^.*inet  ”啦！正则表达式出现！ ^_^</span>

<span class="term_hd">步骤三：将 IP 前面的部分予以删除</span>
[dmtsai@study ~]$ <span class="term_command">/sbin/ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g'</span>
192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255
<span class="term_say"># 仔细与上个步骤比较一下，前面的部分不见了！接下来则是删除后续的部分，亦即：
192.168.1.100<span class="calibre55">  netmask 255.255.255.0  broadcast 192.168.1.255</span>
# 此时所需的正则表达式为：“ ' *netmask.*$ ”就是啦！</span>

<span class="term_hd">步骤四：将 IP 后面的部分予以删除</span>
[dmtsai@study ~]$ <span class="term_command">/sbin/ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g' \</span>
&gt; <span class="term_command">  | sed 's/ *netmask.*$//g'</span>
192.168.1.100
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 123--------------------------------------------------<br/>--------------------------------------------------124--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例六：利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</span>
[dmtsai@study ~]$ <span class="term_command">sed -i 's/\.$/\!/g' regular_express.txt</span>
<span class="term_say"># 上头的 -i 选项可以让你的 sed 直接去修改后面接的文件内容而不是由屏幕输出喔！
# 这个范例是用在取代！请您自行 cat 该文件去查阅结果啰！</span>

<span class="term_hd">范例七：利用 sed 直接在 regular_express.txt 最后一行加入“# This is a test”</span>
[dmtsai@study ~]$ <span class="term_command">sed -i '$a # This is a test' regular_express.txt</span>
<span class="term_say"># 由于 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增啰！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 124--------------------------------------------------<br/>--------------------------------------------------125--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：将刚刚上头数据的文件 （printf.txt） 内容仅列出姓名与成绩：（用 [tab] 分隔）</span>
[dmtsai@study ~]$ <span class="term_command">printf '%s\t %s\t %s\t %s\t %s\t \n' $（cat printf.txt）</span>
Name     Chinese         English         Math    Average
DmTsai   80      60      92      77.33
VBird    75      55      80      70.00
Ken      60      90      70      73.33
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 125--------------------------------------------------<br/>--------------------------------------------------126--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：将上述数据关于第二行以后，分别以字串、整数、小数点来显示：</span>
[dmtsai@study ~]$ <span class="term_command">printf '%10s %5i %5i %5i %8.2f \n' $（cat printf.txt | grep -v Name）</span>
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 126--------------------------------------------------<br/>--------------------------------------------------127--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：列出 16 进位数值 45 代表的字符为何？</span>
[dmtsai@study ~]$ <span class="term_command">printf '\x45\n'</span>
E
<span class="term_say"># 这东西也很好玩～他可以将数值转换成为字符，如果你会写 script 的话，
# 可以自行测试一下，由 20~80 之间的数值代表的字符是啥喔！ ^_^</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 127--------------------------------------------------<br/>--------------------------------------------------128--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">diff [-bBi] from-file to-file</span>
<span class="term_say">选项与参数：
from-file ：一个文件名，作为原始比对文件的文件名；
to-file   ：一个文件名，作为目的比对文件的文件名；
注意，from-file 或 to-file 可以 - 取代，那个 - 代表“Standard input”之意。

-b  ：忽略一行当中，仅有多个空白的差异（例如 "about me" 与 "about     me" 视为相同
-B  ：忽略空白行的差异。
-i  ：忽略大小写的不同。</span>

<span class="term_hd">范例一：比对 passwd.old 与 passwd.new 的差异：</span>
[dmtsai@study testpw]$ <span class="term_command">diff passwd.old passwd.new</span>
4d3    <span class="term_note">&lt;==左边第四行被删除 （d） 掉了，基准是右边的第三行</span>
&lt; adm:x:3:4:adm:/var/adm:/sbin/nologin  <span class="term_note">&lt;==这边列出左边（&lt;）文件被删除的那一行内容</span>
6c5    <span class="term_note">&lt;==左边文件的第六行被取代 （c） 成右边文件的第五行</span>
&lt; sync:x:5:0:sync:/sbin:/bin/sync  <span class="term_note">&lt;==左边（&lt;）文件第六行内容</span>
---
&gt; no six line                      <span class="term_note">&lt;==右边（&gt;）文件第五行内容</span>
<span class="term_say"># 很聪明吧！用 diff 就把我们刚刚的处理给比对完毕了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 128--------------------------------------------------<br/>--------------------------------------------------129--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">cmp [-l] file1 file2</span>
<span class="term_say">选项与参数：
-l  ：将所有的不同点的字节处都列出来。因为 cmp 默认仅会输出第一个发现的不同点。</span>

<span class="term_hd">范例一：用 cmp 比较一下 passwd.old 及 passwd.new</span>
[dmtsai@study testpw]$ <span class="term_command">cmp passwd.old passwd.new</span>
passwd.old passwd.new differ: char 106, line 4
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 129--------------------------------------------------<br/>--------------------------------------------------130--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：以 /tmp/testpw 内的 passwd.old 与 passwd.new  制作补丁文件</span>
[dmtsai@study testpw]$ <span class="term_command">diff -Naur passwd.old passwd.new &gt; passwd.patch</span>
[dmtsai@study testpw]$ <span class="term_command">cat passwd.patch</span>
--- passwd.old  2015-07-14 22:37:43.322535054 +0800  <span class="term_note">&lt;==新旧文件的信息</span>
+++ passwd.new  2015-07-14 22:38:03.010535054 +0800
@@ -1,9 +1,8 @@  <span class="term_note">&lt;==新旧文件要修改数据的界定范围，旧文件在 1-9 行，新文件在 1-8 行</span>
 root:x:0:0:root:/root:/bin/bash
 bin:x:1:1:bin:/bin:/sbin/nologin
 daemon:x:2:2:daemon:/sbin:/sbin/nologin
-adm:x:3:4:adm:/var/adm:/sbin/nologin     <span class="term_note">&lt;==左侧文件删除</span>
 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
-sync:x:5:0:sync:/sbin:/bin/sync          <span class="term_note">&lt;==左侧文件删除</span>
+no six line                              <span class="term_note">&lt;==右侧新文件加入</span>
 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
 halt:x:7:0:halt:/sbin:/sbin/halt
 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 130--------------------------------------------------<br/>--------------------------------------------------131--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd"># 因为 CentOS 7 默认没有安装 patch 这个软件，因此得要依据之前介绍的方式来安装一下软件！
# 请记得拿出原本光盘并放入光驱当中，这时才能够使用下面的方式来安装软件！</span>
[dmtsai@study ~]$ <span class="term_command">su -</span>
[root@study ~]# <span class="term_command">mount /dev/sr0 /mnt</span>
[root@study ~]# <span class="term_command">rpm -ivh /mnt/Packages/patch-2.*</span>
[root@study ~]# <span class="term_command">umount /mnt</span>
[root@study ~]# <span class="term_command">exit</span>
<span class="term_say"># 通过上述的方式可以安装好所需要的软件，且无须上网。接下来让我们开始操作 patch 啰！</span>

[dmtsai@study ~]$ <span class="term_command">patch -pN &lt; patch_file   </span> <span class="term_note">&lt;==更新</span>
[dmtsai@study ~]$ <span class="term_command">patch -R -pN &lt; patch_file</span> <span class="term_note">&lt;==还原</span>
<span class="term_say">选项与参数：
-p  ：后面可以接“取消几层目录”的意思。
-R  ：代表还原，将新的文件还原成原来旧的版本。</span>

<span class="term_hd">范例二：将刚刚制作出来的 patch file 用来更新旧版数据</span>
[dmtsai@study testpw]$ <span class="term_command">patch -p0 &lt; passwd.patch</span>
patching file passwd.old
[dmtsai@study testpw]$ <span class="term_command">ll passwd*</span>
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_command">2035</span> Jul 14 22:38 passwd.new
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command">2035</span> Jul 14 23:30 passwd.old  <span class="term_note">&lt;==文件一模一样！</span>

<span class="term_hd">范例三：恢复旧文件的内容</span>
[dmtsai@study testpw]$ <span class="term_command">patch -R -p0 &lt; passwd.patch</span>
[dmtsai@study testpw]$ <span class="term_command">ll passwd*</span>
-rw-rw-r--. 1 dmtsai dmtsai 2035 Jul 14 22:38 passwd.new
-rw-r--r--. 1 dmtsai dmtsai <span class="term_command">2092</span> Jul 14 23:31 passwd.old
<span class="term_say"># 文件就这样恢复成为旧版本啰</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 131--------------------------------------------------<br/>--------------------------------------------------132--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[dmtsai@study ~]$ <span class="term_command">sh [-nvx] scripts.sh</span>
<span class="term_say">选项与参数：
-n  ：不要执行 script，仅查询语法的问题；
-v  ：再执行 sccript 前，先将 scripts 的内容输出到屏幕上；
-x  ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！</span>

<span class="term_hd">范例一：测试 dir_perm.sh 有无语法的问题？</span>
[dmtsai@study ~]$ <span class="term_command">sh -n dir_perm.sh </span>
<span class="term_say"># 若语法没有问题，则不会显示任何信息！</span>

<span class="term_hd">范例二：将 show_animal.sh 的执行过程全部列出来～</span>
[dmtsai@study ~]$ <span class="term_command">sh -x show_animal.sh </span>
<span class="term_say">+ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/root/bin
+ export PATH
+ for animal in dog cat elephant
+ echo 'There are dogs.... '</span>
There are dogs....
<span class="term_say">+ for animal in dog cat elephant
+ echo 'There are cats.... '</span>
There are cats....
<span class="term_say">+ for animal in dog cat elephant
+ echo 'There are elephants.... '</span>
There are elephants....
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 132--------------------------------------------------<br/>--------------------------------------------------133--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\</span>
&gt; <span class="term_command"> [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 使用者帐号名</span>
<span class="term_say">选项与参数：
-u  ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个帐号；
-g  ：后面接的那个群组名称就是我们上面提到的 initial group 啦～
      该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。
-G  ：后面接的群组名称则是这个帐号还可以加入的群组。
      这个选项与参数会修改 /etc/group 内的相关数据喔！
-M  ：强制！不要创建使用者主文件夹！（系统帐号默认值）
-m  ：强制！要创建使用者主文件夹！（一般帐号默认值）
-c  ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设置的啦～
-d  ：指定某个目录成为主文件夹，而不要使用默认值。务必使用绝对路径！
-r  ：创建一个系统的帐号，这个帐号的 UID 会有限制 （参考 /etc/login.defs）
-s  ：后面接一个 shell ，若没有指定则默认是 /bin/bash 的啦～
-e  ：后面接一个日期，格式为“YYYY-MM-DD”此项目可写入 shadow 第八字段，
      亦即帐号失效日的设置项目啰；
-f  ：后面接 shadow 的第七字段项目，指定密码是否会失效。0为立刻失效，
      -1 为永远不失效（密码只会过期而强制于登陆时重新设置而已。）</span>

<span class="term_hd">范例一：完全参考默认值创建一个使用者，名称为 vbird1</span>
[root@study ~]# <span class="term_command">useradd vbird1</span>
[root@study ~]# <span class="term_command">ll -d /home/vbird1</span>
drwx------. 3 vbird1 vbird1 74 Jul 20 21:50 /home/vbird1
<span class="term_say"># 默认会创建使用者主文件夹，且权限为 700 ！这是重点！</span>

[root@study ~]# <span class="term_command">grep vbird1 /etc/passwd /etc/shadow /etc/group</span>
/etc/passwd:vbird1:x:1003:1004::/home/vbird1:/bin/bash
/etc/shadow:vbird1:!!:16636:0:99999:7:::
/etc/group:vbird1:x:1004:     <span class="term_note">&lt;==默认会创建一个与帐号一模一样的群组名</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 133--------------------------------------------------<br/>--------------------------------------------------134--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：假设我已知道我的系统当中有个群组名称为 users ，且 UID 1500 并不存在，
        请用 users 为初始群组，以及 uid 为 1500 来创建一个名为 vbird2 的帐号</span>
[root@study ~]# <span class="term_command">useradd -u 1500 -g users vbird2</span>
[root@study ~]# <span class="term_command">ll -d /home/vbird2</span>
drwx------. 3 vbird2 <span class="term_command">users</span> 74 Jul 20 21:52 /home/vbird2

[root@study ~]# <span class="term_command">grep vbird2 /etc/passwd /etc/shadow /etc/group</span>
/etc/passwd:vbird2:x:<span class="term_command">1500:100</span>::/home/vbird2:/bin/bash
/etc/shadow:vbird2:!!:16636:0:99999:7:::
<span class="term_say"># 看一下，UID 与 initial group 确实改变成我们需要的了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 134--------------------------------------------------<br/>--------------------------------------------------135--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：创建一个系统帐号，名称为 vbird3</span>
[root@study ~]# <span class="term_command">useradd -r vbird3</span>
[root@study ~]# <span class="term_command">ll -d /home/vbird3</span>
ls: cannot access /home/vbird3: No such file or directorya   <span class="term_note">&lt;==不会主动创建主文件夹</span>

[root@study ~]# <span class="term_command">grep vbird3 /etc/passwd /etc/shadow /etc/group</span>
/etc/passwd:vbird3:x:<span class="term_command">699:699</span>::/home/vbird3:/bin/bash
/etc/shadow:vbird3:!!:16636::::::
/etc/group:vbird3:x:<span class="term_command">699</span>:
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 135--------------------------------------------------<br/>--------------------------------------------------136--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">passwd [--stdin] [帐号名称]</span>  <span class="term_note">&lt;==所有人均可使用来改自己的密码</span>
[root@study ~]# <span class="term_command">passwd [-l] [-u] [--stdin] [-S] \</span>
&gt;  <span class="term_command">[-n 日数] [-x 日数] [-w 日数] [-i 日期] 帐号</span> <span class="term_note">&lt;==root 功能</span>
<span class="term_say">选项与参数：
--stdin ：可以通过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！
-l  ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效；
-u  ：与 -l 相对，是 Unlock 的意思！
-S  ：列出密码相关参数，亦即 shadow 文件内的大部分信息。
-n  ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数
-x  ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码
-w  ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数
-i  ：后面接“日期”，shadow 的第 7 字段，密码失效日期</span>

<span class="term_hd">范例一：请 root 给予 vbird2 密码</span>
[root@study ~]# <span class="term_command">passwd vbird2</span>
Changing password for user vbird2.
New UNIX password: <span class="term_note">&lt;==这里直接输入新的密码，屏幕不会有任何反应</span>
BAD PASSWORD: The password is shorter than 8 characters <span class="term_note">&lt;==密码太简单或过短的错误！</span>
Retype new UNIX password:  <span class="term_note">&lt;==再输入一次同样的密码</span>
passwd: all authentication tokens updated <span class="term_command">successfully</span>.  <span class="term_note">&lt;==竟然还是成功修改了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 136--------------------------------------------------<br/>--------------------------------------------------137--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：用 vbird2 登陆后，修改 vbird2 自己的密码</span>
[vbird2@study ~]$ <span class="term_command">passwd</span>   <span class="term_note">&lt;==后面没有加帐号，就是改自己的密码！</span>
Changing password for user vbird2.
Changing password for vbird2
（current） UNIX password: <span class="term_note">&lt;==这里输入“原有的旧密码”</span>
New UNIX password: <span class="term_note">&lt;==这里输入新密码</span>
BAD PASSWORD: The password is shorter than 8 characters <span class="term_note">&lt;==密码太短！不可以设置！重新想</span>
New password:  <span class="term_note">&lt;==这里输入新想的密码</span>
BAD PASSWORD: The password fails the dictionary check - it is based on a dictionary word
<span class="term_note"># 同样的，密码设置在字典里面找的到该字串，所以也是不建议！无法通过，再想新的！</span>
New UNIX password: <span class="term_note">&lt;==这里再想个新的密码来输入吧</span>
Retype new UNIX password: <span class="term_note">&lt;==通过密码验证！所以重复这个密码的输入</span>
passwd: all authentication tokens updated <u class="calibre34">successfully</u>. <span class="term_note">&lt;==有无成功看关键字</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 137--------------------------------------------------<br/>--------------------------------------------------138--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：使用 standard input 创建用户的密码</span>
[root@study ~]# <span class="term_command">echo "abc543CC" | passwd --stdin vbird2</span>
Changing password for user vbird2.
passwd: all authentication tokens updated successfully.
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 138--------------------------------------------------<br/>--------------------------------------------------139--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：管理 vbird2 的密码使具有 60 天变更、密码过期 10 天后帐号失效的设置</span>
[root@study ~]# <span class="term_command">passwd -S vbird2</span>
vbird2 PS 2015-07-20 0 99999 7 -1 （Password set, SHA512 crypt.）
<span class="term_say"># 上面说明密码创建时间 （2015-07-20）、0 最小天数、99999 变更天数、7 警告日数与密码不会失效 （-1）</span>

[root@study ~]# <span class="term_command">passwd -x 60 -i 10 vbird2</span>
[root@study ~]# <span class="term_command">passwd -S vbird2</span>
vbird2 PS 2015-07-20 0 <span class="term_command">60</span> 7 <span class="term_command">10</span> （Password set, SHA512 crypt.）
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 139--------------------------------------------------<br/>--------------------------------------------------140--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例五：让 vbird2 的帐号失效，观察完毕后再让她失效</span>
[root@study ~]# <span class="term_command">passwd -l vbird2</span>
[root@study ~]# <span class="term_command">passwd -S vbird2</span>
vbird2 <span class="term_command">LK</span> 2015-07-20 0 60 7 10 （<span class="term_command">Password locked</span>.）
<span class="term_say"># 嘿嘿！状态变成“ LK, Lock ”了啦！无法登陆喔！</span>
[root@study ~]# <span class="term_command">grep vbird2 /etc/shadow</span>
vbird2:<span class="term_command">!!</span>$6$iWWO6T46$uYStdkB7QjcUpJaCLB.OOp...:16636:0:60:7:10::
<span class="term_say"># 其实只是在这里加上 !! 而已！</span>

[root@study ~]# <span class="term_command">passwd -u vbird2</span>
[root@study ~]# <span class="term_command">grep vbird2 /etc/shadow</span>
vbird2:$6$iWWO6T46$uYStdkB7QjcUpJaCLB.OOp...:16636:0:60:7:10::
<span class="term_say"># 密码字段恢复正常！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 140--------------------------------------------------<br/>--------------------------------------------------141--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">chage [-ldEImMW] 帐号名</span>
<span class="term_say">选项与参数：
-l ：列出该帐号的详细密码参数；
-d ：后面接日期，修改 shadow 第三字段（最近一次更改密码的日期），格式 YYYY-MM-DD
-E ：后面接日期，修改 shadow 第八字段（帐号失效日），格式 YYYY-MM-DD
-I ：后面接天数，修改 shadow 第七字段（密码失效日期）
-m ：后面接天数，修改 shadow 第四字段（密码最短保留天数）
-M ：后面接天数，修改 shadow 第五字段（密码多久需要进行变更）
-W ：后面接天数，修改 shadow 第六字段（密码过期前警告日期）</span>

<span class="term_hd">范例一：列出 vbird2 的详细密码参数</span>
[root@study ~]# <span class="term_command">chage -l vbird2</span>
Last password change                                    : Jul 20, 2015
Password expires                                        : Sep 18, 2015
Password inactive                                       : Sep 28, 2015
Account expires                                         : never
Minimum number of days between password change          : 0
Maximum number of days between password change          : 60
Number of days of warning before password expires       : 7
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 141--------------------------------------------------<br/>--------------------------------------------------142--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：创建一个名为 agetest 的帐号，该帐号第一次登陆后使用默认密码，但必须要更改过密码后，
        使用新密码才能够登陆系统使用 bash 环境</span>
[root@study ~]# <span class="term_command">useradd agetest</span>
[root@study ~]# <span class="term_command">echo "agetest" | passwd --stdin agetest</span>
[root@study ~]# <span class="term_command">chage -d 0 agetest</span>
[root@study ~]# <span class="term_command">chage -l agetest | head -n 3</span>
Last password change                : password must be changed
Password expires                    : password must be changed
Password inactive                   : password must be changed
<span class="term_say"># 此时此帐号的密码创建时间会被改为 1970/1/1 ，所以会有问题！</span>

<span class="term_hd">范例三：尝试以 agetest 登陆的情况</span>
You are required to change your password immediately （root enforced）
WARNING: Your password has expired.
You must change your password now and login again!
Changing password for user agetest.
Changing password for agetest
（current） UNIX password:  <span class="term_note">&lt;==这个帐号被强制要求必须要改密码！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 142--------------------------------------------------<br/>--------------------------------------------------143--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：修改使用者 vbird2 的说明栏，加上“VBird's test”的说明。</span>
[root@study ~]# <span class="term_command">usermod -c "VBird's test" vbird2</span>
[root@study ~]# <span class="term_command">grep vbird2 /etc/passwd</span>
vbird2:x:1500:100:<span class="term_command">VBird's test</span>:/home/vbird2:/bin/bash

<span class="term_hd">范例二：使用者 vbird2 这个帐号在 2015/12/31 失效。</span>
[root@study ~]# <span class="term_command">usermod -e "2015-12-31" vbird2</span>
[root@study ~]# <span class="term_command">chage -l vbird2 | grep 'Account expires'</span>
Account expires                     : Dec 31, 2015

<span class="term_hd">范例三：我们创建 vbird3 这个系统帐号时并没有给予主文件夹，请创建他的主文件夹</span>
[root@study ~]# <span class="term_command">ll -d ~vbird3</span>
ls: cannot access /home/vbird3: No such file or directory  <span class="term_note">&lt;==确认一下，确实没有主文件夹的存在！</span>
[root@study ~]# <span class="term_command">cp -a /etc/skel /home/vbird3</span>
[root@study ~]# <span class="term_command">chown -R vbird3:vbird3 /home/vbird3</span>
[root@study ~]# <span class="term_command">chmod 700 /home/vbird3</span>
[root@study ~]# <span class="term_command">ll -a ~vbird3</span>
drwx------.  3 vbird3 vbird3   74 May  4 17:51 .   <span class="term_note">&lt;==使用者主文件夹权限</span>
drwxr-xr-x. 10 root   root   4096 Jul 20 22:51 ..
-rw-r--r--.  1 vbird3 vbird3   18 Mar  6 06:06 .bash_logout
-rw-r--r--.  1 vbird3 vbird3  193 Mar  6 06:06 .bash_profile
-rw-r--r--.  1 vbird3 vbird3  231 Mar  6 06:06 .bashrc
drwxr-xr-x.  4 vbird3 vbird3   37 May  4 17:51 .mozilla
<span class="term_say"># 使用 chown -R 是为了连同主文件夹下面的使用者/群组属性都一起变更的意思；
# 使用 chmod 没有 -R ，是因为我们仅要修改目录的权限而非内部文件的权限！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 143--------------------------------------------------<br/>--------------------------------------------------144--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">userdel [-r] username</span>
<span class="term_say">选项与参数：
-r  ：连同使用者的主文件夹也一起删除</span>

<span class="term_hd">范例一：删除 vbird2 ，连同主文件夹一起删除</span>
[root@study ~]# <span class="term_command">userdel -r vbird2</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 144--------------------------------------------------<br/>--------------------------------------------------145--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">id [username]</span>

<span class="term_hd">范例一：查阅 root 自己的相关 ID 信息！</span>
[root@study ~]# <span class="term_command">id</span>
uid=0（root） gid=0（root） groups=0（root） context=unconfined_u:unconfined_r:unconfined_t:
s0-s0:c0.c1023
<span class="term_say"># 上面信息其实是同一行的数据！包括会显示 UID/GID 以及支持的所有群组！
# 至于后面那个 context=... 则是 SELinux 的内容，先不要理会他！</span>

<span class="term_hd">范例二：查阅一下 vbird1 吧～</span>
[root@study ~]# <span class="term_command">id vbird1</span>
uid=1003（vbird1） gid=1004（vbird1） groups=1004（vbird1）

[root@study ~]# <span class="term_command">id vbird100</span>
id: vbird100: No such user  <span class="term_note">&lt;== id 这个指令也可以用来判断系统上面有无某帐号！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 145--------------------------------------------------<br/>--------------------------------------------------146--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">finger [-s] username</span>
<span class="term_say">选项与参数：
-s  ：仅列出使用者的帐号、全名、终端机代号与登陆时间等等；
-m  ：列出与后面接的帐号相同者，而不是利用部分比对 （包括全名部分）</span>

<span class="term_hd">范例一：观察 vbird1 的使用者相关帐号属性</span>
[root@study ~]# <span class="term_command">finger vbird1</span>
Login: vbird1                           Name:
Directory: /home/vbird1                 Shell: /bin/bash
Never logged in.
No mail.
No Plan.
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 146--------------------------------------------------<br/>--------------------------------------------------147--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：利用 vbird1 创建自己的计划档</span>
[vbird1@study ~]$ <span class="term_command">echo "I will study Linux during this year." &gt; ~/.plan</span>
[vbird1@study ~]$ <span class="term_command">finger vbird1</span>
Login: vbird1                           Name:
Directory: /home/vbird1                 Shell: /bin/bash
Last login Mon Jul 20 23:06 （CST） on pts/0
No mail.
<span class="term_command">Plan:
I will study Linux during this year.</span>

<span class="term_hd">范例三：找出目前在系统上面登陆的使用者与登陆时间</span>
[vbird1@study ~]$ <span class="term_command">finger</span>
Login     Name       Tty      Idle  Login Time   Office     Office Phone   Host
dmtsai    dmtsai     tty2      11d  Jul  7 23:07
dmtsai    dmtsai     pts/0          Jul 20 17:59                       
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 147--------------------------------------------------<br/>--------------------------------------------------148--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">chfn [-foph] [帐号名]</span>
<span class="term_say">选项与参数：
-f  ：后面接完整的大名；
-o  ：您办公室的房间号码；
-p  ：办公室的电话号码；
-h  ：家里的电话号码！</span>

<span class="term_hd">范例一：vbird1 自己更改一下自己的相关信息！</span>
[vbird1@study ~]$ <span class="term_command">chfn</span>
Changing finger information for vbird1.
Name []: <span class="term_command">VBird Tsai test</span>         <span class="term_note">&lt;==输入你想要呈现的全名</span>
Office []: <span class="term_command">DIC in KSU</span>            <span class="term_note">&lt;==办公室号码</span>
Office Phone []: <span class="term_command">06-2727175#356</span>  <span class="term_note">&lt;==办公室电话</span>
Home Phone []: <span class="term_command">06-1234567</span>        <span class="term_note">&lt;==家里电话号码</span>

Password:  <span class="term_note">&lt;==确认身份，所以输入自己的密码</span>
Finger information changed.

[vbird1@study ~]$ <span class="term_command">grep vbird1 /etc/passwd</span>
vbird1:x:1003:1004:<span class="term_command">VBird Tsai test,DIC in KSU,06-2727175#356,06-1234567</span>:/home/vbird1:/bin/bash
<span class="term_say"># 其实就是改到第五个字段，该字段里面用多个“ , ”分隔就是了！</span>

[vbird1@study ~]$ <span class="term_command">finger vbird1</span>
Login: vbird1                           <span class="term_command">Name: VBird Tsai test</span>
Directory: /home/vbird1                 Shell: /bin/bash
<span class="term_command">Office: DIC in KSU, 06-2727175#356      Home Phone: 06-1234567</span>
Last login Mon Jul 20 23:12 （CST） on pts/0
No mail.
Plan:
I will study Linux during this year.
<span class="term_say"># 就是上面特殊字体呈现的那些地方是由 chfn 所修改出来的！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 148--------------------------------------------------<br/>--------------------------------------------------149--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[vbird1@study ~]$ <span class="term_command">chsh [-ls]</span>
<span class="term_say">选项与参数：
-l  ：列出目前系统上面可用的 shell ，其实就是 /etc/shells 的内容！
-s  ：设置修改自己的 Shell 啰</span>

<span class="term_hd">范例一：用 vbird1 的身份列出系统上所有合法的 shell，并且指定 csh 为自己的 shell</span>
[vbird1@study ~]$ <span class="term_command">chsh -l</span>
/bin/sh
/bin/bash
/sbin/nologin   <span class="term_note">&lt;==所谓：合法不可登陆的 Shell 就是这玩意！</span>
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh        <span class="term_note">&lt;==这就是 C shell 啦！</span>
<span class="term_say"># 其实上面的信息就是我们在 <a href="#calibre_link-19" class="calibre51 pcalibre">bash</a> 中谈到的 /etc/shells 啦！</span>

[vbird1@study ~]$ <span class="term_command">chsh -s /bin/csh; grep vbird1 /etc/passwd</span>
Changing shell for vbird1.
Password:  <span class="term_note">&lt;==确认身份，请输入 vbird1 的密码</span>
Shell changed.
vbird1:x:1003:1004:VBird Tsai test,DIC in KSU,06-2727175#356,06-1234567:/home/vbird1:<span class="term_command">/bin/csh</span>

[vbird1@study ~]$ <span class="term_command">chsh -s /bin/bash</span>
<span class="term_say"># 测试完毕后，立刻改回来！</span>

[vbird1@study ~]$ <span class="term_command">ll $（which chsh）</span>
-rw<span class="term_command">s</span>--x--x. 1 root root 23856 Mar  6 13:59 /bin/chsh
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 149--------------------------------------------------<br/>--------------------------------------------------150--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">groupadd [-g gid] [-r] 群组名称</span>
<span class="term_say">选项与参数：
-g  ：后面接某个特定的 GID ，用来直接给予某个 GID ～
-r  ：创建系统群组啦！与 /etc/login.defs 内的 GID_MIN 有关。</span>

<span class="term_hd">范例一：新建一个群组，名称为 group1</span>
[root@study ~]# <span class="term_command">groupadd group1</span>
[root@study ~]# <span class="term_command">grep group1 /etc/group /etc/gshadow</span>
/etc/group:group1:x:<span class="term_command">1503</span>:
/etc/gshadow:group1:!::
<span class="term_say"># 群组的 GID 也是会由 1000 以上最大 GID+1 来决定！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 150--------------------------------------------------<br/>--------------------------------------------------151--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">groupmod [-g gid] [-n group_name] 群组名</span>
<span class="term_say">选项与参数：
-g  ：修改既有的 GID 数字；
-n  ：修改既有的群组名称</span>

<span class="term_hd">范例一：将刚刚上个指令创建的 group1 名称改为 mygroup ， GID 为 201</span>
[root@study ~]# <span class="term_command">groupmod -g 201 -n mygroup group1</span>
[root@study ~]# <span class="term_command">grep mygroup /etc/group /etc/gshadow</span>
/etc/group:mygroup:x:<span class="term_command">201</span>:
/etc/gshadow:mygroup:!::
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 151--------------------------------------------------<br/>--------------------------------------------------152--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">groupdel [groupname]</span>

<span class="term_hd">范例一：将刚刚的 mygroup 删除！</span>
[root@study ~]# <span class="term_command">groupdel mygroup</span>

<span class="term_hd">范例二：若要删除 vbird1 这个群组的话？</span>
[root@study ~]# <span class="term_command">groupdel vbird1</span>
groupdel: cannot remove the primary group of user 'vbird1'
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 152--------------------------------------------------<br/>--------------------------------------------------153--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd"># 关于系统管理员（root）做的动作：</span>
[root@study ~]# <span class="term_command">gpasswd groupname</span>
[root@study ~]# <span class="term_command">gpasswd [-A user1,...] [-M user3,...] groupname</span>
[root@study ~]# <span class="term_command">gpasswd [-rR] groupname</span>
<span class="term_say">选项与参数：
    ：若没有任何参数时，表示给予 groupname 一个密码（/etc/gshadow）
-A  ：将 groupname 的主控权交由后面的使用者管理（该群组的管理员）
-M  ：将某些帐号加入这个群组当中！
-r  ：将 groupname 的密码移除
-R  ：让 groupname 的密码栏失效</span>

<span class="term_hd"># 关于群组管理员（Group administrator）做的动作：</span>
[someone@study ~]$ <span class="term_command">gpasswd [-ad] user groupname</span>
<span class="term_say">选项与参数：
-a  ：将某位使用者加入到 groupname 这个群组当中！
-d  ：将某位使用者移除出 groupname 这个群组当中。</span>

<span class="term_hd">范例一：创建一个新群组，名称为 testgroup 且群组交由 vbird1 管理：</span>
[root@study ~]# <span class="term_command">groupadd testgroup</span>  <span class="term_note">&lt;==先创建群组</span>
[root@study ~]# <span class="term_command">gpasswd testgroup </span>  <span class="term_note">&lt;==给这个群组一个密码吧！</span>
Changing the password for group testgroup
New Password:
Re-enter new password:
<span class="term_say"># 输入两次密码就对了！</span>
[root@study ~]# <span class="term_command">gpasswd -A vbird1 testgroup</span>  <span class="term_note">&lt;==加入群组管理员为 vbird1</span>
[root@study ~]# <span class="term_command">grep testgroup /etc/group /etc/gshadow</span>
/etc/group:testgroup:x:1503:
/etc/gshadow:testgroup:<span class="term_command">$6$MnmChP3D$mrUn.Vo.buDjObMm8F2emTkvGSeuWikhRzaKHxpJ...:vbird1:</span>
<span class="term_say"># 很有趣吧！此时 vbird1 则拥有 testgroup 的主控权喔！身份有点像板主啦！</span>

<span class="term_hd">范例二：以 vbird1 登陆系统，并且让他加入 vbird1, vbird3 成为 testgroup 成员</span>
[vbird1@study ~]$ <span class="term_command">id</span>
uid=1003（vbird1） gid=1004（vbird1） groups=1004（vbird1） ...
<span class="term_say"># 看得出来，vbird1 尚未加入 testgroup 群组喔！</span>

[vbird1@study ~]$ <span class="term_command">gpasswd -a vbird1 testgroup</span>
[vbird1@study ~]$ <span class="term_command">gpasswd -a vbird3 testgroup</span>
[vbird1@study ~]$ <span class="term_command">grep testgroup /etc/group</span>
testgroup:x:1503:<span class="term_command">vbird1,vbird3</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 153--------------------------------------------------<br/>--------------------------------------------------154--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名</span>
<span class="term_say">选项与参数：
-m ：设置后续的 acl 参数给文件使用，不可与 -x 合用；
-x ：删除后续的 acl 参数，不可与 -m 合用；
-b ：移除“所有的” ACL 设置参数；
-k ：移除“默认的” ACL 参数，关于所谓的“默认”参数于后续范例中介绍；
-R ：递回设置 acl ，亦即包括次目录都会被设置起来；
-d ：设置“默认 acl 参数”的意思！只对目录有效，在该目录新建的数据会引用此默认值</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 154--------------------------------------------------<br/>--------------------------------------------------155--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：假设你原本是 dmtsai 的身份，想要使用 non-login shell 的方式变成 root</span>
[<span class="calibre34">dmtsai</span>@study ~]$ <span class="term_command">su</span>       <span class="term_note">&lt;==注意提示字符，是 dmtsai 的身份喔！</span>
Password:                  <span class="term_note">&lt;==这里输入 root 的密码喔！</span>
[root@study <span class="calibre34">dmtsai</span>]# <span class="term_command">id</span>    <span class="term_note">&lt;==提示字符的目录是 dmtsai 喔！</span>
<span class="calibre34">uid=0（root） gid=0（root）</span> groups=0（root） context=unconf....  <span class="term_note">&lt;==确实是 root 的身份！</span>
[root@study dmtsai]# <span class="term_command">env | grep 'dmtsai'</span>
USER=dmtsai                                         <span class="term_note">&lt;==竟然还是 dmtsai 这家伙！</span>
PATH=...:/home/dmtsai/.local/bin:/home/dmtsai/bin   <span class="term_note">&lt;==这个影响最大！</span> 
MAIL=/var/spool/mail/dmtsai                         <span class="term_note">&lt;==收到的 mailbox 是 vbird1</span>
PWD=/home/dmtsai                                    <span class="term_note">&lt;==并非 root 的主文件夹</span>
LOGNAME=dmtsai
<span class="term_say"># 虽然你的 UID 已经是具有 root 的身份，但是看到上面的输出讯息吗？
# 还是有一堆变量为原本 dmtsai 的身份，所以很多数据还是无法直接利用。</span>
[root@study dmtsai]# <span class="term_command">exit</span>   <span class="term_note">&lt;==这样可以离开 su 的环境！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 155--------------------------------------------------<br/>--------------------------------------------------156--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：使用 login shell 的方式切换为 root 的身份并观察变量</span>
[dmtsai@study ~]$ <span class="term_command">su -</span>
Password:   <span class="term_note">&lt;==这里输入 root 的密码喔！</span>
[root@study ~]# <span class="term_command">env | grep root</span>
USER=root
MAIL=/var/spool/mail/root
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
PWD=/root
HOME=/root
LOGNAME=root
<span class="term_say"># 了解差异了吧？下次变换成为 root 时，记得最好使用 su - 喔！</span>
[root@study ~]# <span class="term_command">exit</span>   <span class="term_note">&lt;==这样可以离开 su 的环境！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 156--------------------------------------------------<br/>--------------------------------------------------157--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：dmtsai 想要执行“ head -n 3 /etc/shadow ”一次，且已知 root 密码</span>
[dmtsai@study ~]$ <span class="term_command">head -n 3 /etc/shadow</span>
head: cannot open `/etc/shadow' for reading: Permission denied
[dmtsai@study ~]$ <span class="term_command">su - -c "head -n 3 /etc/shadow"</span>
Password: <span class="term_note">&lt;==这里输入 root 的密码喔！</span>
root:$6$wtbCCce/PxMeE5wm$KE2IfSJr.YLP7Rcai6oa/T7KFhOYO62vDnqfLw85...:16559:0:99999:7:::
bin:*:16372:0:99999:7:::
daemon:*:16372:0:99999:7:::
[dmtsai@study ~]$ <span class="term_note">&lt;==注意看，身份还是 dmtsai 喔！继续使用旧的身份进行系统操作！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 157--------------------------------------------------<br/>--------------------------------------------------158--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：原本是 dmtsai 这个使用者，想要变换身份成为 vbird1 时？</span>
[dmtsai@study ~]$ <span class="term_command">su -l vbird1</span>
Password: <span class="term_note">&lt;==这里输入 vbird1 的密码喔！</span>
[<span class="calibre34">vbird1</span>@study ~]$ <span class="term_command">su -</span>
Password: <span class="term_note">&lt;==这里输入 root 的密码喔！</span>
[<u class="calibre34">root</u>@study ~]# <span class="term_command">id sshd</span>
uid=74（sshd） gid=74（sshd） groups=74（sshd） ... <span class="term_note">&lt;==确实有存在此人</span>
[root@study ~]# <span class="term_command">su -l sshd</span>
This account is currently not available.      <span class="term_note">&lt;==竟然说此人无法切换？</span>
[root@study ~]# <span class="term_command">finger sshd</span>
Login: sshd                             Name: Privilege-separated SSH
Directory: /var/empty/sshd              Shell: <span class="term_command">/sbin/nologin</span>
[root@study ~]# <span class="term_command">exit</span>    <span class="term_note">&lt;==离开第二次的 su </span>
[vbird1@study ~]$ <span class="term_command">exit</span>  <span class="term_note">&lt;==离开第一次的 su </span>
[dmtsai@study ~]$ <span class="term_command">exit</span>  <span class="term_note">&lt;==这才是最初的环境！ </span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 158--------------------------------------------------<br/>--------------------------------------------------159--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">sudo [-b] [-u 新使用者帐号]</span>
<span class="term_say">选项与参数：
-b  ：将后续的指令放到背景中让系统自行执行，而不与目前的 shell 产生影响
-u  ：后面可以接欲切换的使用者，若无此项则代表切换身份为 root 。</span>

<span class="term_hd">范例一：你想要以 sshd 的身份在 /tmp 下面创建一个名为 mysshd 的文件</span>
[root@study ~]# <span class="term_command">sudo -u sshd touch /tmp/mysshd</span>
[root@study ~]# <span class="term_command">ll /tmp/mysshd</span>
-rw-r--r--. 1 <span class="term_command">sshd sshd</span> 0 Jul 21 23:37 /tmp/mysshd
<span class="term_say"># 特别留意，这个文件的权限是由 sshd 所创建的情况喔！</span>

<span class="term_hd">范例二：你想要以 vbird1 的身份创建 ~vbird1/www 并于其中创建 index.html 文件</span>
[root@study ~]# <span class="term_command">sudo -u vbird1 sh -c <u class="calibre34">"mkdir ~vbird1/www; cd ~vbird1/www; \</u></span>
&gt;  <span class="term_command"><u class="calibre34">echo 'This is index.html file' &gt; index.html"</u></span>
[root@study ~]# <span class="term_command">ll -a ~vbird1/www</span>
drwxr-xr-x. 2 vbird1 vbird1   23 Jul 21 23:38 .
drwx------. 6 vbird1 vbird1 4096 Jul 21 23:38 ..
-rw-r--r--. 1 vbird1 vbird1   24 Jul 21 23:38 index.html
<span class="term_say"># 要注意，创建者的身份是 vbird1 ，且我们使用 sh -c "一串指令" 来执行的！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 159--------------------------------------------------<br/>--------------------------------------------------160--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：vbird1 这个用户只能创建 100MB 的文件，且大于 90MB 会警告</span>
[root@study ~]# <span class="term_command">vim /etc/security/limits.conf</span>
<span class="term_command">vbird1	soft		fsize		 90000
vbird1	hard		fsize		100000</span>
<span class="term_say">#帐号   限制依据	限制项目 	限制值
# 第一字段为帐号，或者是群组！若为群组则前面需要加上 @ ，例如 @projecta
# 第二字段为限制的依据，是严格（hard），还是仅为警告（soft）；
# 第三字段为相关限制，此例中限制文件大小，
# 第四字段为限制的值，在此例中单位为 KB。
# 若以 vbird1 登陆后，进行如下的操作则会有相关的限制出现！</span>

[vbird1@study ~]$ <span class="term_command">ulimit -a</span>
<span class="term_say">....（前面省略）....</span>
file size               （blocks, -f） <span class="term_command">90000</span>
<span class="term_say">....（后面省略）....</span>

[vbird1@study ~]$ <span class="term_command">dd if=/dev/zero of=test bs=1M count=110</span>
File size limit exceeded
[vbird1@study ~]$ <span class="term_command">ll --block-size=K test</span>
-rw-rw-r--. 1 vbird1 vbird1 <span class="term_command">90000K</span> Jul 22 01:33 test
<span class="term_say"># 果然有限制到了</span>

<span class="term_hd">范例二：限制 pro1 这个群组，每次仅能有一个使用者登陆系统 （maxlogins）</span>
[root@study ~]# <span class="term_command">vim /etc/security/limits.conf</span>
<span class="term_command">@pro1   hard   maxlogins   1</span>
<span class="term_say"># 如果要使用群组功能的话，这个功能似乎对初始群组才有效喔！而如果你尝试多个 pro1 的登陆时，
# 第二个以后就无法登陆了。而且在 /var/log/secure 文件中还会出现如下的信息：
# pam_limits（login:session）: Too many logins （max 1） for pro1</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 160--------------------------------------------------<br/>--------------------------------------------------161--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">xfs_quota -x -c "指令" [挂载点]</span>
<span class="term_say">选项与参数：
-x  ：专家模式，后续才能够加入 -c 的指令参数喔！
-c  ：后面加的就是指令，这个小节我们先来谈谈数据回报的指令
指令：
      print ：单纯的列出目前主机内的文件系统参数等数据
      df    ：与原本的 df 一样的功能，可以加上 -b （block） -i （inode） -h （加上单位） 等
      report：列出目前的 quota 项目，有 -ugr （user/group/project） 及 -bi 等数据
      state ：说明目前支持 quota 的文件系统的信息，有没有起动相关项目等</span>

<span class="term_hd">范例一：列出目前系统的各的文件系统，以及文件系统的 quota 挂载参数支持</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "print"</span>
Filesystem          Pathname
/                   /dev/mapper/centos-root
/srv/myproject      /dev/vda4
/boot               /dev/vda2
/home               /dev/mapper/centos-home （<span class="term_command">uquota, gquota</span>）  <span class="term_note"># 所以这里就有显示支持啰</span>

<span class="term_hd">范例二：列出目前 /home 这个支持 quota 的载点文件系统使用情况</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "df -h" /home</span>
Filesystem     Size   Used  Avail Use% Pathname
/dev/mapper/centos-home
               5.0G  67.0M   4.9G   1% /home
<span class="term_say"># 如上所示，其实跟原本的 df 差不多啦！只是会更正确就是了。</span>

<span class="term_hd">范例三：列出目前 /home 的所有用户的 quota 限制值</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "report -ubih" /home</span>
User quota on /home （/dev/mapper/centos-home）
                        <span class="term_command">Blocks                            Inodes</span>
User ID      <span class="term_command">Used   Soft   Hard Warn/Grace</span>     Used   Soft   Hard Warn/Grace
---------- --------------------------------- ---------------------------------
root           4K      0      0  00 [------]      4      0      0  00 [------]
dmtsai      34.0M      0      0  00 [------]    432      0      0  00 [------]
<span class="term_say">.....（中间省略）.....</span>
myquota1      12K      0      0  00 [------]      7      0      0  00 [------]
myquota2      12K      0      0  00 [------]      7      0      0  00 [------]
myquota3      12K      0      0  00 [------]      7      0      0  00 [------]
myquota4      12K      0      0  00 [------]      7      0      0  00 [------]
myquota5      12K      0      0  00 [------]      7      0      0  00 [------]
<span class="term_say"># 所以列出了所有用户的目前的文件使用情况，并且列出设置值。注意，最上面的 Block
# 代表这个是 block 容量限制，而 inode 则是文件数量限制喔。另外，soft/hard 若为 0，代表没限制</span>

<span class="term_hd">范例四：列出目前支持的 quota 文件系统是否有起动了 quota 功能？</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "state"</span>
User quota state on /home （/dev/mapper/centos-home）
  Accounting: ON    <span class="term_note"># 有启用计算功能</span>
  Enforcement: ON   <span class="term_note"># 有实际 quota 管制的功能</span>
  Inode: #1568 （4 blocks, 4 extents）  <span class="term_note"># 上面四行说明的是有启动 user 的限制能力</span>
Group quota state on /home （/dev/mapper/centos-home）
  Accounting: ON
  Enforcement: ON
  Inode: #1569 （5 blocks, 5 extents）  <span class="term_note"># 上面四行说明的是有启动 group 的限制能力</span>
Project quota state on /home （/dev/mapper/centos-home）
  Accounting: OFF
  Enforcement: OFF
  Inode: #1569 （5 blocks, 5 extents）  <span class="term_note"># 上面四行说明的是 project 并未支持</span>
Blocks grace time: [7 days 00:00:30]  <span class="term_note"># 下面则是 grace time 的项目</span>
Inodes grace time: [7 days 00:00:30]
Realtime Blocks grace time: [7 days 00:00:30]
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 161--------------------------------------------------<br/>--------------------------------------------------162--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">xfs_quota -x -c "limit [-ug] b[soft|hard]=N i[soft|hard]=N name"</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "timer [-ug] [-bir] Ndays"</span>
<span class="term_say">选项与参数：
limit ：实际限制的项目，可以针对 user/group 来限制，限制的项目有
        bsoft/bhard : block 的 soft/hard 限制值，可以加单位
        isoft/ihard : inode 的 soft/hard 限制值
        name        : 就是用户/群组的名称啊！
timer ：用来设置 grace time 的项目喔，也是可以针对 user/group 以及 block/inode 设置</span>

<span class="term_hd">范例一：设置好用户们的 block 限制值 （题目中没有要限制 inode 啦！）</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "limit -u bsoft=250M bhard=300M myquota1" /home</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "limit -u bsoft=250M bhard=300M myquota2" /home</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "limit -u bsoft=250M bhard=300M myquota3" /home</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "limit -u bsoft=250M bhard=300M myquota4" /home</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "limit -u bsoft=250M bhard=300M myquota5" /home</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "report -ubih" /home</span>
User quota on /home （/dev/mapper/centos-home）
                        Blocks                            Inodes
User ID      Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace
---------- --------------------------------- ---------------------------------
myquota1      12K   <span class="term_command">250M   300M</span>  00 [------]      7      0      0  00 [------]

<span class="term_hd">范例二：设置好 myquotagrp 的 block 限制值</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "limit -g bsoft=950M bhard=1G myquotagrp" /home</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "report -gbih" /home</span>
Group quota on /home （/dev/mapper/centos-home）
                        Blocks                            Inodes
Group ID     Used   Soft   Hard Warn/Grace     Used   Soft   Hard Warn/Grace
---------- --------------------------------- ---------------------------------
myquotagrp    60K   <span class="term_command">950M     1G</span>  00 [------]     36      0      0  00 [------]

<span class="term_hd">范例三：设置一下 grace time 变成 14 天吧！</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "timer -ug -b 14days" /home</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "state" /home</span>
User quota state on /home （/dev/mapper/centos-home）
<span class="term_say">.....（中间省略）.....</span>
Blocks grace time: [<span class="term_command">14 days</span> 00:00:30]
Inodes grace time: [7 days 00:00:30]
Realtime Blocks grace time: [7 days 00:00:30]

<span class="term_hd">范例四：以 myquota1 用户测试 quota 是否真的实际运行呢？</span>
[root@study ~]# <span class="term_command">su - myquota1</span>
[myquota1@study ~]$ <span class="term_command">dd if=/dev/zero of=123.img bs=1M count=310</span>
dd: error writing ‘123.img’: Disk quota exceeded
300+0 records in
299+0 records out
314552320 Bytes （315 MB） copied, 0.181088 s, 1.7 GB/s
[myquota1@study ~]$ <span class="term_command">ll -h</span>
-rw-r--r--. 1 myquota1 myquotagrp <span class="term_command">300M</span> Jul 24 21:38 123.img

[myquota1@study ~]$ <span class="term_command">exit</span>
[root@study ~]# <span class="term_command">xfs_quota -x -c "report -ubh" /home</span>
User quota on /home （/dev/mapper/centos-home）
                        Blocks
User ID      Used   Soft   Hard Warn/Grace
---------- ---------------------------------
<span class="term_command">myquota1     300M   250M   300M  00 [13 days]</span>
myquota2      12K   250M   300M  00 [------]
<span class="term_say"># 因为 myquota1 的磁盘用量已经破表，所以当然就会出现那个可怕的 grace time 啰！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 162--------------------------------------------------<br/>--------------------------------------------------163--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：再过五分钟后，将 /root/.bashrc 寄给 root 自己</span>
[root@study ~]# <span class="term_command">at now + 5 minutes</span>  <span class="term_note">&lt;==记得单位要加 s 喔！</span>
at&gt; <span class="term_command">/bin/mail -s "testing at job" root &lt; /root/.bashrc</span>
at&gt; &lt;EOT&gt;   <span class="term_note">&lt;==这里输入 [ctrl] + d 就会出现 &lt;EOF&gt; 的字样！代表结束！</span>
job 2 at Thu Jul 30 19:35:00 2015
<span class="term_say"># 上面这行信息在说明，第 2 个 at 工作将在 2015/07/30 的 19:35 进行！
# 而执行 at 会进入所谓的 at shell 环境，让你下达多重指令等待运行！</span>

<span class="term_hd">范例二：将上述的第 2 项工作内容列出来查阅</span>
[root@study ~]# <span class="term_command">at -c 2</span>
#!/bin/sh               <span class="term_note">&lt;==就是通过 bash shell 的啦！</span>
# atrun uid=0 gid=0
# mail root 0
umask 22
<span class="term_say">....（中间省略许多的环境变量项目）....</span>
cd /etc/cron\.d || {
         echo 'Execution directory inaccessible' &gt;&amp;2
         exit 1
}
<span class="term_command">${SHELL:-/bin/sh} &lt;&lt; 'marcinDELIMITER410efc26'
/bin/mail -s "testing at job" root &lt; /root/.bashrc    <span class="term_note"># 这一行最重要！</span>
marcinDELIMITER410efc26</span>
<span class="term_say"># 你可以看到指令执行的目录 （/root），还有多个环境变量与实际的指令内容啦！</span>

<span class="term_hd">范例三：由于机房预计于 2015/08/05 停电，我想要在 2015/08/04 23:00 关机？</span>
[root@study ~]# <span class="term_command">at 23:00 2015-08-04</span>
at&gt; <span class="term_command">/bin/sync</span>
at&gt; <span class="term_command">/bin/sync</span>
at&gt; <span class="term_command">/sbin/shutdown -h now</span>
at&gt; &lt;EOT&gt;
job 3 at Tue Aug  4 23:00:00 2015
<span class="term_say"># 您瞧瞧！ at 还可以在一个工作内输入多个指令呢！不错吧！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 163--------------------------------------------------<br/>--------------------------------------------------164--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">atq</span>
[root@study ~]# <span class="term_command">atrm （jobnumber）</span>

<span class="term_hd">范例一：查询目前主机上面有多少的 at 工作调度？</span>
[root@study ~]# <span class="term_command">atq</span>
3       Tue Aug  4 23:00:00 2015 a root
<span class="term_say"># 上面说的是：“在 2015/08/04 的 23:00 有一项工作，该项工作指令下达者为 
# root”而且，该项工作的工作号码 （jobnumber） 为 3 号喔！</span>

<span class="term_hd">范例二：将上述的第 3 个工作移除！</span>
[root@study ~]# <span class="term_command">atrm 3</span>
[root@study ~]# <span class="term_command">atq</span>
<span class="term_say"># 没有任何信息，表示该工作被移除了！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 164--------------------------------------------------<br/>--------------------------------------------------165--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：请执行 pi 的计算，然后在系统闲置时，执行 updatdb 的任务</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a（1）" | bc -lq &amp;</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a（1）" | bc -lq &amp;</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a（1）" | bc -lq &amp;</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a（1）" | bc -lq &amp;</span>
<span class="term_say"># 然后等待个大约数十秒的时间，之后再来确认一下工作负载的情况！</span>
[root@study ~]# <span class="term_command">uptime</span>
 19:56:45 up 2 days, 19:54,  2 users,  <span class="term_command">load average: 3.93, 2.23, 0.96</span>

[root@study ~]# <span class="term_command">batch</span>
at&gt; <span class="term_command">/usr/bin/updatedb</span>
at&gt; &lt;EOT&gt;
job 4 at Thu Jul 30 19:57:00 2015

[root@study ~]# <span class="term_command">date;atq</span>
Thu Jul 30 19:57:47 CST 2015
4       Thu Jul 30 19:57:00 2015 b root
<span class="term_say"># 可以看得到，明明时间已经超过了，却没有实际执行 at 的任务！</span>

[root@study ~]# <span class="term_command">jobs</span>
[1]   Running                 echo "scale=100000; 4*a（1）" | bc -lq &amp;
[2]   Running                 echo "scale=100000; 4*a（1）" | bc -lq &amp;
[3]-  Running                 echo "scale=100000; 4*a（1）" | bc -lq &amp;
[4]+  Running                 echo "scale=100000; 4*a（1）" | bc -lq &amp;
[root@study ~]# <span class="term_command">kill -9 %1 %2 %3 %4</span>
<span class="term_say"># 这时先用 jobs 找出背景工作，再使用 kill 删除掉四个背景工作后，慢慢等待工作负载的下降</span>

[root@study ~]# <span class="term_command">uptime; atq</span>
 20:01:33 up 2 days, 19:59,  2 users,  load average: 0.89, 2.29, 1.40
4       Thu Jul 30 19:57:00 2015 b root
[root@study ~]# <span class="term_command">uptime; atq</span>
 20:02:52 up 2 days, 20:01,  2 users,  load average: 0.23, 1.75, 1.28
<span class="term_say"># 在 19:59 时，由于 loading 还是高于 0.8，因此 atq 可以看得到 at job 还是持续再等待当中喔！
# 但是到了 20:01 时， loading 降低到 0.8 以下了，所以 atq 就执行完毕啰！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 165--------------------------------------------------<br/>--------------------------------------------------166--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">crontab [-u username] [-l|-e|-r]</span>
<span class="term_say">选项与参数：
-u  ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度；
-e  ：编辑 crontab 的工作内容
-l  ：查阅 crontab 的工作内容
-r  ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</span>

<span class="term_hd">范例一：用 dmtsai 的身份在每天的 12:00 发信给自己</span>
[dmtsai@study ~]$ <span class="term_command">crontab -e</span>
<span class="term_say"># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span>
<span class="term_command">0   12  *  *  * mail -s "at 12:00" dmtsai &lt; /home/dmtsai/.bashrc</span>
<span class="term_say">#分 时 日 月 周 |&lt;==============指令串========================&gt;|</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 166--------------------------------------------------<br/>--------------------------------------------------167--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">jobs [-lrs]</span>
<span class="term_say">选项与参数：
-l  ：除了列出 job number 与指令串之外，同时列出 PID 的号码；
-r  ：仅列出正在背景 run 的工作；
-s  ：仅列出正在背景当中暂停 （stop） 的工作。</span>

<span class="term_hd">范例一：观察目前的 bash 当中，所有的工作，与对应的 PID</span>
[root@study ~]# <span class="term_command">jobs -l</span>
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 167--------------------------------------------------<br/>--------------------------------------------------168--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">fg %jobnumber</span>
<span class="term_say">选项与参数：
%jobnumber ：jobnumber 为工作号码（数字）。注意，那个 % 是可有可无的！</span>

<span class="term_hd">范例一：先以 jobs 观察工作，再将工作取出：</span>
[root@study ~]# <span class="term_command">jobs -l</span>
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
[root@study ~]# <span class="term_command">fg   </span>   <span class="term_note">&lt;==默认取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z</span>
[root@study ~]# <span class="term_command">fg %1</span>   <span class="term_note">&lt;==直接规定取出的那个工作号码！再按下[ctrl]-z</span>
[root@study ~]# <span class="term_command">jobs -l</span>
[1]<span class="term_command">+</span> 14566 Stopped                 vim ~/.bashrc
[2]- 14567 Stopped                 find / -print
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 168--------------------------------------------------<br/>--------------------------------------------------169--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：一执行 find / -perm /7000 &gt; /tmp/text.txt 后，立刻丢到背景去暂停！</span>
[root@study ~]# <span class="term_command">find / -perm /7000 &gt; /tmp/text.txt</span>
<span class="term_say"># 此时，请立刻按下 [ctrl]-z 暂停！</span>
[3]+  Stopped                 find / -perm /7000 &gt; /tmp/text.txt

<span class="term_hd">范例二：让该工作在背景下进行，并且观察他！！</span>
[root@study ~]# <span class="term_command">jobs ; bg %3 ; jobs</span>
[1]   Stopped                 vim ~/.bashrc
[2]-  Stopped                 find / -print
[3]+  <span class="term_command">Stopped</span>                 find / -perm /7000 &gt; /tmp/text.txt
[3]+ find / -perm /7000 &gt; /tmp/text.txt &amp;
[1]-  Stopped                 vim ~/.bashrc
[2]+  Stopped                 find / -print
[3]   <span class="term_command">Running</span>                 find / -perm /7000 &gt; /tmp/text.txt &amp;
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 169--------------------------------------------------<br/>--------------------------------------------------170--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">kill -signal %jobnumber</span>
[root@study ~]# <span class="term_command">kill -l</span>
<span class="term_say">选项与参数：
-l  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 （signal） 有哪些？
signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：
  -1 ：重新读取一次参数的配置文件 （类似 reload）；
  -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
  -9 ：立刻强制删除一个工作；
  -15：以正常的程序方式终止一项工作。与 -9 是不一样的。</span>

<span class="term_hd">范例一：找出目前的 bash 环境下的背景工作，并将该工作“强制删除”。</span>
[root@study ~]# <span class="term_command">jobs</span>
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[root@study ~]# <span class="term_command">kill -9 %2; jobs</span>
[1]+  Stopped                 vim ~/.bashrc
[2]   <span class="term_command">Killed</span>                  find / -print
<span class="term_say"># 再过几秒你再下达 jobs 一次，就会发现 2 号工作不见了！因为被移除了！</span>

<span class="term_hd">范例二：找出目前的 bash 环境下的背景工作，并将该工作“正常终止”掉。</span>
[root@study ~]# <span class="term_command">jobs</span>
[1]+  Stopped                 vim ~/.bashrc
[root@study ~]# <span class="term_command">kill -SIGTERM %1</span>
<span class="term_say"># -SIGTERM 与 -15 是一样的！您可以使用 kill -l 来查阅！
# 不过在这个案例中， vim 的工作无法被结束喔！因为他无法通过 kill 正常终止的意思！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 170--------------------------------------------------<br/>--------------------------------------------------171--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：将目前属于您自己这次登陆的 PID 与相关信息列示出来（只与自己的 bash 有关）</span>
[root@study ~]# <span class="term_command">ps -l</span>
<span class="calibre34">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span>
4 S     0 14830 13970  0  80   0 - 52686 poll_s pts/0    00:00:00 sudo
4 S     0 14835 14830  0  80   0 - 50511 wait   pts/0    00:00:00 su
<span class="calibre34">4 S     0 14836 14835  0  80   0 - 29035 wait   pts/0    00:00:00 bash</span>
0 R     0 15011 14836  0  80   0 - 30319 -      pts/0    00:00:00 ps
<span class="term_say"># 还记得鸟哥说过，非必要不要使用 root 直接登陆吧？从这个 ps -l 的分析，你也可以发现，
# 鸟哥其实是使用 sudo 才转成 root 的身份～否则连测试机，鸟哥都是使用一般帐号登陆的！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 171--------------------------------------------------<br/>--------------------------------------------------172--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：列出目前所有的正在内存当中的程序：</span>
[root@study ~]# <span class="term_command">ps aux</span>
<span class="calibre34">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span>
root         1  0.0  0.2  60636  7948 ?        Ss   Aug04   0:01 /usr/lib/systemd/systemd ...
root         2  0.0  0.0      0     0 ?        S    Aug04   0:00 [kthreadd]
<span class="term_say">.....（中间省略）.....</span>
root     14830  0.0  0.1 210744  3988 pts/0    S    Aug04   0:00 sudo su -
root     14835  0.0  0.1 202044  2996 pts/0    S    Aug04   0:00 su -
<span class="calibre34">root     14836  0.0  0.1 116140  2960 pts/0    S    Aug04   0:00 -bash</span>
<span class="term_say">.....（中间省略）.....</span>
root     18459  0.0  0.0 123372  1380 pts/0    R+   00:25   0:00 ps aux
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 172--------------------------------------------------<br/>--------------------------------------------------173--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：以范例一的显示内容，显示出所有的程序：</span>
[root@study ~]# <span class="term_command">ps -lA</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 - 15159 ep_pol ?        00:00:01 systemd
1 S     0     2     0  0  80   0 -     0 kthrea ?        00:00:00 kthreadd
1 S     0     3     2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/0
<span class="term_say">....（以下省略）....
# 你会发现每个字段与 ps -l 的输出情况相同，但显示的程序则包括系统所有的程序。</span>

<span class="term_hd">范例四：列出类似程序树的程序显示：</span>
[root@study ~]# <span class="term_command">ps axjf</span>
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
    0     2     0     0 ?           -1 S        0   0:00 [kthreadd]
    2     3     0     0 ?           -1 S        0   0:00  \_ [ksoftirqd/0]
<span class="term_say">.....（中间省略）.....</span>
    1  1326  1326  1326 ?           -1 Ss       0   0:00 /usr/sbin/sshd -D
 1326 13923 13923 13923 ?           -1 Ss       0   0:00  \_ sshd: dmtsai [priv]
13923 13927 13923 13923 ?           -1 S     1000   0:00      \_ sshd: dmtsai@pts/0
13927 13928 13928 13928 pts/0    18703 Ss    1000   0:00          \_ -bash
13928 13970 13970 13928 pts/0    18703 S     1000   0:00              \_ bash
13970 14830 14830 13928 pts/0    18703 S        0   0:00                  \_ sudo su -
14830 14835 14830 13928 pts/0    18703 S        0   0:00                      \_ su -
14835 14836 14836 13928 pts/0    18703 S        0   0:00                          \_ -bash
14836 18703 18703 13928 pts/0    18703 R+       0   0:00                              \_ ps axjf
<span class="term_say">.....（后面省略）.....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 173--------------------------------------------------<br/>--------------------------------------------------174--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例五：找出与 cron 与 rsyslog 这两个服务有关的 PID 号码？</span>
[root@study ~]# <span class="term_command">ps aux | egrep '（cron|rsyslog）'</span>
root       742  0.0  0.1 208012  4088 ?        Ssl  Aug04   0:00 /usr/sbin/rsyslogd -n
root      1338  0.0  0.0 126304  1704 ?        Ss   Aug04   0:00 /usr/sbin/crond -n
root     18740  0.0  0.0 112644   980 pts/0    S+   00:49   0:00 grep -E --color=auto （cron|rsyslog）
<span class="term_say"># 所以号码是 742 及 1338 这两个啰！就是这样找的啦！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 174--------------------------------------------------<br/>--------------------------------------------------175--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：每两秒钟更新一次 top ，观察整体信息：</span>
[root@study ~]# <span class="term_command">top -d 2</span>
top - 00:53:59 up  6:07,  3 users,  <span class="calibre34">load average: 0.00, 0.01, 0.05</span>
Tasks: 179 total,   2 running, 177 sleeping,   0 stopped,   <span class="calibre34">0 zombie</span>
%Cpu（s）:  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  <span class="calibre34">0.0 wa</span>,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  2916388 total,  1839140 free,   353712 used,   723536 buff/cache
KiB Swap:  1048572 total,  1048572 free,   <span class="calibre34">     0 used</span>.  2318680 avail Mem
    <span class="term_note">&lt;==如果加入 k 或 r 时，就会有相关的字样出现在这里喔！</span>
<span class="calibre72">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    </span>
18804 root      20   0  130028   1872   1276 R   0.5  0.1   0:00.02 top
    1 root      20   0   60636   7948   2656 S   0.0  0.3   0:01.70 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd
    3 root      20   0       0      0      0 S   0.0  0.0   0:00.00 ksoftirqd/0
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 175--------------------------------------------------<br/>--------------------------------------------------176--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：将 top 的信息进行 2 次，然后将结果输出到 /tmp/top.txt</span>
[root@study ~]# <span class="term_command">top -b -n 2 &gt; /tmp/top.txt</span>
<span class="term_say"># 这样一来，嘿嘿！就可以将 top 的信息存到 /tmp/top.txt 文件中了。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 176--------------------------------------------------<br/>--------------------------------------------------177--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例三：我们自己的 bash PID 可由 $$ 变量取得，请使用 top 持续观察该 PID</span>
[root@study ~]# <span class="term_command">echo $$</span>
14836  <span class="term_note">&lt;==就是这个数字！他是我们 bash 的 PID</span>
[root@study ~]# <span class="term_command">top -d 2 -p 14836</span>
top - 01:00:53 up  6:14,  3 users,  load average: 0.00, 0.01, 0.05
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu（s）:  0.0 us,  0.1 sy,  0.0 ni, 99.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  2916388 total,  1839264 free,   353424 used,   723700 buff/cache
KiB Swap:  1048572 total,  1048572 free,        0 used.  2318848 avail Mem

<span class="calibre72">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span>
<span class="calibre34">14836</span> root      20   0  116272   3136   1848 S   0.0  0.1   0:00.07 bash
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 177--------------------------------------------------<br/>--------------------------------------------------178--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：承上题，上面的 NI 值是 0 ，想要改成 10 的话？</span>
<span class="term_say"># 在范例三的 top 画面当中直接按下 r 之后，会出现如下的图样！</span>
top - 01:02:01 up  6:15,  3 users,  load average: 0.00, 0.01, 0.05
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu（s）:  0.1 us,  0.0 sy,  0.0 ni, 99.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  2916388 total,  1839140 free,   353576 used,   723672 buff/cache
KiB Swap:  1048572 total,  1048572 free,        0 used.  2318724 avail Mem
PID to renice [default pid = 14836] <span class="term_command">14836</span>
<span class="calibre72">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span>
14836 root      20   0  116272   3136   1848 S   0.0  0.1   0:00.07 bash
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 178--------------------------------------------------<br/>--------------------------------------------------179--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">pstree [-A|U] [-up]</span>
<span class="term_say">选项与参数：
-A  ：各程序树之间的连接以 ASCII 字符来连接；
-U  ：各程序树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误；
-p  ：并同时列出每个 process 的 PID；
-u  ：并同时列出每个 process 的所属帐号名称。</span>

<span class="term_hd">范例一：列出目前系统上面所有的程序树的相关性：</span>
[root@study ~]# <span class="term_command">pstree -A</span>
systemd-+-ModemManager---2*[{ModemManager}]       <span class="term_note"># 这行是 ModenManager 与其子程序</span>
        |-NetworkManager---3*[{NetworkManager}]   <span class="term_note"># 前面有数字，代表子程序的数量！</span>
<span class="term_say">....（中间省略）....</span>
        |-sshd---sshd---sshd---bash---bash---sudo---su---bash---pstree <span class="term_note">&lt;==我们指令执行的相依性</span>
<span class="term_say">....（下面省略）....</span>
<span class="term_say"># 注意一下，为了节省版面，所以鸟哥已经删去很多程序了！</span>

<span class="term_hd">范例二：承上题，同时秀出 PID 与 users </span>
[root@study ~]# <span class="term_command">pstree -Aup</span>
systemd（1）-+-ModemManager（745）-+-{ModemManager}（785）
           |                   `-{ModemManager}（790）
           |-NetworkManager（870）-+-{NetworkManager}（907）
           |                     |-{NetworkManager}（911）
           |                     `-{NetworkManager}（914）
<span class="term_say">....（中间省略）....</span>
           |-sshd（1326）---sshd（13923）---sshd（13927,<span class="term_command">dmtsai</span>）---bash（13928）---bash（13970）---
<span class="term_say">....（下面省略）....</span>
<span class="term_say"># 在括号 （） 内的即是 PID 以及该程序的 owner 喔！一般来说，如果该程序的所有人与父程序同，
# 就不会列出，但是如果与父程序不一样，那就会列出该程序的拥有者！看上面 13927 就转变成 dmtsai 了</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 179--------------------------------------------------<br/>--------------------------------------------------180--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">killall [-iIe] [command name]</span>
<span class="term_say">选项与参数：
-i  ：interactive 的意思，互动式的，若需要删除时，会出现提示字符给使用者；
-e  ：exact 的意思，表示“后面接的 command name 要一致”，但整个完整的指令
      不能超过 15 个字符。
-I  ：指令名称（可能含参数）忽略大小写。</span>

<span class="term_hd">范例一：给予 rsyslogd 这个指令启动的 PID 一个 SIGHUP 的讯号</span>
[root@study ~]# <span class="term_command">killall -1 rsyslogd</span>
<span class="term_say"># 如果用 ps aux 仔细看一下，若包含所有参数，则 /usr/sbin/rsyslogd -n 才是最完整的！</span>

<span class="term_hd">范例二：强制终止所有以 httpd 启动的程序 （其实并没有此程序在系统内）</span>
[root@study ~]# <span class="term_command">killall -9 httpd</span>

<span class="term_hd">范例三：依次询问每个 bash 程序是否需要被终止运行！</span>
[root@study ~]# <span class="term_command">killall -i -9 bash</span>
Signal bash（13888） ? （y/N） <span class="term_command">n</span> <span class="term_note">&lt;==这个不杀！</span>
Signal bash（13928） ? （y/N） <span class="term_command">n</span> <span class="term_note">&lt;==这个不杀！</span>
Signal bash（13970） ? （y/N） <span class="term_command">n</span> <span class="term_note">&lt;==这个不杀！</span>
Signal bash（14836） ? （y/N） <span class="term_command">y</span> <span class="term_note">&lt;==这个杀掉！</span>
<span class="term_say"># 具有互动的功能！可以询问你是否要删除 bash 这个程序。要注意，若没有 -i 的参数，
# 所有的 bash 都会被这个 root 给杀掉！包括 root 自己的 bash 喔！ ^_^</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 180--------------------------------------------------<br/>--------------------------------------------------181--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">nice [-n 数字] command</span>
<span class="term_say">选项与参数：
-n  ：后面接一个数值，数值的范围 -20 ~ 19。</span>

<span class="term_hd">范例一：用 root 给一个 nice 值为 -5 ，用于执行 vim ，并观察该程序！</span>
[root@study ~]# <span class="term_command">nice -n -5 vim &amp;</span>
[1] 19865
[root@study ~]# <span class="term_command">ps -l</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 14836 14835  0  90  10 - 29068 wait   pts/0    00:00:00 bash
4 T     0 19865 14836  0  <span class="term_command">85   5</span> - 37757 signal pts/0    00:00:00 vim
0 R     0 19866 14836  0  90  10 - 30319 -      pts/0    00:00:00 ps
<span class="term_say"># 原本的 bash PRI 为 90  ，所以 vim 默认应为 90。不过由于给予 nice  为 -5 ，
# 因此 vim 的 PRI 降低了！RPI 与 NI 各减 5 ！但不一定每次都是正好相同喔！因为核心会动态调整</span>

[root@study ~]# <span class="term_command">kill -9 %1</span> <span class="term_note">&lt;==测试完毕将 vim 关闭</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 181--------------------------------------------------<br/>--------------------------------------------------182--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">renice [number] PID</span>
<span class="term_say">选项与参数：
PID ：某个程序的 ID 啊！</span>

<span class="term_hd">范例一：找出自己的 bash PID ，并将该 PID 的 nice 调整到 -5</span>
[root@study ~]# <span class="term_command">ps -l</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 <span class="term_command">14836</span> 14835  0  <span class="term_command">90  10</span> - 29068 wait   pts/0    00:00:00 bash
0 R     0 19900 14836  0  90  10 - 30319 -      pts/0    00:00:00 ps

[root@study ~]# <span class="term_command">renice -5 14836</span>
14836 （process ID） old priority 10, new priority -5

[root@study ~]# <span class="term_command">ps -l</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 14836 14835  0  <span class="term_command">75  -5</span> - 29068 wait   pts/0    00:00:00 bash
0 R     0 19910 14836  0  <span class="term_command">75  -5</span> - 30319 -      pts/0    00:00:00 ps
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 182--------------------------------------------------<br/>--------------------------------------------------183--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span>
<span class="term_say">选项与参数：
-b  ：直接输入 free 时，显示的单位是 KBytes，我们可以使用 b（Bytes）, m（MBytes）
      k（KBytes）, 及 g（GBytes） 来显示单位喔！也可以直接让系统自己指定单位 （-h）
-t  ：在输出的最终结果，显示实体内存与 swap 的总量。
-s  ：可以让系统每几秒钟输出一次，不间断的一直输出的意思！对于系统观察挺有效！
-c  ：与 -s 同时处理～让 free 列出几次的意思～</span>

<span class="term_hd">范例一：显示目前系统的内存容量</span>
[root@study ~]# <span class="term_command">free -m</span>
              total        used        free      shared  buff/cache   available
Mem:           2848         346        1794           8         706        2263
Swap:          1023           0        1023
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 183--------------------------------------------------<br/>--------------------------------------------------184--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">uname [-asrmpi]</span>
<span class="term_say">选项与参数：
-a  ：所有系统相关的信息，包括下面的数据都会被列出来；
-s  ：系统核心名称
-r  ：核心的版本
-m  ：本系统的硬件名称，例如 i686 或 x86_64 等；
-p  ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！
-i  ：硬件的平台 （ix86）</span>

<span class="term_hd">范例一：输出系统的基本信息</span>
[root@study ~]# <span class="term_command">uname -a</span>
Linux study.centos.vbird 3.10.0-229.el7.x86_64 #1 SMP Fri Mar 6 11:36:42 UTC 2015 
x86_64 x86_64 x86_64 GNU/Linux
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 184--------------------------------------------------<br/>--------------------------------------------------185--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">netstat -[atunlp]</span>
<span class="term_say">选项与参数：
-a  ：将目前系统上所有的连线、监听、Socket 数据都列出来
-t  ：列出 tcp 网络封包的数据
-u  ：列出 udp 网络封包的数据
-n  ：不以程序的服务名称，以埠号 （port number） 来显示；
-l  ：列出目前正在网络监听 （listen） 的服务；
-p  ：列出该网络服务的程序 PID </span>

<span class="term_hd">范例一：列出目前系统已经创建的网络连线与 unix socket 状态</span>
[root@study ~]# <span class="term_command">netstat</span>
<span class="calibre34">Active Internet connections （w/o servers）</span> <span class="term_note">&lt;==与网络较相关的部分</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 172.16.15.100:ssh       172.16.220.234:48300    ESTABLISHED
<span class="calibre34">Active UNIX domain sockets （w/o servers）</span>  <span class="term_note">&lt;==与本机的程序自己的相关性（非网络）</span>
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ]         DGRAM                    1902     @/org/freedesktop/systemd1/notify
unix  2      [ ]         DGRAM                    1944     /run/systemd/shutdownd
<span class="term_say">....（中间省略）....</span>
unix  3      [ ]         STREAM     CONNECTED     25425    @/tmp/.X11-unix/X0
unix  3      [ ]         STREAM     CONNECTED     28893
unix  3      [ ]         STREAM     CONNECTED     21262
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 185--------------------------------------------------<br/>--------------------------------------------------186--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：找出目前系统上已在监听的网络连线及其 PID</span>
[root@study ~]# <span class="term_command">netstat -tulnp</span>
Active Internet connections （only servers）
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1326/sshd
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      2349/master
tcp6       0      0 :::22                   :::*                    LISTEN      <span class="term_command">1326/sshd</span>
tcp6       0      0 ::1:25                  :::*                    LISTEN      2349/master
udp        0      0 0.0.0.0:123             0.0.0.0:*                           751/chronyd
udp        0      0 127.0.0.1:323           0.0.0.0:*                           751/chronyd
udp        0      0 0.0.0.0:57808           0.0.0.0:*                           743/avahi-daemon: r
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           743/avahi-daemon: r
udp6       0      0 :::123                  :::*                                751/chronyd
udp6       0      0 ::1:323                 :::*                                751/chronyd
<span class="term_say"># 除了可以列出监听网络的接口与状态之外，最后一个字段还能够显示此服务的
# PID 号码以及程序的指令名称喔！例如上头的 1326 就是该 PID</span>

<span class="term_hd">范例三：将上述的 0.0.0.0:57808 那个网络服务关闭的话？</span>
[root@study ~]# <span class="term_command">kill -9 743</span>
[root@study ~]# <span class="term_command">killall -9 avahi-daemon</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 186--------------------------------------------------<br/>--------------------------------------------------187--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：输出所有的核心开机时的信息</span>
[root@study ~]# <span class="term_command">dmesg | more</span>

<span class="term_hd">范例二：搜寻开机的时候，硬盘的相关信息为何？</span>
[root@study ~]# <span class="term_command">dmesg | grep -i vda</span>
[    0.758551]  vda: vda1 vda2 vda3 vda4 vda5 vda6 vda7 vda8 vda9
[    3.964134] XFS （vda2）: Mounting V4 Filesystem
<span class="term_say">....（下面省略）....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 187--------------------------------------------------<br/>--------------------------------------------------188--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">vmstat [-a] [延迟 [总计侦测次数]]</span> <span class="term_note">&lt;==CPU/内存等信息</span>
[root@study ~]# <span class="term_command">vmstat [-fs]                     </span> <span class="term_note">&lt;==内存相关</span>
[root@study ~]# <span class="term_command">vmstat [-S 单位]                 </span> <span class="term_note">&lt;==设置显示数据的单位</span>
[root@study ~]# <span class="term_command">vmstat [-d]                      </span> <span class="term_note">&lt;==与磁盘有关</span>
[root@study ~]# <span class="term_command">vmstat [-p 分区]               </span> <span class="term_note">&lt;==与磁盘有关</span>
<span class="term_say">选项与参数：
-a  ：使用 inactive/active（活跃与否） 取代 buffer/cache 的内存输出信息；
-f  ：开机到目前为止，系统复制 （fork） 的程序数；
-s  ：将一些事件 （开机至目前为止） 导致的内存变化情况列表说明；
-S  ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 Bytes 的容量；
-d  ：列出磁盘的读写总量统计表
-p  ：后面列出分区，可显示该分区的读写总量统计表</span>

<span class="term_hd">范例一：统计目前主机 CPU 状态，每秒一次，共计三次！</span>
[root@study ~]# <span class="term_command">vmstat 1 3</span>
procs ------------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd    free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1838092   1504 722216    0    0     4     1    6    9  0  0 100  0  0
 0  0      0 1838092   1504 722200    0    0     0     0   13   23  0  0 100  0  0
 0  0      0 1838092   1504 722200    0    0     0     0   25   46  0  0 100  0  0
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 188--------------------------------------------------<br/>--------------------------------------------------189--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：系统上面所有的磁盘的读写状态</span>
[root@study ~]# <span class="term_command">vmstat -d</span>
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
vda    21928      0  992587   47490   7239   2225  258449   13331      0     26
sda      395      1    3168     213      0      0       0       0      0      0
sr0        0      0       0       0      0      0       0       0      0      0
dm-0   19139      0  949575   44608   7672      0  202251   16264      0     25
dm-1     336      0    2688     327      0      0       0       0      0      0
md0      212      0    1221       0     14      0    4306       0      0      0
dm-2     218      0    9922     565     54      0    4672     128      0      0
dm-3     179      0     957     182     11      0    4306      68      0      0
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 189--------------------------------------------------<br/>--------------------------------------------------190--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">fuser [-umv] [-k [i] [-signal]] file/dir</span>
<span class="term_say">选项与参数：
-u  ：除了程序的 PID 之外，同时列出该程序的拥有者；
-m  ：后面接的那个文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效！
-v  ：可以列出每个文件与程序还有指令的完整相关性！
-k  ：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID；
-i  ：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿！
-signal：例如 -1 -15 等等，若不加的话，默认是 SIGKILL （-9） 啰！</span>

<span class="term_hd">范例一：找出目前所在目录的使用 PID/所属帐号/权限 为何？</span>
[root@study ~]# <span class="term_command">fuser -uv .</span>
                     USER        PID ACCESS COMMAND
/root:               root      13888 ..c.. （root）bash
                     root      31743 ..c.. （root）bash
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 190--------------------------------------------------<br/>--------------------------------------------------191--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例二：找到所有使用到 /proc 这个文件系统的程序吧！</span>
[root@study ~]# <span class="term_command">fuser -uv /proc</span>
/proc:               root     kernel mount （root）/proc
                     rtkit       768 .rc.. （rtkit）rtkit-daemon
<span class="term_say"># 数据量还不会很多，虽然这个目录很繁忙～没关系！我们可以继续这样作，看看其他的程序！</span>

[root@study ~]# <span class="term_command">fuser -mvu /proc</span>
                     USER        PID ACCESS COMMAND
/proc:               root     kernel mount （root）/proc
                     root          1 f.... （root）systemd
                     root          2 ...e. （root）kthreadd
<span class="term_say">.....（下面省略）.....</span>
<span class="term_say"># 有这几支程序在进行 /proc 文件系统的存取喔！这样清楚了吗？</span>

<span class="term_hd">范例三：找到所有使用到 /home 这个文件系统的程序吧！</span>
[root@study ~]# <span class="term_command">echo $$</span>
31743  <span class="term_note"># 先确认一下，自己的 bash PID 号码吧！</span>
[root@study ~]# <span class="term_command">cd /home</span>
[root@study home]# <span class="term_command">fuser -muv .</span>
                     USER        PID ACCESS COMMAND
/home:               root     kernel mount （root）/home
                     dmtsai    31535 ..c.. （dmtsai）bash
                     root      31571 ..c.. （root）passwd
                     root      31737 ..c.. （root）sudo
                     root      <span class="term_command">31743</span> ..c.. （root）bash    <span class="term_note"># 果然，自己的 PID 在啊！</span>
[root@study home]# <span class="term_command">cd ~</span>
[root@study ~]# <span class="term_command">umount /home</span>
umount: /home: target is busy.
        （In some cases useful info about processes that use
         the device is found by lsof（8） or fuser（1））
<span class="term_say"># 从 fuser 的结果可以知道，总共有五只 process 在该目录下运行，那即使 root 离开了 /home，
# 当然还是无法 umount 的！那要怎办？哈哈！可以通过如下方法一个一个删除～</span>
[root@study ~]# <span class="term_command">fuser -mki /home</span>
/home:               31535c 31571c 31737c  <span class="term_note"># 你会发现， PID 跟上面查到的相同！</span>
Kill process 31535 ? （y/N） <span class="term_note"># 这里会问你要不要删除！当然不要乱删除啦！通通取消！</span>

</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 191--------------------------------------------------<br/>--------------------------------------------------192--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例四：找到 /run 下面属于 FIFO 类型的文件，并且找出存取该文件的程序</span>
[root@study ~]# <span class="term_command">find /run -type p</span>
<span class="term_say">.....（前面省略）.....</span>
/run/systemd/sessions/165.ref
/run/systemd/sessions/1.ref
/run/systemd/sessions/c1.ref   <span class="term_note"># 随便抓个项目！就是这个好了！来测试一下！</span>

[root@study ~]# <span class="term_command">fuser -uv /run/systemd/sessions/c1.ref</span>
                     USER        PID ACCESS COMMAND
/run/systemd/sessions/c1.ref:
                     root        763 f.... （root）systemd-logind
                     root       5450 F.... （root）gdm-session-wor
<span class="term_say"># 通常系统的 FIFO 文件都会放置到 /run 下面，通过这个方式来追踪该文件被存取的 process！
# 也能够晓得系统有多忙碌啊！呵呵！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 192--------------------------------------------------<br/>--------------------------------------------------193--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">lsof [-aUu] [+d]</span>
<span class="term_say">选项与参数：
-a  ：多项数据需要“同时成立”才显示出结果时！
-U  ：仅列出 Unix like 系统的 socket 文件类型；
-u  ：后面接 username，列出该使用者相关程序所打开的文件；
+d  ：后面接目录，亦即找出某个目录下面已经被打开的文件！</span>

<span class="term_hd">范例一：列出目前系统上面所有已经被打开的文件与设备：</span>
[root@study ~]# <span class="term_command">lsof</span>
COMMAND   PID   TID    USER   FD   TYPE    DEVICE  SIZE/OFF       NODE NAME
systemd     1          root  cwd    DIR     253,0      4096        128 /
systemd     1          root  rtd    DIR     253,0      4096        128 /
systemd     1          root  txt    REG     253,0   1230920     967763 /usr/lib/systemd/systemd
<span class="term_say">....（下面省略）....</span>
<span class="term_say"># 注意到了吗？是的，在默认的情况下， lsof 会将目前系统上面已经打开的
# 文件全部列出来～所以，画面多的吓人啊！您可以注意到，第一个文件 systemd 执行的
# 地方就在根目录，而根目录，嘿嘿！所在的 inode 也有显示出来喔！</span>

<span class="term_hd">范例二：仅列出关于 root 的所有程序打开的 socket 文件</span>
[root@study ~]# <span class="term_command">lsof -u root -a -U</span>
COMMAND     PID USER   FD   TYPE             DEVICE SIZE/OFF   NODE NAME
systemd       1 root    3u  unix 0xffff8800b7756580      0t0  13715 socket
systemd       1 root    7u  unix 0xffff8800b7755a40      0t0   1902 @/org/freedesktop/systemd1/notify
systemd       1 root    9u  unix 0xffff8800b7756d00      0t0   1903 /run/systemd/private
<span class="term_say">.....（中间省略）.....</span>
Xorg       4496 root    1u  unix 0xffff8800ab107480      0t0  25981 @/tmp/.X11-unix/X0
Xorg       4496 root    3u  unix 0xffff8800ab107840      0t0  25982 /tmp/.X11-unix/X0
Xorg       4496 root   16u  unix 0xffff8800b7754f00      0t0  25174 @/tmp/.X11-unix/X0
<span class="term_say">.....（下面省略）.....</span>
<span class="term_say"># 注意到那个 -a 吧！如果你分别输入 lsof -u root 及 lsof -U ，会有啥信息？
# 使用 lsof -u root -U 及 lsof -u root -a -U ，呵呵！都不同啦！
# -a 的用途就是在解决同时需要两个项目都成立时啊！ ^_^</span>

<span class="term_hd">范例三：请列出目前系统上面所有的被启动的周边设备</span>
[root@study ~]# <span class="term_command">lsof +d /dev</span>
COMMAND     PID           USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
systemd       1           root    0u   CHR                1,3      0t0 1028 /dev/null
systemd       1           root    1u   CHR                1,3      0t0 1028 /dev/null
<span class="term_say"># 看吧！因为设备都在 /dev 里面嘛！所以啰，使用搜寻目录即可啊！</span>

<span class="term_hd">范例四：秀出属于 root 的 bash 这支程序所打开的文件</span>
[root@study ~]# <span class="term_command">lsof -u root | grep bash</span>
ksmtuned    781 root  txt    REG    253,0    960384   33867220 /usr/bin/bash
bash      13888 root  cwd    DIR    253,0      4096   50331777 /root
bash      13888 root  rtd    DIR    253,0      4096        128 /
bash      13888 root  txt    REG    253,0    960384   33867220 /usr/bin/bash
bash      13888 root  mem    REG    253,0 106065056   17331169 /usr/lib/locale/locale-archive
<span class="term_say">....（下面省略）....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 193--------------------------------------------------<br/>--------------------------------------------------194--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">pidof [-sx] program_name</span>
<span class="term_say">选项与参数：
-s  ：仅列出一个 PID 而不列出所有的 PID
-x  ：同时列出该 program name 可能的 PPID 那个程序的 PID</span>

<span class="term_hd">范例一：列出目前系统上面 systemd 以及 rsyslogd 这两个程序的 PID</span>
[root@study ~]# <span class="term_command">pidof systemd rsyslogd</span>
1 742
<span class="term_say"># 理论上，应该会有两个 PID 才对。上面的显示也是出现了两个 PID 喔。
# 分别是 systemd 及 rsyslogd 这两支程序的 PID 啦。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 194--------------------------------------------------<br/>--------------------------------------------------195--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">sestatus [-vb]</span>
<span class="term_say">选项与参数：
-v  ：检查列于 /etc/sestatus.conf 内的文件与程序的安全性本文内容；
-b  ：将目前政策的规则布林值列出，亦即某些规则 （rule） 是否要启动 （0/1） 之意；</span>

<span class="term_hd">范例一：列出目前的 SELinux 使用哪个政策 （Policy）？</span>
[root@study ~]# <span class="term_command">sestatus</span>
SELinux status:                 enabled           <span class="term_note">&lt;==是否启动 SELinux</span>
SELinuxfs mount:                /sys/fs/selinux   <span class="term_note">&lt;==SELinux 的相关文件数据挂载点</span>
SELinux root directory:         /etc/selinux      <span class="term_note">&lt;==SELinux 的根目录所在</span>
Loaded policy name:             targeted          <span class="term_note">&lt;==目前的政策为何？</span>
Current mode:                   enforcing         <span class="term_note">&lt;==目前的模式</span>
Mode from config file:          enforcing         <span class="term_note">&lt;==目前配置文件内规范的 SELinux 模式</span>
Policy MLS status:              enabled           <span class="term_note">&lt;==是否含有 MLS 的模式机制</span>
Policy deny_unknown status:     allowed           <span class="term_note">&lt;==是否默认抵挡未知的主体程序</span>
Max kernel policy version:      28 
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 195--------------------------------------------------<br/>--------------------------------------------------196--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">setenforce [0|1]</span>
<span class="term_say">选项与参数：
0 ：转成 permissive 宽容模式；
1 ：转成 Enforcing 强制模式</span>

<span class="term_hd">范例一：将 SELinux 在 Enforcing 与 permissive 之间切换与观察</span>
[root@study ~]# <span class="term_command">setenforce 0</span>
[root@study ~]# <span class="term_command">getenforce</span>
Permissive
[root@study ~]# <span class="term_command">setenforce 1</span>
[root@study ~]# <span class="term_command">getenforce</span>
Enforcing
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 196--------------------------------------------------<br/>--------------------------------------------------197--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">getsebool [-a] [规则的名称]</span>
<span class="term_say">选项与参数：
-a  ：列出目前系统上面的所有 SELinux 规则的布林值为打开或关闭值</span>

<span class="term_hd">范例一：查询本系统内所有的布林值设置状况</span>
[root@study ~]# <span class="term_command">getsebool -a</span>
abrt_anon_write --&gt; off
abrt_handle_event --&gt; off
<span class="term_say">....（中间省略）....</span>
cron_can_relabel --&gt; off                 <span class="term_note"># 这个跟 cornd 比较有关！</span>
cron_userdomain_transition --&gt; on
<span class="term_say">....（中间省略）....</span>
httpd_enable_homedirs --&gt; off            <span class="term_note"># 这当然就是跟网页，亦即 http 有关的啰！</span>
<span class="term_say">....（下面省略）....
# 这么多的 SELinux 规则喔！每个规则后面都列出现在是允许放行还是不许放行的布林值喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 197--------------------------------------------------<br/>--------------------------------------------------198--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">seinfo [-Atrub]</span>
<span class="term_say">选项与参数：
-A  ：列出 SELinux 的状态、规则布林值、身份识别、角色、类别等所有信息
-u  ：列出 SELinux 的所有身份识别 （user） 种类
-r  ：列出 SELinux 的所有角色 （role） 种类
-t  ：列出 SELinux 的所有类别 （type） 种类
-b  ：列出所有规则的种类 （布林值）</span>

<span class="term_hd">范例一：列出 SELinux 在此政策下的统计状态</span>
[root@study ~]# <span class="term_command">seinfo</span>
Statistics for policy file: /sys/fs/selinux/policy
Policy Version &amp; Type: v.28 （binary, mls）

   Classes:            83    Permissions:       255
   Sensitivities:       1    Categories:       1024
   <span class="term_command">Types:            4620</span>    Attributes:        357
   Users:               8    Roles:              14
   <span class="term_command">Booleans:          295</span>    Cond. Expr.:       346
   Allow:          102249    Neverallow:          0
   Auditallow:        160    Dontaudit:        8413
   Type_trans:      16863    Type_change:        74
   Type_member:        35    Role allow:         30
   Role_trans:        412    Range_trans:      5439
<span class="term_say">....（下面省略）....
# 从上面我们可以看到这个政策是 targeted ，此政策的安全本文类别有 4620 个；
# 而各种 SELinux 的规则 （Booleans） 共制订了 295 条！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 198--------------------------------------------------<br/>--------------------------------------------------199--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">sesearch [-A] [-s 主体类别] [-t 目标类别] [-b 布林值]</span>
<span class="term_say">选项与参数：
-A  ：列出后面数据中，允许“读取或放行”的相关数据
-t  ：后面还要接类别，例如 -t httpd_t
-b  ：后面还要接SELinux的规则，例如 -b httpd_enable_ftp_server</span>

<span class="term_hd">范例一：找出 crond_t 这个主体程序能够读取的文件 SELinux type</span>
[root@study ~]# <span class="term_command">sesearch -A -s crond_t | grep spool</span>
   allow <span class="term_command">crond_t system_cron_spool_t : file</span> { ioctl read write create getattr ..
   allow <span class="term_command">crond_t system_cron_spool_t : dir</span> { ioctl read getattr lock search op..
   allow <span class="term_command">crond_t user_cron_spool_t : file</span> { ioctl read write create getattr se..
   allow <span class="term_command">crond_t user_cron_spool_t : dir</span> { ioctl read write getattr lock add_n..
   allow <span class="term_command">crond_t user_cron_spool_t : lnk_file</span> { read getattr } ;
<span class="term_say"># allow 后面接主体程序以及文件的 SELinux type，上面的数据是撷取出来的，
# 意思是说，crond_t 可以读取 system_cron_spool_t 的文件/目录类型～等等！</span>

<span class="term_hd">范例二：找出 crond_t 是否能够读取 /etc/cron.d/checktime 这个我们自订的配置文件？</span>
[root@study ~]# <span class="term_command">ll -Z /etc/cron.d/checktime</span>
-rw-r--r--. root root unconfined_u:object_r:<span class="term_command">admin_home_t</span>:s0 /etc/cron.d/checktime
<span class="term_say"># 两个重点，一个是 SELinux type 为 admin_home_t，一个是文件 （file）</span>

[root@study ~]# <span class="term_command">sesearch -A -s crond_t | grep admin_home_t</span>
   allow domain admin_home_t : dir { getattr search open } ;
   allow domain admin_home_t : lnk_file { read getattr } ;
   allow crond_t admin_home_t : dir { ioctl read getattr lock search open } ;
   allow crond_t admin_home_t : lnk_file { read getattr } ;
<span class="term_say"># 仔细看！看仔细～虽然有 crond_t admin_home_t 存在，但是这是总体的信息，
# 并没有针对某些规则的寻找～所以还是不确定 checktime 能否被读取。但是，基本上就是 SELinux
# type 出问题～因此才会无法读取的！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 199--------------------------------------------------<br/>--------------------------------------------------200--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">semanage boolean -l | grep httpd_enable_homedirs</span>
SELinux boolean                State  Default Description
httpd_enable_homedirs          （off  ,  off）  Allow httpd to enable homedirs
<span class="term_say"># httpd_enable_homedirs 的功能是允许 httpd 程序去读取使用者主文件夹的意思～</span>

[root@study ~]# <span class="term_command">sesearch -A -b httpd_enable_homedirs</span>
<span class="term_hd">范例三：列出 httpd_enable_homedirs 这个规则当中，主体程序能够读取的文件 SELinux type</span>
Found 43 semantic av rules:
   allow httpd_t home_root_t : dir { ioctl read getattr lock search open } ;
   allow httpd_t home_root_t : lnk_file { read getattr } ;
   allow httpd_t user_home_type : dir { getattr search open } ;
   allow httpd_t user_home_type : lnk_file { read getattr } ;
<span class="term_say">....（后面省略）....
# 从上面的数据才可以理解，在这个规则中，主要是放行 httpd_t 能否读取使用者主文件夹的文件！
# 所以，如果这个规则没有启动，基本上， httpd_t 这种程序就无法读取使用者主文件夹下的文件！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 200--------------------------------------------------<br/>--------------------------------------------------201--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">setsebool  [-P]  “规则名称” [0|1]</span>
<span class="term_say">选项与参数：
-P  ：直接将设置值写入配置文件，该设置数据未来会生效的！</span>

<span class="term_hd">范例一：查询 httpd_enable_homedirs 这个规则的状态，并且修改这个规则成为不同的布林值</span>
[root@study ~]# <span class="term_command">getsebool httpd_enable_homedirs</span>
httpd_enable_homedirs --&gt; <span class="term_command">off</span>  <span class="term_note">&lt;==结果是 off ，依题意给他启动看看！</span>

[root@study ~]# <span class="term_command">setsebool -P httpd_enable_homedirs 1</span> <span class="term_note"># 会跑很久很久！请耐心等待！</span>
[root@study ~]# <span class="term_command">getsebool httpd_enable_homedirs</span>
httpd_enable_homedirs --&gt; <span class="term_command">on</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 201--------------------------------------------------<br/>--------------------------------------------------202--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">chcon [-R] [-t type] [-u user] [-r role] 文件</span>
[root@study ~]# <span class="term_command">chcon [-R] --reference=范例档 文件</span>
<span class="term_say">选项与参数：
-R  ：连同该目录下的次目录也同时修改；
-t  ：后面接安全性本文的类型字段！例如 httpd_sys_content_t ；
-u  ：后面接身份识别，例如 system_u； （不重要）
-r  ：后面街角色，例如 system_r；     （不重要）
-v  ：若有变化成功，请将变动的结果列出来
--reference=范例档：拿某个文件当范例来修改后续接的文件的类型！</span>

<span class="term_hd">范例一：查询一下 /etc/hosts 的 SELinux type，并将该类型套用到 /etc/cron.d/checktime 上</span>
[root@study ~]# <span class="term_command">ll -Z /etc/hosts</span>
-rw-r--r--. root root system_u:object_r:<span class="term_command">net_conf_t</span>:s0  /etc/hosts
[root@study ~]# <span class="term_command">chcon -v -t net_conf_t /etc/cron.d/checktime</span>
changing security context of ‘/etc/cron.d/checktime’
[root@study ~]# <span class="term_command">ll -Z /etc/cron.d/checktime</span>
-rw-r--r--. root root unconfined_u:object_r:<span class="term_command">net_conf_t</span>:s0 /etc/cron.d/checktime

<span class="term_hd">范例二：直接以 /etc/shadow SELinux type 套用到 /etc/cron.d/checktime 上！</span>
[root@study ~]# <span class="term_command">chcon -v --reference=/etc/shadow /etc/cron.d/checktime</span>
[root@study ~]# <span class="term_command">ll -Z /etc/shadow /etc/cron.d/checktime</span>
-rw-r--r--. root root system_u:object_r:shadow_t:s0    /etc/cron.d/checktime
----------. root root system_u:object_r:shadow_t:s0    /etc/shadow
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 202--------------------------------------------------<br/>--------------------------------------------------203--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">restorecon [-Rv] 文件或目录</span>
<span class="term_say">选项与参数：
-R  ：连同次目录一起修改；
-v  ：将过程显示到屏幕上</span>

<span class="term_hd">范例三：将 /etc/cron.d/ 下面的文件通通恢复成默认的 SELinux type！</span>
[root@study ~]# <span class="term_command">restorecon -Rv /etc/cron.d</span>
restorecon reset /etc/cron.d/checktime context system_u:object_r:<span class="term_command">shadow_t</span>:s0-&gt;
system_u:object_r:<span class="term_command">system_cron_spool_t</span>:s0
<span class="term_say"># 上面这两行其实是同一行喔！表示将 checktime 由 shadow_t 改为 system_cron_spool_t</span>

<span class="term_hd">范例四：重新启动 crond 看看有没有正确启动 checktime 啰！？</span>
[root@study ~]# <span class="term_command">systemctl restart crond</span>
[root@study ~]# <span class="term_command">tail /var/log/cron</span>
<span class="term_say"># 再去瞧瞧这个 /var/log/cron 的内容，应该就没有错误讯息了</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 203--------------------------------------------------<br/>--------------------------------------------------204--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">semanage {login|user|port|interface|fcontext|translation} -l</span>
[root@study ~]# <span class="term_command">semanage fcontext -{a|d|m} [-frst] file_spec</span>
<span class="term_say">选项与参数：
fcontext ：主要用在安全性本文方面的用途， -l 为查询的意思；
-a ：增加的意思，你可以增加一些目录的默认安全性本文类型设置；
-m ：修改的意思；
-d ：删除的意思。</span>

<span class="term_hd">范例一：查询一下 /etc /etc/cron.d 的默认 SELinux type 为何？</span>
[root@study ~]# <span class="term_command">semanage fcontext -l | grep -E '^/etc |^/etc/cron'</span>
SELinux fcontext         type               Context
/etc                     all files          system_u:object_r:<span class="term_command">etc_t</span>:s0
/etc/cron\.d（/.*）?       all files          system_u:object_r:<span class="term_command">system_cron_spool_t</span>:s0
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 204--------------------------------------------------<br/>--------------------------------------------------205--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">systemctl [command] [unit]</span>
<span class="term_say">command 主要有：
start     ：立刻启动后面接的 unit
stop      ：立刻关闭后面接的 unit
restart   ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思
reload    ：不关闭后面接的 unit 的情况下，重新载入配置文件，让设置生效
enable    ：设置下次开机时，后面接的 unit 会被启动
disable   ：设置下次开机时，后面接的 unit 不会被启动
status    ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机默认执行否、登录等信息等！
is-active ：目前有没有正在运行中
is-enable ：开机时有没有默认要启用这个 unit</span>

<span class="term_hd">范例一：看看目前 atd 这个服务的状态为何？</span>
[root@study ~]# <span class="term_command">systemctl status atd.service</span>
atd.service - Job spooling tools
   <span class="term_command">Loaded: loaded （/usr/lib/systemd/system/atd.service; enabled）
   Active: active （running）</span> since Mon 2015-08-10 19:17:09 CST; 5h 42min ago
 Main PID: 1350 （atd）
   CGroup: /system.slice/atd.service
           └─1350 /usr/sbin/atd -f

Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.
<span class="term_say"># 重点在第二、三行喔～
# Loaded：这行在说明，开机的时候这个 unit 会不会启动，enabled 为开机启动，disabled 开机不会启动
# Active：现在这个 unit 的状态是正在执行 （running） 或没有执行 （dead）
# 后面几行则是说明这个 unit 程序的 PID 状态以及最后一行显示这个服务的登录文件信息！
# 登录文件信息格式为：“时间” “讯息发送主机” “哪一个服务的讯息” “实际讯息内容”
# 所以上面的显示讯息是：这个 atd 默认开机就启动，而且现在正在运行的意思！</span>

<span class="term_hd">范例二：正常关闭这个 atd 服务</span>
[root@study ~]# <span class="term_command">systemctl stop atd.service</span>
[root@study ~]# <span class="term_command">systemctl status atd.service</span>
atd.service - Job spooling tools
   Loaded: loaded （/usr/lib/systemd/system/atd.service; <span class="term_command">enabled</span>）
   <span class="term_command">Active: inactive （dead）</span> since Tue 2015-08-11 01:04:55 CST; 4s ago
  Process: 1350 ExecStart=/usr/sbin/atd -f $OPTS （code=exited, status=0/SUCCESS）
 Main PID: 1350 （code=exited, status=0/SUCCESS）

Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.
<span class="term_command">Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopping Job spooling tools...
Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopped Job spooling tools.</span>
<span class="term_say"># 目前这个 unit 下次开机还是会启动，但是现在是没在运行的状态中！同时，
# 最后两行为新增加的登录讯息，告诉我们目前的系统状态喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 205--------------------------------------------------<br/>--------------------------------------------------206--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">systemctl [command] [--type=TYPE] [--all]</span>
<span class="term_say">command:
    list-units      ：依据 unit 列出目前有启动的 unit。若加上 --all 才会列出没启动的。
    list-unit-files ：依据 /usr/lib/systemd/system/ 内的文件，将所有文件列表说明。
--type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等</span>

<span class="term_hd">范例一：列出系统上面有启动的 unit</span>
[root@study ~]# <span class="term_command">systemctl</span>
UNIT                      LOAD   ACTIVE SUB       DESCRIPTION
proc-sys-fs-binfmt_mis... loaded active waiting   Arbitrary Executable File Formats File System
sys-devices-pc...:0:1:... loaded active plugged   QEMU_HARDDISK
sys-devices-pc...0:1-0... loaded active plugged   QEMU_HARDDISK
sys-devices-pc...0:0-1... loaded active plugged   QEMU_DVD-ROM
<span class="term_say">.....（中间省略）.....</span>
vsftpd.service            loaded active running   Vsftpd ftp daemon
<span class="term_say">.....（中间省略）.....</span>
cups.socket               loaded failed failed    CUPS Printing Service Sockets
<span class="term_say">.....（中间省略）.....</span>
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

<span class="term_command">141 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</span>
<span class="term_say"># 列出的项目中，主要的意义是：
# UNIT   ：项目的名称，包括各个 unit 的类别 （看扩展名）
# LOAD   ：开机时是否会被载入，默认 systemctl 显示的是有载入的项目而已喔！
# ACTIVE ：目前的状态，须与后续的 SUB 搭配！就是我们用 systemctl status 观察时，active 的项目！
# DESCRIPTION ：详细描述啰
# cups 比较有趣，因为刚刚被我们玩过，所以 ACTIVE 竟然是 failed 的喔！被玩死了！ ^_^
# 另外，systemctl 都不加参数，其实默认就是 list-units 的意思！</span>

<span class="term_hd">范例二：列出所有已经安装的 unit 有哪些？</span>
[root@study ~]# <span class="term_command">systemctl list-unit-files</span>
UNIT FILE                                   STATE
proc-sys-fs-binfmt_misc.automount           static
dev-hugepages.mount                         static
dev-mqueue.mount                            static
proc-fs-nfsd.mount                          static
<span class="term_say">.....（中间省略）.....</span>
systemd-tmpfiles-clean.timer                static

336 unit files listed.
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 206--------------------------------------------------<br/>--------------------------------------------------207--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">systemctl list-units --type=service --all</span>
<span class="term_say"># 只剩下 *.service 的项目才会出现喔！</span>

<span class="term_hd">范例一：查询系统上是否有以 cpu 为名的服务？</span>
[root@study ~]# <span class="term_command">systemctl list-units --type=service --all | grep cpu</span>
cpupower.service  loaded inactive dead    Configure CPU power related settings
<span class="term_say"># 确实有喔！可以改变 CPU 电源管理机制的服务哩！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 207--------------------------------------------------<br/>--------------------------------------------------208--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">systemctl [command] [unit.target]</span>
<span class="term_say">选项与参数：
command:
    get-default ：取得目前的 target 
    set-default ：设置后面接的 target 成为默认的操作模式
    isolate     ：切换到后面接的模式</span>

<span class="term_hd">范例一：我们的测试机器默认是图形界面，先观察是否真为图形模式，再将默认模式转为文字界面</span>
[root@study ~]# <span class="term_command">systemctl get-default </span>
graphical.target  <span class="term_note"># 果然是图形界面喔！</span>

[root@study ~]# <span class="term_command">systemctl set-default multi-user.target</span>
[root@study ~]# <span class="term_command">systemctl get-default </span>
multi-user.target

<span class="term_hd">范例二：在不重新开机的情况下，将目前的操作环境改为纯文本模式，关掉图形界面</span>
[root@study ~]# <span class="term_command">systemctl isolate multi-user.target</span>

<span class="term_hd">范例三：若需要重新取得图形界面呢？</span>
[root@study ~]# <span class="term_command">systemctl isolate graphical.target</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 208--------------------------------------------------<br/>--------------------------------------------------209--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">systemctl list-dependencies [unit] [--reverse]</span>
<span class="term_say">选项与参数：
--reverse ：反向追踪谁使用这个 unit 的意思！</span>

<span class="term_hd">范例一：列出目前的 target 环境下，用到什么特别的 unit </span>
[root@study ~]# <span class="term_command">systemctl get-default</span>
multi-user.target

[root@study ~]# <span class="term_command">systemctl list-dependencies</span>
default.target
├─abrt-ccpp.service
├─abrt-oops.service
├─vsftpd.service
├─basic.target
│ ├─alsa-restore.service
│ ├─alsa-state.service
<span class="term_say">.....（中间省略）.....</span>
│ ├─sockets.target
│ │ ├─avahi-daemon.socket
│ │ ├─dbus.socket
<span class="term_say">.....（中间省略）.....</span>
│ ├─sysinit.target
│ │ ├─dev-hugepages.mount
│ │ ├─dev-mqueue.mount
<span class="term_say">.....（中间省略）.....</span>
│ └─timers.target
│   └─systemd-tmpfiles-clean.timer
├─getty.target
│ └─getty@tty1.service
└─remote-fs.target
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 209--------------------------------------------------<br/>--------------------------------------------------210--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">原始文件：执行服务名称@.service
可执行文件案：执行服务名称@范例名称.service
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 210--------------------------------------------------<br/>--------------------------------------------------211--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">语法：英文周名  YYYY-MM-DD  HH:MM:SS
范例：Thu       2015-08-13  13:40:00
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 211--------------------------------------------------<br/>--------------------------------------------------212--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">logrotate [-vf] logfile</span>
<span class="term_say">选项与参数：
-v  ：启动显示模式，会显示 logrotate 运行的过程喔！
-f  ：不论是否符合配置文件的数据，强制每个登录文件都进行 rotate 的动作！</span>

<span class="term_hd">范例一：执行一次 logrotate 看看整个流程为何？</span>
[root@study ~]# <span class="term_command">logrotate -v /etc/logrotate.conf</span>
reading config file /etc/logrotate.conf <span class="term_note">&lt;==读取主要配置文件</span>
including /etc/logrotate.d              <span class="term_note">&lt;==调用外部的设置</span>
reading config file chrony              <span class="term_note">&lt;==就是外部设置啊！</span>
<span class="term_say">....（中间省略）....</span>
Handling 18 logs                        <span class="term_note">&lt;==共有 18 个登录文件被记录</span>
<span class="term_say">....（中间省略）....</span>
rotating pattern: /var/log/cron
/var/log/maillog
/var/log/messages
/var/log/secure
/var/log/spooler
 weekly （52 rotations）
empty log files are not rotated, old logs are removed
considering log /var/log/cron
  log does not need rotating
considering log /var/log/maillog
  log does not need rotating
considering log /var/log/messages       <span class="term_note">&lt;==开始处理 messages</span>
  log does not need rotating            <span class="term_note">&lt;==因为时间未到，不需要更动！</span>
<span class="term_say">....（下面省略）....</span>

<span class="term_hd">范例二：强制进行 logrotate 的动作</span>
[root@study ~]# <span class="term_command">logrotate -vf /etc/logrotate.conf</span>
<span class="term_say">....（前面省略）....</span>
rotating log /var/log/messages, log-&gt;rotateCount is 52
dateext suffix '-20150820'
glob pattern '-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'
compressing log with: /bin/gzip
<span class="term_say">....（下面省略）....</span>
<span class="term_say"># 看到否？整个 rotate 的动作就是这样一步一步进行的～</span>

[root@study ~]# <span class="term_command">ll /var/log/messages*; lsattr /var/log/messages</span>
-rw-------. 1 root root    143 Aug 20 01:45 /var/log/messages
-rw-------. 1 root root 167125 Aug 20 01:40 /var/log/messages-20150820
-----a---------- /var/log/messages  <span class="term_note">&lt;==主动加入 a 的隐藏属性啰！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 212--------------------------------------------------<br/>--------------------------------------------------213--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">journalctl [-nrpf] [--since TIME] [--until TIME] _optional</span>
<span class="term_say">选项与参数：
默认会秀出全部的 log 内容，从旧的输出到最新的讯息
-n  ：秀出最近的几行的意思～找最新的信息相当有用
-r  ：反向输出，从最新的输出到最旧的数据
-p  ：秀出后面所接的讯息重要性排序！请参考前一小节的 rsyslogd 信息
-f  ：类似 tail -f 的功能，持续显示 journal 日志的内容（实时监测时相当有帮助！）
--since --until：设置开始与结束的时间，让在该期间的数据输出而已
_SYSTEMD_UNIT=unit.service ：只输出 unit.service 的信息而已
_COMM=bash ：只输出与 bash 有关的信息
_PID=pid   ：只输出 PID 号码的信息
_UID=uid   ：只输出 UID 为 uid 的信息
SYSLOG_FACILITY=[0-23] ：使用 syslog.h 规范的服务相对序号来调用出正确的数据！</span>

<span class="term_hd">范例一：秀出目前系统中所有的 journal 日志数据</span>
[root@study ~]# <span class="term_command">journalctl</span>
-- Logs <span class="term_command">begin at Mon 2015-08-17 18:37:52 CST, end at Wed 2015-08-19 00:01:01 CST.</span> --
Aug 17 18:37:52 study.centos.vbird systemd-journal[105]: Runtime journal is using 8.0M （max 
 142.4M, leaving 213.6M of free 1.3G, current limit 142.4M）.
Aug 17 18:37:52 study.centos.vbird systemd-journal[105]: Runtime journal is using 8.0M （max
 142.4M, leaving 213.6M of free 1.3G, current limit 142.4M）.
Aug 17 18:37:52 study.centos.vbird kernel: Initializing cgroup subsys cpuset
Aug 17 18:37:52 study.centos.vbird kernel: Initializing cgroup subsys cpu
<span class="term_say">.....（中间省略）.....</span>
Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19268]: finished 0anacron
Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19270]: starting 0yum-hourly.cron
Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19274]: finished 0yum-hourly.cron
<span class="term_say"># 从这次开机以来的所有数据都会显示出来！通过 less 一页页翻动给管理员查阅！数据量相当大！</span>

<span class="term_hd">范例二：（1）仅显示出 2015/08/18 整天以及（2）仅今天及（3）仅昨天的日志数据内容</span>
[root@study ~]# <span class="term_command">journalctl --since "2015-08-18 00:00:00" --until "2015-08-19 00:00:00"</span>
[root@study ~]# <span class="term_command">journalctl --since today</span>
[root@study ~]# <span class="term_command">journalctl --since yesterday --until today</span>

<span class="term_hd">范例三：只找出 crond.service 的数据，同时只列出最新的 10 笔即可</span>
[root@study ~]# <span class="term_command">journalctl _SYSTEMD_UNIT=crond.service -n 10</span>

<span class="term_hd">范例四：找出 su, login 执行的登录文件，同时只列出最新的 10 笔即可</span>
[root@study ~]# <span class="term_command">journalctl _COMM=su _COMM=login -n 10</span>

<span class="term_hd">范例五：找出讯息严重等级为错误 （error） 的讯息！</span>
[root@study ~]# <span class="term_command">journalctl -p err</span>

<span class="term_hd">范例六：找出跟登录服务 （auth, authpriv） 有关的登录文件讯息</span>
[root@study ~]# <span class="term_command">journalctl SYSLOG_FACILITY=4 SYSLOG_FACILITY=10</span>
<span class="term_say"># 更多关于 syslog_facility 的数据，请参考 18.2.1 小节的内容啰！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 213--------------------------------------------------<br/>--------------------------------------------------214--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">logger [-p 服务名称.等级] "讯息"</span>
<span class="term_say">选项与参数：
服务名称.等级 ：这个项目请参考 rsyslogd 的本章后续小节的介绍；</span>

<span class="term_hd">范例一：指定一下，让 dmtsai 使用 logger 来传送数据到登录文件内</span>
[root@study ~]# <span class="term_command">logger -p user.info "I will check logger command"</span>
[root@study ~]# <span class="term_command">journalctl SYSLOG_FACILITY=1 -n 3</span>
-- Logs begin at Mon 2015-08-17 18:37:52 CST, end at Wed 2015-08-19 18:03:17 CST. --
Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29710]: starting 0yum-hourly.cron
Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29714]: finished 0yum-hourly.cron
<span class="term_command">Aug 19 18:03:17 study.centos.vbird dmtsai[29753]: I will check logger command</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 214--------------------------------------------------<br/>--------------------------------------------------215--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">depmod [-Ane]</span>
<span class="term_say">选项与参数：
-A  ：不加任何参数时， depmod 会主动的去分析目前核心的模块，并且重新写入
      /lib/modules/$（uname -r）/modules.dep 当中。若加入 -A 参数时，则 depmod
      会去搜寻比 modules.dep 内还要新的模块，如果真找到新模块，才会更新。
-n  ：不写入 modules.dep ，而是将结果输出到屏幕上（standard out）；
-e  ：显示出目前已载入的不可执行的模块名称</span>

<span class="term_hd">范例一：若我做好一个网卡驱动程序，文件名为 a.ko，该如何更新核心相依性？</span>
[root@study ~]# <span class="term_command">cp a.ko /lib/modules/$（uname -r）/kernel/drivers/net</span>
[root@study ~]# <span class="term_command">depmod</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 215--------------------------------------------------<br/>--------------------------------------------------216--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">modinfo [-adln] [module_name|filename]</span>
<span class="term_say">选项与参数：
-a  ：仅列出作者名称；
-d  ：仅列出该 modules 的说明 （description）；
-l  ：仅列出授权 （license）；
-n  ：仅列出该模块的详细路径。</span>

<span class="term_hd">范例一：由上个表格当中，请列出 drm 这个模块的相关信息：</span>
[root@study ~]# <span class="term_command">modinfo drm</span>
<span class="term_command">filename:       /lib/modules/3.10.0-229.el7.x86_64/kernel/drivers/gpu/drm/drm.ko</span>
license:        GPL and additional rights
<span class="term_command">description:    DRM shared core routines</span>
author:         Gareth Hughes, Leif Delgass, José Fonseca, Jon Smirl
rhelversion:    7.1
srcversion:     66683E37FDD905C9FFD7931
depends:        i2c-core
intree:         Y
vermagic:       3.10.0-229.el7.x86_64 SMP mod_unload modversions
signer:         CentOS Linux kernel signing key
sig_key:        A6:2A:0E:1D:6A:6E:48:4E:9B:FD:73:68:AF:34:08:10:48:E5:35:E5
sig_hashalgo:   sha256
parm:           edid_fixup:Minimum number of valid EDID header Bytes （0-8, default 6） （int）
<span class="term_say">.....（下面省略）.....</span>
<span class="term_say"># 可以看到这个模块的来源，以及该模块的简易说明！</span>

<span class="term_hd">范例二：我有一个模块名称为 a.ko ，请问该模块的信息为？</span>
[root@study ~]# <span class="term_command">modinfo a.ko</span>
<span class="term_say">....（省略）....</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 216--------------------------------------------------<br/>--------------------------------------------------217--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">insmod [/full/path/module_name] [parameters]</span>

<span class="term_hd">范例一：请尝试载入 cifs.ko 这个“文件系统”模块</span>
[root@study ~]# <span class="term_command">insmod /lib/modules/$（uname -r）/kernel/fs/fat/fat.ko</span>
[root@study ~]# <span class="term_command">lsmod | grep fat</span>
fat                    65913  0
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 217--------------------------------------------------<br/>--------------------------------------------------218--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">rmmod [-fw] module_name</span>
<span class="term_say">选项与参数：
-f  ：强制将该模块移除掉，不论是否正被使用；</span>

<span class="term_hd">范例一：将刚刚载入的 fat 模块移除！</span>
[root@study ~]# <span class="term_command">rmmod fat</span>

<span class="term_hd">范例二：请载入 vfat 这个“文件系统”模块</span>
[root@study ~]# <span class="term_command">insmod /lib/modules/$（uname -r）/kernel/fs/vfat/vfat.ko</span>
insmod: ERROR: could not load module /lib/modules/3.10.0-229.el7.x86_64/kernel/fs/vfat/
 vfat.ko: No such file or directory
<span class="term_say"># 无法载入 vfat 这个模块啊！伤脑筋！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 218--------------------------------------------------<br/>--------------------------------------------------219--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">modprobe [-cfr] module_name</span>
<span class="term_say">选项与参数：
-c  ：列出目前系统所有的模块！（更详细的代号对应表）
-f  ：强制载入该模块；
-r  ：类似 rmmod ，就是移除某个模块啰～</span>

<span class="term_hd">范例一：载入 vfat 模块</span>
[root@study ~]# <span class="term_command">modprobe vfat</span>
<span class="term_say"># 很方便吧！不需要知道完整的模块文件名，这是因为该完整文件名已经记录到
# /lib/modules/`uname -r`/modules.dep 当中的缘故啊！如果要移除的话：</span>
[root@study ~]# <span class="term_command">modprobe -r vfat</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 219--------------------------------------------------<br/>--------------------------------------------------220--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">dracut [-fv] [--add-drivers 列表] initramfs文件名 核心版本</span>
<span class="term_say">选项与参数：
-f   ：强迫编译出 initramfs ，如果 initramfs 文件已经存在，则覆盖掉旧文件
-f   ：显示 dracut 的运行过程
--add-drivers 列表：在原本的默认核心模块中，增加某些你想要的模块！模块位于核心所在目录
                    /lib/modules/$（uname -r）/kernel/*
initramfs文件名     ：就是你需要的文件名！开头最好就是 initramfs，后面接版本与功能
核心版本          ：默认当然是目前运行中的核心版本，不过你也可以手动输入其他不同版本！
其实 dracut 还有很多功能，例如下面的几个参数也可以参考看看：
--modules  ：将 dracut 所提供的开机所需模块 （核心核模块） 载入，可用模块在下面的目录内
             /usr/lib/dracut/modules.d/
--gzip|--bzip2|--xz：尝试使用哪一种压缩方式来进行 initramfs 压缩。默认使用 gzip 喔！
--filesystems ：加入某些额外的文件系统支持！</span>

<span class="term_hd">范例一：以 dracut 的默认功能创建一个 initramfs 虚拟磁盘文件</span>
[root@study ~]# <span class="term_command">dracut -v initramfs-test.img $（uname -r）</span>
Executing: /sbin/dracut -v initramfs-test.img 3.10.0-229.el7.x86_64
*** Including module: bash ***                     <span class="term_note"># 先载入 dracut 本身的模块支持</span>
*** Including module: nss-softokn ***
*** Including modules done ***
<span class="term_say">.....（中间省略）.....</span> <span class="term_note"># 下面两行在处理核心模块</span>
*** Installing kernel module dependencies and firmware ***
*** Installing kernel module dependencies and firmware done ***
<span class="term_say">.....（中间省略）.....</span>
*** Generating early-microcode cpio image ***      <span class="term_note"># 创建微指令集</span>
*** Constructing GenuineIntel.bin ****
*** Store current command line parameters ***
*** Creating image file ***                        <span class="term_note"># 开始创建 initramfs 啰！</span>
*** Creating image file done ***

<span class="term_hd">范例二：额外加入 e1000e 网卡驱动与 ext4/nfs 文件系统在新的 initramfs 内</span>
[root@study ~]# <span class="term_command">dracut -v --add-drivers "e1000e" --filesystems "ext4 nfs" \</span>
&gt; <span class="term_command"> initramfs-new.img $（uname -r）</span>
[root@study ~]# <span class="term_command">lsinitrd initramfs-new.img  | grep -E '（e1000|ext4|nfs）'</span>
 usr/lib/modules/3.10.0-229.el7.x86_64/kernel/drivers/net/ethernet/intel/e1000e
 usr/lib/modules/3.10.0-229.el7.x86_64/kernel/drivers/net/ethernet/intel/e1000e/e1000e.ko
 usr/lib/modules/3.10.0-229.el7.x86_64/kernel/fs/ext4
 usr/lib/modules/3.10.0-229.el7.x86_64/kernel/fs/ext4/ext4.ko
 usr/lib/modules/3.10.0-229.el7.x86_64/kernel/fs/nfs
 usr/lib/modules/3.10.0-229.el7.x86_64/kernel/fs/nfs/nfs.ko
<span class="term_say"># 你可以看得到，新增的模块现在正在新的 initramfs 当中了呢！很愉快喔！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 220--------------------------------------------------<br/>--------------------------------------------------221--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">grub2-install [--boot-directory=DIR] INSTALL_DEVICE</span>
<span class="term_say">选项与参数：
--boot-directory=DIR 那个 DIR 为实际的目录，使用 grub2-install 默认会将
  grub2 所有的文件都复制到 /boot/grub2/* ，如果想要复制到其他目录与设备去，
  就得要用这个参数。
INSTALL_DEVICE 安装的设备代号啦！</span>

<span class="term_hd">范例一：将 grub2 安装在目前系统的 MBR 下面，我的系统为 /dev/vda：</span>
[root@study ~]# <span class="term_command">grub2-install /dev/vda</span>
<span class="term_say"># 因为原本 /dev/vda 就是使用 grub2 ，所以似乎不会出现什么特别的讯息。
# 如果去查阅一下 /boot/grub2 的内容，会发现所有的文件都更新了，因为我们重装了！
# 但是注意到，我们并没有配置文件喔！那要自己创建！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 221--------------------------------------------------<br/>--------------------------------------------------222--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">dmidecode -t type</span>
<span class="term_say">选项与参数：
详细的 type 项目请 man dmidecode 查询更多的数据，这里仅列出比较常用的项目：
1 ：详细的系统数据，含主板的型号与硬件的基础数据等
4 ：CPU 的相关数据，包括倍频、外频、核心数、核心绪数等
9 ：系统的相关插槽格式，包括 PCI, PCI-E 等等的插槽规格说明
17：每一个内存插槽的规格，若内有内存，则列出该内存的容量与型号</span>

<span class="term_hd">范例一：秀出整个系统的硬件信息，例如主板型号等等</span>
[root@study ~]# <span class="term_command">dmidecode -t 1</span>
# dmidecode 2.12
SMBIOS 2.4 present.

Handle 0x0100, DMI type 1, 27 Bytes
System Information
        Manufacturer: Red Hat
        Product Name: KVM
        Version: RHEL 6.6.0 PC
        Serial Number: Not Specified
        UUID: AA3CB5D1-4F42-45F7-8DBF-575445D3887F
        Wake-up Type: Power Switch
        SKU Number: Not Specified
        Family: Red Hat Enterprise Linux

<span class="term_hd">范例二：那内存相关的数据呢？</span>
[root@study ~]# <span class="term_command">dmidecode -t 17</span>
# dmidecode 2.12
SMBIOS 2.4 present.

Handle 0x1100, DMI type 17, 21 Bytes
Memory Device
        Array Handle: 0x1000
        Error Information Handle: 0x0000
        Total Width: 64 bits
        Data Width: 64 bits
        Size: 3072 MB
        Form Factor: DIMM
        Set: None
        Locator: DIMM 0
        Bank Locator: Not Specified
        Type: RAM
        Type Detail: None
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 222--------------------------------------------------<br/>--------------------------------------------------223--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">lspci [-vvn]</span>
<span class="term_say">选项与参数：
-v  ：显示更多的 PCI 接口设备的详细信息；
-vv ：比 -v 还要更详细的细部信息；
-n  ：直接观察 PCI 的 ID 而不是厂商名称</span>

<span class="term_hd">范例一：查阅您系统内的 PCI 总线相关设备：</span>
[root@study ~]# <span class="term_command">lspci</span>
<span class="calibre85">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] （rev 02）
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]
00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] （rev 01）
00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI （rev 03）
00:02.0 VGA compatible controller: Red Hat, Inc. QXL paravirtual graphic card （rev 04）
00:03.0 Ethernet controller: Red Hat, Inc Virtio network device
00:04.0 SCSI storage controller: Red Hat, Inc Virtio block device
00:05.0 RAM memory: Red Hat, Inc Virtio memory balloon
00:06.0 Audio device: Intel Corporation 82801FB/FBM/FR/FW/FRW （ICH6 Family） High Definition Audio
        Controller （rev 01）
00:1d.0 USB controller: Intel Corporation 82801I （ICH9 Family） USB UHCI Controller #1 （rev 03）
00:1d.1 USB controller: Intel Corporation 82801I （ICH9 Family） USB UHCI Controller #2 （rev 03）
00:1d.2 USB controller: Intel Corporation 82801I （ICH9 Family） USB UHCI Controller #3 （rev 03）
00:1d.7 USB controller: Intel Corporation 82801I （ICH9 Family） USB2 EHCI Controller #1 （rev 03）</span>
<span class="term_say"># 不必加任何的参数，就能够显示出目前主机上面的各个 PCI 接口的设备呢！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 223--------------------------------------------------<br/>--------------------------------------------------224--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">lsusb [-t]</span>
<span class="term_say">选项与参数：
-t  ：使用类似树状目录来显示各个 USB 端口的相关性</span>

<span class="term_hd">范例一：列出目前鸟哥的测试用主机 USB 各端口状态</span>
[root@study ~]# <span class="term_command">lsusb</span>
Bus 002 Device 002: ID 0627:0001 Adomax Technology Co., Ltd
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
<span class="term_say"># 如上所示，鸟哥的主机在 Bus 002 有接了一个设备，
# 该设备的 ID 是 0627:0001，对应的厂商与产品为 Adomax 的设备。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 224--------------------------------------------------<br/>--------------------------------------------------225--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">iostat [-c|-d] [-k|-m] [-t] [间隔秒数] [侦测次数]</span>
<span class="term_say">选项与参数：
-c  ：仅显示 CPU 的状态；
-d  ：仅显示储存设备的状态，不可与 -c 一起用；
-k  ：默认显示的是 block ，这里可以改成 K Bytes 的大小来显示；
-m  ：与 -k 类似，只是以 MB 的单位来显示结果。
-t  ：显示日期出来；</span>

<span class="term_hd">范例一：显示一下目前整个系统的 CPU 与储存设备的状态</span>
[root@study ~]# <span class="term_command">iostat</span>
Linux 3.10.0-229.el7.x86_64 （study.centos.vbird）  09/02/2015   _x86_64_    （4 CPU）

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.08    0.01    0.02    0.00    0.01   99.88

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.46         5.42         3.16     973670     568007
scd0              0.00         0.00         0.00        154          0
sda               0.01         0.03         0.00       4826          0
dm-0              0.23         4.59         3.09     825092     555621
<span class="term_say"># 瞧！上面数据总共分为上下两部分，上半部显示的是 CPU 的当下信息；
# 下面数据则是显示储存设备包括 /dev/vda 的相关数据，他的数据意义：
# tps       ：平均每秒钟的传送次数！与数据传输“次数”有关，非容量！
# kB_read/s ：开机到现在平均的读取单位；
# kB_wrtn/s ：开机到现在平均的写入单位；
# kB_read   ：开机到现在，总共读出来的文件单位；
# kB_wrtn   ：开机到现在，总共写入的文件单位；</span>

<span class="term_hd">范例二：仅针对 vda ，每两秒钟侦测一次，并且共侦测三次储存设备</span>
[root@study ~]# <span class="term_command">iostat -d 2 3 vda</span>
Linux 3.10.0-229.el7.x86_64 （study.centos.vbird）  09/02/2015   _x86_64_    （4 CPU）

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.46         5.41         3.16     973682     568148

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               1.00         0.00         0.50          0          1

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.00         0.00         0.00          0          0
<span class="term_say"># 仔细看一下，如果是有侦测次数的情况，那么第一次显示的是“从开机到现在的数据”，
# 第二次以后所显示的数据则代表两次侦测之间的系统传输值！举例来说，上面的信息中，
# 第二次显示的数据，则是两秒钟内（本案例）系统的总传输量与平均值。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 225--------------------------------------------------<br/>--------------------------------------------------226--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">ldconfig [-f conf] [ -C cache]</span>
[root@study ~]# <span class="term_command">ldconfig [-p]</span>
<span class="term_say">选项与参数：
-f conf ：那个 conf 指的是某个文件名称，也就是说，使用 conf 作为 libarary 
	  函数库的取得路径，而不以 /etc/ld.so.conf 为默认值
-C cache：那个 cache 指的是某个文件名称，也就是说，使用 cache 作为高速缓存暂存
	  的函数库数据，而不以 /etc/ld.so.cache 为默认值
-p	：列出目前有的所有函数库数据内容 （在 /etc/ld.so.cache 内的数据！）</span>

<span class="term_hd">范例一：假设我的 Mariadb 数据库函数库在 /usr/lib64/mysql 当中，如何读进 cache ？</span>
[root@study ~]# <span class="term_command">vim /etc/ld.so.conf.d/vbird.conf</span>
<span class="term_command">/usr/lib64/mysql</span>   <span class="term_note">&lt;==这一行新增的啦！</span>

[root@study ~]# <span class="term_command">ldconfig</span>  <span class="term_note">&lt;==画面上不会显示任何的信息，不要太紧张！正常的！</span>

[root@study ~]# <span class="term_command">ldconfig -p</span>
924 libs found in cache `/etc/ld.so.cache'
        p11-kit-trust.so （libc6,x86-64） =&gt; /lib64/p11-kit-trust.so
        libzapojit-0.0.so.0 （libc6,x86-64） =&gt; /lib64/libzapojit-0.0.so.0
<span class="term_say">....（下面省略）....</span>
<span class="term_say">#       函数库名称 =&gt; 该函数库实际路径</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 226--------------------------------------------------<br/>--------------------------------------------------227--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">ldd [-vdr] [filename]</span>
<span class="term_say">选项与参数：
-v ：列出所有内容信息；
-d ：重新将数据有遗失的 link 点秀出来！
-r ：将 ELF 有关的错误内容秀出来！</span>

<span class="term_hd">范例一：找出 /usr/bin/passwd 这个文件的函数库数据</span>
[root@study ~]# <span class="term_command">ldd /usr/bin/passwd</span>
<span class="term_say">....（前面省略）....</span>
        libpam.so.0 =&gt; /lib64/libpam.so.0 （0x00007f5e683dd000）            <span class="term_note">&lt;==PAM 模块</span>
        libpam_misc.so.0 =&gt; /lib64/libpam_misc.so.0 （0x00007f5e681d8000）
        libaudit.so.1 =&gt; /lib64/libaudit.so.1 （0x00007f5e67fb1000）        <span class="term_note">&lt;==SELinux</span>
        libselinux.so.1 =&gt; /lib64/libselinux.so.1 （0x00007f5e67d8c000）    <span class="term_note">&lt;==SELinux</span>
<span class="term_say">....（下面省略）....</span>
<span class="term_say"># 我们前言的部分不是一直提到 passwd 有使用到 pam 的模块吗！怎么知道？
# 利用 ldd 察看一下这个文件，看到 libpam.so 了吧？这就是 pam 提供的函数库</span>

<span class="term_hd">范例二：找出 /lib64/libc.so.6 这个函数的相关其他函数库！</span>
[root@study ~]# <span class="term_command">ldd -v /lib64/libc.so.6</span>
        /lib64/ld-linux-x86-64.so.2 （0x00007f7acc68f000）
        linux-vdso.so.1 =&gt;  （0x00007fffa975b000）

        Version information:  <span class="term_note">&lt;==使用 -v 选项，增加显示其他版本信息！</span>
        /lib64/libc.so.6:
                ld-linux-x86-64.so.2 （GLIBC_2.3） =&gt; /lib64/ld-linux-x86-64.so.2
                ld-linux-x86-64.so.2 （GLIBC_PRIVATE） =&gt; /lib64/ld-linux-x86-64.so.2
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 227--------------------------------------------------<br/>--------------------------------------------------228--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">md5sum/sha1sum/sha256sum [-bct] filename</span>
[root@study ~]# <span class="term_command">md5sum/sha1sum/sha256sum [--status|--warn] --check filename</span>
<span class="term_say">选项与参数：
-b ：使用 binary 的读档方式，默认为 Windows/DOS 文件型态的读取方式；
-c ：检验文件指纹；
-t ：以文字体态来读取文件指纹。</span>

<span class="term_hd">范例一：将刚刚的文件下载后，测试看看指纹码</span>
[root@study ~]# <span class="term_command">md5sum ntp-4.2.8p3.tar.gz</span>
b98b0cbb72f6df04608e1dd5f313808b  ntp-4.2.8p3.tar.gz
<span class="term_say"># 看！显示的编码是否与上面相同呢？赶紧测试看看！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 228--------------------------------------------------<br/>--------------------------------------------------229--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">rpm -ivh package_name</span>
<span class="term_say">选项与参数：
-i ：install 的意思
-v ：察看更细部的安装信息画面
-h ：以安装信息列显示安装进度</span>

<span class="term_hd">范例一：安装原版光盘上的 rp-pppoe 软件</span>
[root@study ~]# <span class="term_command">rpm -ivh /mnt/Packages/rp-pppoe-3.11-5.el7.x86_64.rpm</span>
Preparing...                          ################################# [100%]
Updating / installing...
   1:rp-pppoe-3.11-5.el7              ################################# [100%]

<span class="term_hd">范例二、一口气安装两个以上的软件时：</span>
[root@study ~]# <span class="term_command">rpm -ivh a.i386.rpm b.i386.rpm *.rpm</span>
<span class="term_say"># 后面直接接上许多的软件文件！</span>

<span class="term_hd">范例三、直接由网络上面的某个文件安装，以网址来安装：</span>
[root@study ~]# <span class="term_command">rpm -ivh http://website.name/path/pkgname.rpm</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 229--------------------------------------------------<br/>--------------------------------------------------230--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：找出你的 Linux 是否有安装 logrotate 这个软件？</span>
[root@study ~]# <span class="term_command">rpm -q logrotate</span>
logrotate-3.8.6-4.el7.x86_64
[root@study ~]# <span class="term_command">rpm -q logrotating</span>
package logrotating is not installed
<span class="term_say"># 注意到，系统会去找是否有安装后面接的软件名称。注意，不必要加上版本喔！
# 至于显示的结果，一看就知道有没有安装啦！</span>

<span class="term_hd">范例二：列出上题当中，属于该软件所提供的所有目录与文件：</span>
[root@study ~]# <span class="term_command">rpm -ql logrotate</span>
/etc/cron.daily/logrotate
/etc/logrotate.conf
<span class="term_say">....（以下省略）....</span>
<span class="term_say"># 可以看出该软件到底提供了多少的文件与目录，也可以追踪软件的数据。</span>

<span class="term_hd">范例三：列出 logrotate 这个软件的相关说明数据：</span>
[root@study ~]# <span class="term_command">rpm -qi logrotate</span>
Name        : logrotate                          <span class="term_note"># 软件名称</span>
Version     : 3.8.6                              <span class="term_note"># 软件的版本</span>
Release     : 4.el7                              <span class="term_note"># 释出的版本</span>
Architecture: x86_64                             <span class="term_note"># 编译时所针对的硬件等级</span>
Install Date: Mon 04 May 2015 05:52:36 PM CST    <span class="term_note"># 这个软件安装到本系统的时间</span>
Group       : System Environment/Base            <span class="term_note"># 软件是放再哪一个软件群组中</span>
Size        : 102451                             <span class="term_note"># 软件的大小</span>
License     : GPL+                               <span class="term_note"># 释出的授权方式</span>
Signature   : RSA/SHA256, Fri 04 Jul 2014 11:34:56 AM CST, Key ID 24c6a8a7f4a80eb5
Source RPM  : logrotate-3.8.6-4.el7.src.rpm      <span class="term_note"># 这就是 SRPM 的文件名</span>
Build Date  : Tue 10 Jun 2014 05:58:02 AM CST    <span class="term_note"># 软件编译打包的时间</span>
Build Host  : worker1.bsys.centos.org            <span class="term_note"># 在哪一部主机上面编译的</span>
Relocations : （not relocatable）   
Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;
Vendor      : CentOS
URL         : https://fedorahosted.org/logrotate/
Summary     : Rotates, compresses, removes and mails system log files
Description :                                    <span class="term_note"># 这个是详细的描述！</span>
The logrotate utility is designed to simplify the administration of
log files on a system which generates a lot of log files.  Logrotate
allows for the automatic rotation compression, removal and mailing of
log files.  Logrotate can be set to handle a log file daily, weekly,
monthly or when the log file gets to a certain size.  Normally,
logrotate runs as a daily cron job.

Install the logrotate package if you need a utility to deal with the
log files on your system.
<span class="term_say"># 列出该软件的 information （信息），里面的信息可多着呢，包括了软件名称、
# 版本、开发商、SRPM文件名称、打包次数、简单说明信息、软件打包者、
# 安装日期等等！如果想要详细的知道该软件的数据，用这个参数来了解一下</span>

<span class="term_hd">范例四：分别仅找出 logrotate 的配置文件与说明文档</span>
[root@study ~]# <span class="term_command">rpm -qc logrotate</span>
[root@study ~]# <span class="term_command">rpm -qd logrotate</span>

<span class="term_hd">范例五：若要成功安装 logrotate ，他还需要什么文件的帮忙？</span>
[root@study ~]# <span class="term_command">rpm -qR logrotate</span>
/bin/sh
config（logrotate） = 3.8.6-4.el7
coreutils &gt;= 5.92
<span class="term_say">....（以下省略）....
# 由这里看起来，呵呵～还需要很多文件的支持才行喔！</span>

<span class="term_hd">范例六：由上面的范例五，找出 /bin/sh 是那个软件提供的？</span>
[root@study ~]# <span class="term_command">rpm -qf /bin/sh</span>
bash-4.2.46-12.el7.x86_64
<span class="term_say"># 这个参数后面接的可是“文件”呐！不像前面都是接软件喔！
# 这个功能在查询系统的某个文件属于哪一个软件所有的。</span>

<span class="term_hd">范例七：假设我有下载一个 RPM 文件，想要知道该文件的需求文件，该如何？</span>
[root@study ~]# <span class="term_command">rpm -qpR filename.i386.rpm</span>
<span class="term_say"># 加上 -qpR ，找出该文件需求的数据！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 230--------------------------------------------------<br/>--------------------------------------------------231--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">rpm -Va</span>
[root@study ~]# <span class="term_command">rpm -V  已安装的软件名称</span>
[root@study ~]# <span class="term_command">rpm -Vp 某个 RPM 文件的文件名</span>
[root@study ~]# <span class="term_command">rpm -Vf 在系统上面的某个文件</span>
<span class="term_say">选项与参数：
-V  ：后面加的是软件名称，若该软件所含的文件被更动过，才会列出来；
-Va ：列出目前系统上面所有可能被更动过的文件；
-Vp ：后面加的是文件名称，列出该软件内可能被更动过的文件；
-Vf ：列出某个文件是否被更动过～</span>

<span class="term_hd">范例一：列出你的 Linux 内的 logrotate 这个软件是否被更动过？</span>
[root@study ~]# <span class="term_command">rpm -V logrotate</span>
<span class="term_say"># 如果没有出现任何讯息，恭喜你，该软件所提供的文件没有被更动过。
# 如果有出现任何讯息，才是有出现状况啊！</span>

<span class="term_hd">范例二：查询一下，你的 /etc/crontab 是否有被更动过？</span>
[root@study ~]# <span class="term_command">rpm -Vf /etc/crontab</span>
.......T.  c /etc/crontab
<span class="term_say"># 瞧！因为有被更动过，所以会列出被更动过的信息类型！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 231--------------------------------------------------<br/>--------------------------------------------------232--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd"># 1. 找出与 pam 有关的软件名称，并尝试移除 pam 这个软件：</span>
[root@study ~]# <span class="term_command">rpm -qa | grep pam</span>
fprintd-pam-0.5.0-4.0.el7_0.x86_64
pam-1.1.8-12.el7.x86_64
gnome-keyring-pam-3.8.2-10.el7.x86_64
pam-devel-1.1.8-12.el7.x86_64
pam_krb5-2.4.8-4.el7.x86_64
[root@study ~]# <span class="term_command">rpm -e pam</span>
error: Failed dependencies:  <span class="term_note">&lt;==这里提到的是相依性的问题</span>
        libpam.so.0（）（64bit） is needed by （installed） systemd-libs-208-20.el7.x86_64
        libpam.so.0（）（64bit） is needed by （installed） libpwquality-1.2.3-4.el7.x86_64
<span class="term_say">....（以下省略）....</span>

<span class="term_hd"># 2. 若仅移除 pam-devel 这个之前范例安装上的软件呢？</span>
[root@study ~]# <span class="term_command">rpm -e pam-devel</span>  <span class="term_note">&lt;==不会出现任何讯息！</span>
[root@study ~]# <span class="term_command">rpm -q pam-devel</span>
package pam-devel is not installed
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 232--------------------------------------------------<br/>--------------------------------------------------233--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">yum [option] [查询工作项目] [相关参数]</span>
<span class="term_say">选项与参数：
[option]：主要的选项，包括有：
  -y ：当 yum 要等待使用者输入时，这个选项可以自动提供 yes 的回应；
  --installroot=/some/path ：将该软件安装在 /some/path 而不使用默认路径
[查询工作项目] [相关参数]：这方面的参数有：
  search  ：搜寻某个软件名称或者是描述 （description） 的重要关键字；
  list    ：列出目前 yum 所管理的所有的软件名称与版本，有点类似 rpm -qa；
  info    ：同上，不过有点类似 rpm -qai 的执行结果；
  provides：从文件去搜寻软件！类似 rpm -qf 的功能！</span>

<span class="term_hd">范例一：搜寻磁盘阵列 （raid） 相关的软件有哪些？</span>
[root@study ~]# <span class="term_command">yum search raid</span>
Loaded plugins: fastestmirror, langpacks      <span class="term_note"># yum 系统自己找出最近的 yum server</span>
Loading mirror speeds from cached hostfile    <span class="term_note"># 找出速度最快的那一部 yum server</span>
 * base: ftp.twaren.net                       <span class="term_note"># 下面三个软件库，且来源为该服务器！</span>
 * extras: ftp.twaren.net
 * updates: ftp.twaren.net
<span class="term_say">....（前面省略）....</span>
dmraid-events-logwatch.x86_64 : dmraid logwatch-based email reporting
dmraid-events.x86_64 : dmevent_tool （Device-mapper event tool） and DSO
iprutils.x86_64 : Utilities for the IBM Power Linux RAID adapters
mdadm.x86_64 : The mdadm program controls Linux md devices （software RAID arrays）
<span class="term_say">....（后面省略）....
# 在冒号 （:）  左边的是软件名称，右边的则是在 RPM 内的 name 设置 （软件名）
# 瞧！上面的结果，这不就是与 RAID 有关的软件吗？如果想了解 mdadm 的软件内容呢？</span>

<span class="term_hd">范例二：找出 mdadm 这个软件的功能为何</span>
[root@study ~]# <span class="term_command">yum info mdadm</span>
Installed Packages       <span class="term_note">&lt;==这说明该软件是已经安装的了</span>
Name        : mdadm      <span class="term_note">&lt;==这个软件的名称</span>
Arch        : x86_64     <span class="term_note">&lt;==这个软件的编译架构</span>
Version     : 3.3.2      <span class="term_note">&lt;==此软件的版本</span>
Release     : 2.el7      <span class="term_note">&lt;==释出的版本</span>
Size        : 920 k      <span class="term_note">&lt;==此软件的文件总容量</span>
Repo        : installed  <span class="term_note">&lt;==软件库回报说已安装的</span>
From repo   : anaconda
Summary     : The mdadm program controls Linux md devices （software RAID arrays）
URL         : http://www.kernel.org/pub/linux/utils/raid/mdadm/
License     : GPLv2+
Description : The mdadm program is used to create, manage, and monitor Linux MD （software
            : RAID） devices.  As such, it provides similar functionality to the raidtools
            : package.  However, mdadm is a single program, and it can perform
            : almost all functions without a configuration file, though a configuration
            : file can be used to help with some common tasks.
<span class="term_say"># 不要跟我说，上面说些啥？自己找字典翻一翻吧！拜托拜托！</span>

<span class="term_hd">范例三：列出 yum 服务器上面提供的所有软件名称</span>
[root@study ~]# <span class="term_command">yum list</span>
Installed Packages   <span class="term_note">&lt;==已安装软件</span>
GConf2.x86_64                           3.2.6-8.el7                    @anaconda
LibRaw.x86_64                           0.14.8-5.el7.20120830git98d925 @base
ModemManager.x86_64                     1.1.0-6.git20130913.el7        @anaconda
<span class="term_say">....（中间省略）....</span>
Available Packages   <span class="term_note">&lt;==还可以安装的其他软件</span>
389-ds-base.x86_64                      1.3.3.1-20.el7_1               updates
389-ds-base-devel.x86_64                1.3.3.1-20.el7_1               updates
389-ds-base-libs.x86_64                 1.3.3.1-20.el7_1               updates
<span class="term_say">....（下面省略）....
# 上面提供的意义为：“ 软件名称   版本   在那个软件库内 ”</span>

<span class="term_hd">范例四：列出目前服务器上可供本机进行升级的软件有哪些？</span>
[root@study ~]# <span class="term_command">yum list updates</span>  <span class="term_note">&lt;==一定要是 update<span class="calibre34">s</span> 喔！</span>
Updated Packages
NetworkManager.x86_64          1:1.0.0-16.git20150121.b4ea599c.el7_1       updates
NetworkManager-adsl.x86_64     1:1.0.0-16.git20150121.b4ea599c.el7_1       updates
<span class="term_say">....（下面省略）....
# 上面就列出在那个软件库内可以提供升级的软件与版本！</span>

<span class="term_hd">范例五：列出提供 passwd 这个文件的软件有哪些</span>
[root@study ~]# <span class="term_command">yum provides passwd</span>
passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM
Repo        : base

passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM
Repo        : @anaconda
<span class="term_say"># 找到啦！就是上面的这个软件提供了 passwd 这个程序！</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 233--------------------------------------------------<br/>--------------------------------------------------234--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">yum [option] [安装与升级的工作项目] [相关参数]</span>
<span class="term_say">选项与参数：
  install ：后面接要安装的软件！
  update  ：后面接要升级的软件，若要整个系统都升级，就直接 update 即可</span>

<span class="term_hd">范例一：将前一个练习找到的未安装的 pam-devel 安装起来</span>
[root@study ~]# <span class="term_command">yum install pam-devel</span>
Loaded plugins: fastestmirror, langpacks    <span class="term_note"># 首先的 5 行在找出最快的 yum server</span>
Loading mirror speeds from cached hostfile
 * base: ftp.twaren.net
 * extras: ftp.twaren.net
 * updates: ftp.twaren.net
Resolving Dependencies                      <span class="term_note"># 接下来先处理“属性相依”的软件问题</span>
--&gt; Running transaction check
---&gt; Package pam-devel.x86_64 0:1.1.8-12.el7_1.1 will be installed
--&gt; Processing Dependency: pam（x86-64） = 1.1.8-12.el7_1.1 for package: pam-devel-
       1.1.8-12.el7_1.1.x86_64
--&gt; Running transaction check
---&gt; Package pam.x86_64 0:1.1.8-12.el7 will be updated 
---&gt; Package pam.x86_64 0:1.1.8-12.el7_1.1 will be an update
--&gt; Finished Dependency Resolution
Dependencies Resolved

<span class="term_say"># 由上面的检查发现到 pam 这个软件也需要同步升级，这样才能够安装新版 pam-devel 喔！
# 至于下面则是一个总结的表格显示！</span>
==========================================================================================
 Package             Arch             Version                     Repository         Size
==========================================================================================
Installing:
 pam-devel           x86_64           1.1.8-12.el7_1.1            updates           183 k
Updating for dependencies:
 pam                 x86_64           1.1.8-12.el7_1.1            updates           714 k

Transaction Summary
==========================================================================================
Install  1 Package                          <span class="term_note"># 要安装的是一个软件</span>
Upgrade             （ 1 Dependent package）  <span class="term_note"># 因为相依属性问题，需要额外加装一个软件！</span>

Total size: 897 k
Total download size: 183 k                  <span class="term_note"># 总共需要下载的容量！</span>
Is this ok [y/d/N]: <span class="term_command">y</span>   <span class="term_note"># 你得要自己决定是否要下载与安装！当然是 y 啊！</span>
Downloading packages:                       <span class="term_note"># 开始下载啰！</span>
warning: /var/cache/yum/x86_64/7/updates/packages/pam-devel-1.1.8-12.el7_1.1.x86_64.rpm:
         Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY
Public key for pam-devel-1.1.8-12.el7_1.1.x86_64.rpm is not installed
pam-devel-1.1.8-12.el7_1.1.x86_64.rpm                              | 183 kB  00:00:00
Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
Importing GPG key 0xF4A80EB5:
 Userid     : "CentOS-7 Key （CentOS 7 Official Signing Key） &lt;security@centos.org&gt;"
 Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5
 Package    : centos-release-7-1.1503.el7.centos.2.8.x86_64 （@anaconda）
 From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
Is this ok [y/N]: <span class="term_command">y</span>  <span class="term_note"># 只有在第一次安装才会出现这个项目“确定要安装数码签章”才能继续！</span>
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
Warning: RPMDB altered outside of yum.
  Updating   : pam-1.1.8-12.el7_1.1.x86_64                                            1/3
  Installing : pam-devel-1.1.8-12.el7_1.1.x86_64                                      2/3
  Cleanup    : pam-1.1.8-12.el7.x86_64                                                3/3
  Verifying  : pam-1.1.8-12.el7_1.1.x86_64                                            1/3
  Verifying  : pam-devel-1.1.8-12.el7_1.1.x86_64                                      2/3
  Verifying  : pam-1.1.8-12.el7.x86_64                                                3/3

Installed:
  pam-devel.x86_64 0:1.1.8-12.el7_1.1

Dependency Updated:
  pam.x86_64 0:1.1.8-12.el7_1.1

Complete!
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 234--------------------------------------------------<br/>--------------------------------------------------235--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33"><span class="term_hd">范例一：列出目前 yum server 所使用的软件库有哪些？</span>
[root@study ~]# <span class="term_command">yum repolist all</span>
<span class="calibre34">repo id                              repo name                         status</span>
C7.0.1406-base/x86_64                CentOS-7.0.1406 - Base            disabled
C7.0.1406-centosplus/x86_64          CentOS-7.0.1406 - CentOSPlus      disabled
C7.0.1406-extras/x86_64              CentOS-7.0.1406 - Extras          disabled
C7.0.1406-fasttrack/x86_64           CentOS-7.0.1406 - CentOSPlus      disabled
C7.0.1406-updates/x86_64             CentOS-7.0.1406 - Updates         disabled
<span class="calibre34">base                                 CentOS-7 - Base                   enabled: 8,652</span>
base-debuginfo/x86_64                CentOS-7 - Debuginfo              disabled
base-source/7                        CentOS-7 - Base Sources           disabled
centosplus/7/x86_64                  CentOS-7 - Plus                   disabled
centosplus-source/7                  CentOS-7 - Plus Sources           disabled
cr/7/x86_64                          CentOS-7 - cr                     disabled
<span class="calibre34">extras                               CentOS-7 - Extras                 enabled:   181</span>
extras-source/7                      CentOS-7 - Extras Sources         disabled
fasttrack/7/x86_64                   CentOS-7 - fasttrack              disabled
<span class="calibre34">updates                              CentOS-7 - Updates                enabled: 1,302</span>
updates-source/7                     CentOS-7 - Updates Sources        disabled
repolist: 10,135
<span class="term_say"># 上面最右边有写 enabled 才是有启动的！由于 /etc/yum.repos.d/
# 有多个配置文件，所以你会发现还有其他的软件库存在。</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 235--------------------------------------------------<br/>--------------------------------------------------236--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">yum clean [packages|headers|all] </span>
<span class="term_say">选项与参数：
 packages：将已下载的软件文件删除
 headers ：将下载的软件文件开始删除
 all     ：将所有软件库数据都删除！</span>

<span class="term_hd">范例一：删除已下载过的所有软件库的相关数据 （含软件本身与清单）</span>
[root@study ~]# <span class="term_command">yum clean all</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 236--------------------------------------------------<br/>--------------------------------------------------237--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">yum [群组功能] [软件群组]</span>
<span class="term_say">选项与参数：
   grouplist   ：列出所有可使用的“软件群组组”，例如 Development Tools 之类的；
   groupinfo   ：后面接 group_name，则可了解该 group 内含的所有软件名；
   groupinstall：这个好用！可以安装一整组的软件群组，相当的不错用！
   groupremove ：移除某个软件群组；</span>

<span class="term_hd">范例一：查阅目前软件库与本机上面的可用与安装过的软件群组有哪些？</span>
[root@study ~]# <span class="term_command">yum grouplist</span>
Installed environment groups:            <span class="term_note"># 已经安装的系统环境软件群组</span>
   Development and Creative Workstation
Available environment groups:            <span class="term_note"># 还可以安装的系统环境软件群组</span>
   Minimal Install
   Compute Node
   Infrastructure Server
   File and Print Server
   Basic Web Server
   Virtualization Host
   Server with GUI
   GNOME Desktop
   KDE Plasma Workspaces
Installed groups:                        <span class="term_note"># 已经安装的软件群组！</span>
   Development Tools
Available Groups:                        <span class="term_note"># 还能额外安装的软件群组！</span>
   Compatibility Libraries
   Console Internet Tools
   Graphical Administration Tools
   Legacy UNIX Compatibility
   Scientific Support
   Security Tools
   Smart Card Support
   System Administration Tools
   System Management
Done
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 237--------------------------------------------------<br/>--------------------------------------------------238--------------------------------------------------<table class="term"><tbody class="calibre16"><tr class="calibre17"><td class="term1"><pre class="calibre33">[root@study ~]# <span class="term_command">startx [X client 参数] -- [X server 参数]</span>

<span class="term_hd"># 范例：以色彩深度为 16 bit 启动 X</span>
[root@study ~]# <span class="term_command">startx  --  -depth 16</span>
</pre>
</td>
</tr>
</tbody>
</table>-------------------------------------------------- 238--------------------------------------------------<br/>